"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.describeListenersByLoadBalancerArn = exports.tagsMatch = exports.describeTags = exports.describeLoadBalancers = exports.LoadBalancerListenerContextProviderPlugin = exports.LoadBalancerContextProviderPlugin = void 0;
const cxapi = require("@aws-cdk/cx-api");
const credentials_1 = require("../api/aws-auth/credentials");
/**
 * Provides load balancer context information.
 */
class LoadBalancerContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(query) {
        const options = { assumeRoleArn: query.lookupRoleArn };
        const elbv2 = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(query.account, query.region), credentials_1.Mode.ForReading, options)).sdk.elbv2();
        if (!query.loadBalancerArn && !query.loadBalancerTags) {
            throw new Error('The load balancer lookup query must specify either `loadBalancerArn` or `loadBalancerTags`');
        }
        const loadBalancers = await findLoadBalancers(elbv2, query);
        if (loadBalancers.length === 0) {
            throw new Error(`No load balancers found matching ${JSON.stringify(query)}`);
        }
        if (loadBalancers.length > 1) {
            throw new Error(`Multiple load balancers found matching ${JSON.stringify(query)} - please provide more specific criteria`);
        }
        const loadBalancer = loadBalancers[0];
        const ipAddressType = loadBalancer.IpAddressType === 'ipv4'
            ? cxapi.LoadBalancerIpAddressType.IPV4
            : cxapi.LoadBalancerIpAddressType.DUAL_STACK;
        return {
            loadBalancerArn: loadBalancer.LoadBalancerArn,
            loadBalancerCanonicalHostedZoneId: loadBalancer.CanonicalHostedZoneId,
            loadBalancerDnsName: loadBalancer.DNSName,
            vpcId: loadBalancer.VpcId,
            securityGroupIds: loadBalancer.SecurityGroups ?? [],
            ipAddressType: ipAddressType,
        };
    }
}
exports.LoadBalancerContextProviderPlugin = LoadBalancerContextProviderPlugin;
/**
 * Provides load balancer listener context information
 */
class LoadBalancerListenerContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(query) {
        const options = { assumeRoleArn: query.lookupRoleArn };
        const elbv2 = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(query.account, query.region), credentials_1.Mode.ForReading, options)).sdk.elbv2();
        if (!query.listenerArn && !query.loadBalancerArn && !query.loadBalancerTags) {
            throw new Error('The load balancer listener query must specify at least one of: `listenerArn`, `loadBalancerArn` or `loadBalancerTags`');
        }
        return query.listenerArn ? this.getListenerByArn(elbv2, query) : this.getListenerByFilteringLoadBalancers(elbv2, query);
    }
    /**
     * Look up a listener by querying listeners for query's listener arn and then
     * resolve its load balancer for the security group information.
     */
    async getListenerByArn(elbv2, query) {
        const listenerArn = query.listenerArn;
        const listenerResults = await elbv2.describeListeners({ ListenerArns: [listenerArn] }).promise();
        const listeners = (listenerResults.Listeners ?? []);
        if (listeners.length === 0) {
            throw new Error(`No load balancer listeners found matching arn ${listenerArn}`);
        }
        const listener = listeners[0];
        const loadBalancers = await findLoadBalancers(elbv2, {
            ...query,
            loadBalancerArn: listener.LoadBalancerArn,
        });
        if (loadBalancers.length === 0) {
            throw new Error(`No associated load balancer found for listener arn ${listenerArn}`);
        }
        const loadBalancer = loadBalancers[0];
        return {
            listenerArn: listener.ListenerArn,
            listenerPort: listener.Port,
            securityGroupIds: loadBalancer.SecurityGroups ?? [],
        };
    }
    /**
     * Look up a listener by starting from load balancers, filtering out
     * unmatching load balancers, and then by querying the listeners of each load
     * balancer and filtering out unmatching listeners.
     */
    async getListenerByFilteringLoadBalancers(elbv2, args) {
        // Find matching load balancers
        const loadBalancers = await findLoadBalancers(elbv2, args);
        if (loadBalancers.length === 0) {
            throw new Error(`No associated load balancers found for load balancer listener query ${JSON.stringify(args)}`);
        }
        return this.findMatchingListener(elbv2, loadBalancers, args);
    }
    /**
     * Finds the matching listener from the list of load balancers. This will
     * error unless there is exactly one match so that the user is prompted to
     * provide more specific criteria rather than us providing a nondeterministic
     * result.
     */
    async findMatchingListener(elbv2, loadBalancers, query) {
        const loadBalancersByArn = indexLoadBalancersByArn(loadBalancers);
        const loadBalancerArns = Object.keys(loadBalancersByArn);
        const matches = Array();
        for await (const listener of describeListenersByLoadBalancerArn(elbv2, loadBalancerArns)) {
            const loadBalancer = loadBalancersByArn[listener.LoadBalancerArn];
            if (listenerMatchesQueryFilter(listener, query) && loadBalancer) {
                matches.push({
                    listenerArn: listener.ListenerArn,
                    listenerPort: listener.Port,
                    securityGroupIds: loadBalancer.SecurityGroups ?? [],
                });
            }
        }
        if (matches.length === 0) {
            throw new Error(`No load balancer listeners found matching ${JSON.stringify(query)}`);
        }
        if (matches.length > 1) {
            throw new Error(`Multiple load balancer listeners found matching ${JSON.stringify(query)} - please provide more specific criteria`);
        }
        return matches[0];
    }
}
exports.LoadBalancerListenerContextProviderPlugin = LoadBalancerListenerContextProviderPlugin;
/**
 * Find load balancers by the given filter args.
 */
async function findLoadBalancers(elbv2, args) {
    // List load balancers
    let loadBalancers = await describeLoadBalancers(elbv2, {
        LoadBalancerArns: args.loadBalancerArn ? [args.loadBalancerArn] : undefined,
    });
    // Filter by load balancer type
    loadBalancers = loadBalancers.filter(lb => lb.Type === args.loadBalancerType);
    // Filter by load balancer tags
    if (args.loadBalancerTags) {
        loadBalancers = await filterLoadBalancersByTags(elbv2, loadBalancers, args.loadBalancerTags);
    }
    return loadBalancers;
}
/**
 * Helper to paginate over describeLoadBalancers
 * @internal
 */
async function describeLoadBalancers(elbv2, request) {
    const loadBalancers = Array();
    let page;
    do {
        page = await elbv2.describeLoadBalancers({
            ...request,
            Marker: page?.NextMarker,
        }).promise();
        loadBalancers.push(...Array.from(page.LoadBalancers ?? []));
    } while (page.NextMarker);
    return loadBalancers;
}
exports.describeLoadBalancers = describeLoadBalancers;
/**
 * Describes the tags of each load balancer and returns the load balancers that
 * match the given tags.
 */
async function filterLoadBalancersByTags(elbv2, loadBalancers, loadBalancerTags) {
    const loadBalancersByArn = indexLoadBalancersByArn(loadBalancers);
    const loadBalancerArns = Object.keys(loadBalancersByArn);
    const matchingLoadBalancers = Array();
    // Consume the items of async generator.
    for await (const tags of describeTags(elbv2, loadBalancerArns)) {
        if (tagsMatch(tags, loadBalancerTags) && loadBalancersByArn[tags.ResourceArn]) {
            matchingLoadBalancers.push(loadBalancersByArn[tags.ResourceArn]);
        }
    }
    return matchingLoadBalancers;
}
/**
 * Generator function that yields `TagDescriptions`. The API doesn't support
 * pagination, so this generator breaks the resource list into chunks and issues
 * the appropriate requests, yielding each tag description as it receives it.
 * @internal
 */
async function* describeTags(elbv2, resourceArns) {
    // Max of 20 resource arns per request.
    const chunkSize = 20;
    for (let i = 0; i < resourceArns.length; i += chunkSize) {
        const chunk = resourceArns.slice(i, Math.min(i + chunkSize, resourceArns.length));
        const chunkTags = await elbv2.describeTags({
            ResourceArns: chunk,
        }).promise();
        for (const tag of chunkTags.TagDescriptions ?? []) {
            yield tag;
        }
    }
}
exports.describeTags = describeTags;
/**
 * Determines if the given TagDescription matches the required tags.
 * @internal
 */
function tagsMatch(tagDescription, requiredTags) {
    const tagsByName = {};
    for (const tag of tagDescription.Tags ?? []) {
        tagsByName[tag.Key] = tag.Value;
    }
    for (const tag of requiredTags) {
        if (tagsByName[tag.key] !== tag.value) {
            return false;
        }
    }
    return true;
}
exports.tagsMatch = tagsMatch;
/**
 * Async generator that produces listener descriptions by traversing the
 * pagination. Because describeListeners only lets you search by one load
 * balancer arn at a time, we request them individually and yield the listeners
 * as they come in.
 * @internal
 */
async function* describeListenersByLoadBalancerArn(elbv2, loadBalancerArns) {
    for (const loadBalancerArn of loadBalancerArns) {
        let page;
        do {
            page = await elbv2.describeListeners({
                LoadBalancerArn: loadBalancerArn,
                Marker: page?.NextMarker,
            }).promise();
            for (const listener of page.Listeners ?? []) {
                yield listener;
            }
        } while (page.NextMarker);
    }
}
exports.describeListenersByLoadBalancerArn = describeListenersByLoadBalancerArn;
/**
 * Determines if a listener matches the query filters.
 */
function listenerMatchesQueryFilter(listener, args) {
    if (args.listenerPort && listener.Port !== args.listenerPort) {
        // No match.
        return false;
    }
    if (args.listenerProtocol && listener.Protocol !== args.listenerProtocol) {
        // No match.
        return false;
    }
    return true;
}
/**
 * Returns a record of load balancers indexed by their arns
 */
function indexLoadBalancersByArn(loadBalancers) {
    const loadBalancersByArn = {};
    for (const loadBalancer of loadBalancers) {
        loadBalancersByArn[loadBalancer.LoadBalancerArn] = loadBalancer;
    }
    return loadBalancersByArn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZC1iYWxhbmNlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsb2FkLWJhbGFuY2Vycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSx5Q0FBeUM7QUFFekMsNkRBQW1EO0FBSW5EOztHQUVHO0FBQ0gsTUFBYSxpQ0FBaUM7SUFDNUMsWUFBNkIsR0FBZ0I7UUFBaEIsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUM3QyxDQUFDO0lBRUQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUF3QztRQUNyRCxNQUFNLE9BQU8sR0FBRyxFQUFFLGFBQWEsRUFBRSxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDdkQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsa0JBQUksQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFOUksSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUN0RCxNQUFNLElBQUksS0FBSyxDQUFDLDRGQUE0RixDQUFDLENBQUM7UUFDaEgsQ0FBQztRQUVELE1BQU0sYUFBYSxHQUFHLE1BQU0saUJBQWlCLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTVELElBQUksYUFBYSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMvRSxDQUFDO1FBRUQsSUFBSSxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQzdCLE1BQU0sSUFBSSxL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LGdCQUFnQixJQUFJLFFBQVEsQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDekUsWUFBWTtRQUNaLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyx1QkFBdUIsQ0FBQyxhQUF1QztJQUN0RSxNQUFNLGtCQUFrQixHQUEyQyxFQUFFLENBQUM7SUFFdEUsS0FBSyxNQUFNLFlBQVksSUFBSSxhQUFhLEVBQUUsQ0FBQztRQUN6QyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsZUFBZ0IsQ0FBQyxHQUFHLFlBQVksQ0FBQztJQUNuRSxDQUFDO0lBRUQsT0FBTyxrQkFBa0IsQ0FBQztBQUM1QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBNb2RlIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL3Nkay1wcm92aWRlcic7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuLi9hcGkvcGx1Z2luJztcblxuLyoqXG4gKiBQcm92aWRlcyBsb2FkIGJhbGFuY2VyIGNvbnRleHQgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2FkQmFsYW5jZXJDb250ZXh0UHJvdmlkZXJQbHVnaW4gaW1wbGVtZW50cyBDb250ZXh0UHJvdmlkZXJQbHVnaW4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGF3czogU2RrUHJvdmlkZXIpIHtcbiAgfVxuXG4gIGFzeW5jIGdldFZhbHVlKHF1ZXJ5OiBjeHNjaGVtYS5Mb2FkQmFsYW5jZXJDb250ZXh0UXVlcnkpOiBQcm9taXNlPGN4YXBpLkxvYWRCYWxhbmNlckNvbnRleHRSZXNwb25zZT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGFzc3VtZVJvbGVBcm46IHF1ZXJ5Lmxvb2t1cFJvbGVBcm4gfTtcbiAgICBjb25zdCBlbGJ2MiA9IChhd2FpdCB0aGlzLmF3cy5mb3JFbnZpcm9ubWVudChjeGFwaS5FbnZpcm9ubWVudFV0aWxzLm1ha2UocXVlcnkuYWNjb3VudCwgcXVlcnkucmVnaW9uKSwgTW9kZS5Gb3JSZWFkaW5nLCBvcHRpb25zKSkuc2RrLmVsYnYyKCk7XG5cbiAgICBpZiAoIXF1ZXJ5LmxvYWRCYWxhbmNlckFybiAmJiAhcXVlcnkubG9hZEJhbGFuY2VyVGFncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbG9hZCBiYWxhbmNlciBsb29rdXAgcXVlcnkgbXVzdCBzcGVjaWZ5IGVpdGhlciBgbG9hZEJhbGFuY2VyQXJuYCBvciBgbG9hZEJhbGFuY2VyVGFnc2AnKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2FkQmFsYW5jZXJzID0gYXdhaXQgZmluZExvYWRCYWxhbmNlcnMoZWxidjIsIHF1ZXJ5KTtcblxuICAgIGlmIChsb2FkQmFsYW5jZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBsb2FkIGJhbGFuY2VycyBmb3VuZCBtYXRjaGluZyAke0pTT04uc3RyaW5naWZ5KHF1ZXJ5KX1gKTtcbiAgICB9XG5cbiAgICBpZiAobG9hZEJhbGFuY2Vycy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIGxvYWQgYmFsYW5jZXJzIGZvdW5kIG1hdGNoaW5nICR7SlNPTi5zdHJpbmdpZnkocXVlcnkpfSAtIHBsZWFzZSBwcm92aWRlIG1vcmUgc3BlY2lmaWMgY3JpdGVyaWFgKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2FkQmFsYW5jZXIgPSBsb2FkQmFsYW5jZXJzWzBdO1xuXG4gICAgY29uc3QgaXBBZGRyZXNzVHlwZSA9IGxvYWRCYWxhbmNlci5JcEFkZHJlc3NUeXBlID09PSAnaXB2NCdcbiAgICAgID8gY3hhcGkuTG9hZEJhbGFuY2VySXBBZGRyZXNzVHlwZS5JUFY0XG4gICAgICA6IGN4YXBpLkxvYWRCYWxhbmNlcklwQWRkcmVzc1R5cGUuRFVBTF9TVEFDSztcblxuICAgIHJldHVybiB7XG4gICAgICBsb2FkQmFsYW5jZXJBcm46IGxvYWRCYWxhbmNlci5Mb2FkQmFsYW5jZXJBcm4hLFxuICAgICAgbG9hZEJhbGFuY2VyQ2Fub25pY2FsSG9zdGVkWm9uZUlkOiBsb2FkQmFsYW5jZXIuQ2Fub25pY2FsSG9zdGVkWm9uZUlkISxcbiAgICAgIGxvYWRCYWxhbmNlckRuc05hbWU6IGxvYWRCYWxhbmNlci5ETlNOYW1lISxcbiAgICAgIHZwY0lkOiBsb2FkQmFsYW5jZXIuVnBjSWQhLFxuICAgICAgc2VjdXJpdHlHcm91cElkczogbG9hZEJhbGFuY2VyLlNlY3VyaXR5R3JvdXBzID8/IFtdLFxuICAgICAgaXBBZGRyZXNzVHlwZTogaXBBZGRyZXNzVHlwZSxcbiAgICB9O1xuICB9XG59XG5cbi8vIERlY3JlYXNlcyBsaW5lIGxlbmd0aFxudHlwZSBMb2FkQmFsYW5jZXJMaXN0ZW5lclF1ZXJ5ID0gY3hzY2hlbWEuTG9hZEJhbGFuY2VyTGlzdGVuZXJDb250ZXh0UXVlcnk7XG50eXBlIExvYWRCYWxhbmNlckxpc3RlbmVyUmVzcG9uc2UgPSBjeGFwaS5Mb2FkQmFsYW5jZXJMaXN0ZW5lckNvbnRleHRSZXNwb25zZTtcblxuLyoqXG4gKiBQcm92aWRlcyBsb2FkIGJhbGFuY2VyIGxpc3RlbmVyIGNvbnRleHQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIExvYWRCYWxhbmNlckxpc3RlbmVyQ29udGV4dFByb3ZpZGVyUGx1Z2luIGltcGxlbWVudHMgQ29udGV4dFByb3ZpZGVyUGx1Z2luIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhd3M6IFNka1Byb3ZpZGVyKSB7XG4gIH1cblxuICBhc3luYyBnZXRWYWx1ZShxdWVyeTogTG9hZEJhbGFuY2VyTGlzdGVuZXJRdWVyeSk6IFByb21pc2U8TG9hZEJhbGFuY2VyTGlzdGVuZXJSZXNwb25zZT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGFzc3VtZVJvbGVBcm46IHF1ZXJ5Lmxvb2t1cFJvbGVBcm4gfTtcbiAgICBjb25zdCBlbGJ2MiA9IChhd2FpdCB0aGlzLmF3cy5mb3JFbnZpcm9ubWVudChjeGFwaS5FbnZpcm9ubWVudFV0aWxzLm1ha2UocXVlcnkuYWNjb3VudCwgcXVlcnkucmVnaW9uKSwgTW9kZS5Gb3JSZWFkaW5nLCBvcHRpb25zKSkuc2RrLmVsYnYyKCk7XG5cbiAgICBpZiAoIXF1ZXJ5Lmxpc3RlbmVyQXJuICYmICFxdWVyeS5sb2FkQmFsYW5jZXJBcm4gJiYgIXF1ZXJ5LmxvYWRCYWxhbmNlclRhZ3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxvYWQgYmFsYW5jZXIgbGlzdGVuZXIgcXVlcnkgbXVzdCBzcGVjaWZ5IGF0IGxlYXN0IG9uZSBvZjogYGxpc3RlbmVyQXJuYCwgYGxvYWRCYWxhbmNlckFybmAgb3IgYGxvYWRCYWxhbmNlclRhZ3NgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5Lmxpc3RlbmVyQXJuID8gdGhpcy5nZXRMaXN0ZW5lckJ5QXJuKGVsYnYyLCBxdWVyeSkgOiB0aGlzLmdldExpc3RlbmVyQnlGaWx0ZXJpbmdMb2FkQmFsYW5jZXJzKGVsYnYyLCBxdWVyeSk7XG4gIH1cblxuICAvKipcbiAgICogTG9vayB1cCBhIGxpc3RlbmVyIGJ5IHF1ZXJ5aW5nIGxpc3RlbmVycyBmb3IgcXVlcnkncyBsaXN0ZW5lciBhcm4gYW5kIHRoZW5cbiAgICogcmVzb2x2ZSBpdHMgbG9hZCBiYWxhbmNlciBmb3IgdGhlIHNlY3VyaXR5IGdyb3VwIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRMaXN0ZW5lckJ5QXJuKGVsYnYyOiBBV1MuRUxCdjIsIHF1ZXJ5OiBMb2FkQmFsYW5jZXJMaXN0ZW5lclF1ZXJ5KSB7XG4gICAgY29uc3QgbGlzdGVuZXJBcm4gPSBxdWVyeS5saXN0ZW5lckFybiE7XG4gICAgY29uc3QgbGlzdGVuZXJSZXN1bHRzID0gYXdhaXQgZWxidjIuZGVzY3JpYmVMaXN0ZW5lcnMoeyBMaXN0ZW5lckFybnM6IFtsaXN0ZW5lckFybl0gfSkucHJvbWlzZSgpO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IChsaXN0ZW5lclJlc3VsdHMuTGlzdGVuZXJzID8/IFtdKTtcblxuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGxvYWQgYmFsYW5jZXIgbGlzdGVuZXJzIGZvdW5kIG1hdGNoaW5nIGFybiAke2xpc3RlbmVyQXJufWApO1xuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gbGlzdGVuZXJzWzBdO1xuXG4gICAgY29uc3QgbG9hZEJhbGFuY2VycyA9IGF3YWl0IGZpbmRMb2FkQmFsYW5jZXJzKGVsYnYyLCB7XG4gICAgICAuLi5xdWVyeSxcbiAgICAgIGxvYWRCYWxhbmNlckFybjogbGlzdGVuZXIuTG9hZEJhbGFuY2VyQXJuISxcbiAgICB9KTtcblxuICAgIGlmIChsb2FkQmFsYW5jZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBhc3NvY2lhdGVkIGxvYWQgYmFsYW5jZXIgZm91bmQgZm9yIGxpc3RlbmVyIGFybiAke2xpc3RlbmVyQXJufWApO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYWRCYWxhbmNlciA9IGxvYWRCYWxhbmNlcnNbMF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGlzdGVuZXJBcm46IGxpc3RlbmVyLkxpc3RlbmVyQXJuISxcbiAgICAgIGxpc3RlbmVyUG9ydDogbGlzdGVuZXIuUG9ydCEsXG4gICAgICBzZWN1cml0eUdyb3VwSWRzOiBsb2FkQmFsYW5jZXIuU2VjdXJpdHlHcm91cHMgPz8gW10sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIGEgbGlzdGVuZXIgYnkgc3RhcnRpbmcgZnJvbSBsb2FkIGJhbGFuY2VycywgZmlsdGVyaW5nIG91dFxuICAgKiB1bm1hdGNoaW5nIGxvYWQgYmFsYW5jZXJzLCBhbmQgdGhlbiBieSBxdWVyeWluZyB0aGUgbGlzdGVuZXJzIG9mIGVhY2ggbG9hZFxuICAgKiBiYWxhbmNlciBhbmQgZmlsdGVyaW5nIG91dCB1bm1hdGNoaW5nIGxpc3RlbmVycy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0TGlzdGVuZXJCeUZpbHRlcmluZ0xvYWRCYWxhbmNlcnMoZWxidjI6IEFXUy5FTEJ2MiwgYXJnczogTG9hZEJhbGFuY2VyTGlzdGVuZXJRdWVyeSkge1xuICAgIC8vIEZpbmQgbWF0Y2hpbmcgbG9hZCBiYWxhbmNlcnNcbiAgICBjb25zdCBsb2FkQmFsYW5jZXJzID0gYXdhaXQgZmluZExvYWRCYWxhbmNlcnMoZWxidjIsIGFyZ3MpO1xuXG4gICAgaWYgKGxvYWRCYWxhbmNlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGFzc29jaWF0ZWQgbG9hZCBiYWxhbmNlcnMgZm91bmQgZm9yIGxvYWQgYmFsYW5jZXIgbGlzdGVuZXIgcXVlcnkgJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5kTWF0Y2hpbmdMaXN0ZW5lcihlbGJ2MiwgbG9hZEJhbGFuY2VycywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIG1hdGNoaW5nIGxpc3RlbmVyIGZyb20gdGhlIGxpc3Qgb2YgbG9hZCBiYWxhbmNlcnMuIFRoaXMgd2lsbFxuICAgKiBlcnJvciB1bmxlc3MgdGhlcmUgaXMgZXhhY3RseSBvbmUgbWF0Y2ggc28gdGhhdCB0aGUgdXNlciBpcyBwcm9tcHRlZCB0b1xuICAgKiBwcm92aWRlIG1vcmUgc3BlY2lmaWMgY3JpdGVyaWEgcmF0aGVyIHRoYW4gdXMgcHJvdmlkaW5nIGEgbm9uZGV0ZXJtaW5pc3RpY1xuICAgKiByZXN1bHQuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGZpbmRNYXRjaGluZ0xpc3RlbmVyKGVsYnYyOiBBV1MuRUxCdjIsIGxvYWRCYWxhbmNlcnM6IEFXUy5FTEJ2Mi5Mb2FkQmFsYW5jZXJzLCBxdWVyeTogTG9hZEJhbGFuY2VyTGlzdGVuZXJRdWVyeSkge1xuICAgIGNvbnN0IGxvYWRCYWxhbmNlcnNCeUFybiA9IGluZGV4TG9hZEJhbGFuY2Vyc0J5QXJuKGxvYWRCYWxhbmNlcnMpO1xuICAgIGNvbnN0IGxvYWRCYWxhbmNlckFybnMgPSBPYmplY3Qua2V5cyhsb2FkQmFsYW5jZXJzQnlBcm4pO1xuXG4gICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5PGN4YXBpLkxvYWRCYWxhbmNlckxpc3RlbmVyQ29udGV4dFJlc3BvbnNlPigpO1xuXG4gICAgZm9yIGF3YWl0IChjb25zdCBsaXN0ZW5lciBvZiBkZXNjcmliZUxpc3RlbmVyc0J5TG9hZEJhbGFuY2VyQXJuKGVsYnYyLCBsb2FkQmFsYW5jZXJBcm5zKSkge1xuICAgICAgY29uc3QgbG9hZEJhbGFuY2VyID0gbG9hZEJhbGFuY2Vyc0J5QXJuW2xpc3RlbmVyLkxvYWRCYWxhbmNlckFybiFdO1xuICAgICAgaWYgKGxpc3RlbmVyTWF0Y2hlc1F1ZXJ5RmlsdGVyKGxpc3RlbmVyLCBxdWVyeSkgJiYgbG9hZEJhbGFuY2VyKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgbGlzdGVuZXJBcm46IGxpc3RlbmVyLkxpc3RlbmVyQXJuISxcbiAgICAgICAgICBsaXN0ZW5lclBvcnQ6IGxpc3RlbmVyLlBvcnQhLFxuICAgICAgICAgIHNlY3VyaXR5R3JvdXBJZHM6IGxvYWRCYWxhbmNlci5TZWN1cml0eUdyb3VwcyA/PyBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGxvYWQgYmFsYW5jZXIgbGlzdGVuZXJzIGZvdW5kIG1hdGNoaW5nICR7SlNPTi5zdHJpbmdpZnkocXVlcnkpfWApO1xuICAgIH1cblxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgbG9hZCBiYWxhbmNlciBsaXN0ZW5lcnMgZm91bmQgbWF0Y2hpbmcgJHtKU09OLnN0cmluZ2lmeShxdWVyeSl9IC0gcGxlYXNlIHByb3ZpZGUgbW9yZSBzcGVjaWZpYyBjcml0ZXJpYWApO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICB9XG59XG5cbi8qKlxuICogRmluZCBsb2FkIGJhbGFuY2VycyBieSB0aGUgZ2l2ZW4gZmlsdGVyIGFyZ3MuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbmRMb2FkQmFsYW5jZXJzKGVsYnYyOiBBV1MuRUxCdjIsIGFyZ3M6IGN4c2NoZW1hLkxvYWRCYWxhbmNlckZpbHRlcikge1xuICAvLyBMaXN0IGxvYWQgYmFsYW5jZXJzXG4gIGxldCBsb2FkQmFsYW5jZXJzID0gYXdhaXQgZGVzY3JpYmVMb2FkQmFsYW5jZXJzKGVsYnYyLCB7XG4gICAgTG9hZEJhbGFuY2VyQXJuczogYXJncy5sb2FkQmFsYW5jZXJBcm4gPyBbYXJncy5sb2FkQmFsYW5jZXJBcm5dIDogdW5kZWZpbmVkLFxuICB9KTtcblxuICAvLyBGaWx0ZXIgYnkgbG9hZCBiYWxhbmNlciB0eXBlXG4gIGxvYWRCYWxhbmNlcnMgPSBsb2FkQmFsYW5jZXJzLmZpbHRlcihsYiA9PiBsYi5UeXBlID09PSBhcmdzLmxvYWRCYWxhbmNlclR5cGUpO1xuXG4gIC8vIEZpbHRlciBieSBsb2FkIGJhbGFuY2VyIHRhZ3NcbiAgaWYgKGFyZ3MubG9hZEJhbGFuY2VyVGFncykge1xuICAgIGxvYWRCYWxhbmNlcnMgPSBhd2FpdCBmaWx0ZXJMb2FkQmFsYW5jZXJzQnlUYWdzKGVsYnYyLCBsb2FkQmFsYW5jZXJzLCBhcmdzLmxvYWRCYWxhbmNlclRhZ3MpO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRCYWxhbmNlcnM7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIHBhZ2luYXRlIG92ZXIgZGVzY3JpYmVMb2FkQmFsYW5jZXJzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlc2NyaWJlTG9hZEJhbGFuY2VycyhlbGJ2MjogQVdTLkVMQnYyLCByZXF1ZXN0OiBBV1MuRUxCdjIuRGVzY3JpYmVMb2FkQmFsYW5jZXJzSW5wdXQpIHtcbiAgY29uc3QgbG9hZEJhbGFuY2VycyA9IEFycmF5PEFXUy5FTEJ2Mi5Mb2FkQmFsYW5jZXI+KCk7XG4gIGxldCBwYWdlOiBBV1MuRUxCdjIuRGVzY3JpYmVMb2FkQmFsYW5jZXJzT3V0cHV0IHwgdW5kZWZpbmVkO1xuICBkbyB7XG4gICAgcGFnZSA9IGF3YWl0IGVsYnYyLmRlc2NyaWJlTG9hZEJhbGFuY2Vycyh7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgTWFya2VyOiBwYWdlPy5OZXh0TWFya2VyLFxuICAgIH0pLnByb21pc2UoKTtcblxuICAgIGxvYWRCYWxhbmNlcnMucHVzaCguLi5BcnJheS5mcm9tKHBhZ2UuTG9hZEJhbGFuY2VycyA/PyBbXSkpO1xuICB9IHdoaWxlIChwYWdlLk5leHRNYXJrZXIpO1xuXG4gIHJldHVybiBsb2FkQmFsYW5jZXJzO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyB0aGUgdGFncyBvZiBlYWNoIGxvYWQgYmFsYW5jZXIgYW5kIHJldHVybnMgdGhlIGxvYWQgYmFsYW5jZXJzIHRoYXRcbiAqIG1hdGNoIHRoZSBnaXZlbiB0YWdzLlxuICovXG5hc3luYyBmdW5jdGlvbiBmaWx0ZXJMb2FkQmFsYW5jZXJzQnlUYWdzKGVsYnYyOiBBV1MuRUxCdjIsIGxvYWRCYWxhbmNlcnM6IEFXUy5FTEJ2Mi5Mb2FkQmFsYW5jZXJzLCBsb2FkQmFsYW5jZXJUYWdzOiBjeHNjaGVtYS5UYWdbXSkge1xuICBjb25zdCBsb2FkQmFsYW5jZXJzQnlBcm4gPSBpbmRleExvYWRCYWxhbmNlcnNCeUFybihsb2FkQmFsYW5jZXJzKTtcbiAgY29uc3QgbG9hZEJhbGFuY2VyQXJucyA9IE9iamVjdC5rZXlzKGxvYWRCYWxhbmNlcnNCeUFybik7XG4gIGNvbnN0IG1hdGNoaW5nTG9hZEJhbGFuY2VycyA9IEFycmF5PEFXUy5FTEJ2Mi5Mb2FkQmFsYW5jZXI+KCk7XG5cbiAgLy8gQ29uc3VtZSB0aGUgaXRlbXMgb2YgYXN5bmMgZ2VuZXJhdG9yLlxuICBmb3IgYXdhaXQgKGNvbnN0IHRhZ3Mgb2YgZGVzY3JpYmVUYWdzKGVsYnYyLCBsb2FkQmFsYW5jZXJBcm5zKSkge1xuICAgIGlmICh0YWdzTWF0Y2godGFncywgbG9hZEJhbGFuY2VyVGFncykgJiYgbG9hZEJhbGFuY2Vyc0J5QXJuW3RhZ3MuUmVzb3VyY2VBcm4hXSkge1xuICAgICAgbWF0Y2hpbmdMb2FkQmFsYW5jZXJzLnB1c2gobG9hZEJhbGFuY2Vyc0J5QXJuW3RhZ3MuUmVzb3VyY2VBcm4hXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoaW5nTG9hZEJhbGFuY2Vycztcbn1cblxuLyoqXG4gKiBHZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCB5aWVsZHMgYFRhZ0Rlc2NyaXB0aW9uc2AuIFRoZSBBUEkgZG9lc24ndCBzdXBwb3J0XG4gKiBwYWdpbmF0aW9uLCBzbyB0aGlzIGdlbmVyYXRvciBicmVha3MgdGhlIHJlc291cmNlIGxpc3QgaW50byBjaHVua3MgYW5kIGlzc3Vlc1xuICogdGhlIGFwcHJvcHJpYXRlIHJlcXVlc3RzLCB5aWVsZGluZyBlYWNoIHRhZyBkZXNjcmlwdGlvbiBhcyBpdCByZWNlaXZlcyBpdC5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGRlc2NyaWJlVGFncyhlbGJ2MjogQVdTLkVMQnYyLCByZXNvdXJjZUFybnM6IHN0cmluZ1tdKSB7XG4gIC8vIE1heCBvZiAyMCByZXNvdXJjZSBhcm5zIHBlciByZXF1ZXN0LlxuICBjb25zdCBjaHVua1NpemUgPSAyMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvdXJjZUFybnMubGVuZ3RoOyBpICs9IGNodW5rU2l6ZSkge1xuICAgIGNvbnN0IGNodW5rID0gcmVzb3VyY2VBcm5zLnNsaWNlKGksIE1hdGgubWluKGkgKyBjaHVua1NpemUsIHJlc291cmNlQXJucy5sZW5ndGgpKTtcbiAgICBjb25zdCBjaHVua1RhZ3MgPSBhd2FpdCBlbGJ2Mi5kZXNjcmliZVRhZ3Moe1xuICAgICAgUmVzb3VyY2VBcm5zOiBjaHVuayxcbiAgICB9KS5wcm9taXNlKCk7XG5cbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBjaHVua1RhZ3MuVGFnRGVzY3JpcHRpb25zID8/IFtdKSB7XG4gICAgICB5aWVsZCB0YWc7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gVGFnRGVzY3JpcHRpb24gbWF0Y2hlcyB0aGUgcmVxdWlyZWQgdGFncy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFnc01hdGNoKHRhZ0Rlc2NyaXB0aW9uOiBBV1MuRUxCdjIuVGFnRGVzY3JpcHRpb24sIHJlcXVpcmVkVGFnczogY3hzY2hlbWEuVGFnW10pIHtcbiAgY29uc3QgdGFnc0J5TmFtZTogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiA9IHt9O1xuICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdEZXNjcmlwdGlvbi5UYWdzID8/IFtdKSB7XG4gICAgdGFnc0J5TmFtZVt0YWcuS2V5IV0gPSB0YWcuVmFsdWU7XG4gIH1cblxuICBmb3IgKGNvbnN0IHRhZyBvZiByZXF1aXJlZFRhZ3MpIHtcbiAgICBpZiAodGFnc0J5TmFtZVt0YWcua2V5XSAhPT0gdGFnLnZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQXN5bmMgZ2VuZXJhdG9yIHRoYXQgcHJvZHVjZXMgbGlzdGVuZXIgZGVzY3JpcHRpb25zIGJ5IHRyYXZlcnNpbmcgdGhlXG4gKiBwYWdpbmF0aW9uLiBCZWNhdXNlIGRlc2NyaWJlTGlzdGVuZXJzIG9ubHkgbGV0cyB5b3Ugc2VhcmNoIGJ5IG9uZSBsb2FkXG4gKiBiYWxhbmNlciBhcm4gYXQgYSB0aW1lLCB3ZSByZXF1ZXN0IHRoZW0gaW5kaXZpZHVhbGx5IGFuZCB5aWVsZCB0aGUgbGlzdGVuZXJzXG4gKiBhcyB0aGV5IGNvbWUgaW4uXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBkZXNjcmliZUxpc3RlbmVyc0J5TG9hZEJhbGFuY2VyQXJuKGVsYnYyOiBBV1MuRUxCdjIsIGxvYWRCYWxhbmNlckFybnM6IHN0cmluZ1tdKSB7XG4gIGZvciAoY29uc3QgbG9hZEJhbGFuY2VyQXJuIG9mIGxvYWRCYWxhbmNlckFybnMpIHtcbiAgICBsZXQgcGFnZTogQVdTLkVMQnYyLkRlc2NyaWJlTGlzdGVuZXJzT3V0cHV0IHwgdW5kZWZpbmVkO1xuICAgIGRvIHtcbiAgICAgIHBhZ2UgPSBhd2FpdCBlbGJ2Mi5kZXNjcmliZUxpc3RlbmVycyh7XG4gICAgICAgIExvYWRCYWxhbmNlckFybjogbG9hZEJhbGFuY2VyQXJuLFxuICAgICAgICBNYXJrZXI6IHBhZ2U/Lk5leHRNYXJrZXIsXG4gICAgICB9KS5wcm9taXNlKCk7XG5cbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcGFnZS5MaXN0ZW5lcnMgPz8gW10pIHtcbiAgICAgICAgeWllbGQgbGlzdGVuZXI7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocGFnZS5OZXh0TWFya2VyKTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBsaXN0ZW5lciBtYXRjaGVzIHRoZSBxdWVyeSBmaWx0ZXJzLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lck1hdGNoZXNRdWVyeUZpbHRlcihsaXN0ZW5lcjogQVdTLkVMQnYyLkxpc3RlbmVyLCBhcmdzOiBjeHNjaGVtYS5Mb2FkQmFsYW5jZXJMaXN0ZW5lckNvbnRleHRRdWVyeSk6IGJvb2xlYW4ge1xuICBpZiAoYXJncy5saXN0ZW5lclBvcnQgJiYgbGlzdGVuZXIuUG9ydCAhPT0gYXJncy5saXN0ZW5lclBvcnQpIHtcbiAgICAvLyBObyBtYXRjaC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJncy5saXN0ZW5lclByb3RvY29sICYmIGxpc3RlbmVyLlByb3RvY29sICE9PSBhcmdzLmxpc3RlbmVyUHJvdG9jb2wpIHtcbiAgICAvLyBObyBtYXRjaC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVjb3JkIG9mIGxvYWQgYmFsYW5jZXJzIGluZGV4ZWQgYnkgdGhlaXIgYXJuc1xuICovXG5mdW5jdGlvbiBpbmRleExvYWRCYWxhbmNlcnNCeUFybihsb2FkQmFsYW5jZXJzOiBBV1MuRUxCdjIuTG9hZEJhbGFuY2VyW10pOiBSZWNvcmQ8c3RyaW5nLCBBV1MuRUxCdjIuTG9hZEJhbGFuY2VyPiB7XG4gIGNvbnN0IGxvYWRCYWxhbmNlcnNCeUFybjogUmVjb3JkPHN0cmluZywgQVdTLkVMQnYyLkxvYWRCYWxhbmNlcj4gPSB7fTtcblxuICBmb3IgKGNvbnN0IGxvYWRCYWxhbmNlciBvZiBsb2FkQmFsYW5jZXJzKSB7XG4gICAgbG9hZEJhbGFuY2Vyc0J5QXJuW2xvYWRCYWxhbmNlci5Mb2FkQmFsYW5jZXJBcm4hXSA9IGxvYWRCYWxhbmNlcjtcbiAgfVxuXG4gIHJldHVybiBsb2FkQmFsYW5jZXJzQnlBcm47XG59XG4iXX0=