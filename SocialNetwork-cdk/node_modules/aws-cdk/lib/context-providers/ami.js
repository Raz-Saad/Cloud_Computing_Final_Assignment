"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmiContextProviderPlugin = void 0;
const cxapi = require("@aws-cdk/cx-api");
const credentials_1 = require("../api/aws-auth/credentials");
const logging_1 = require("../logging");
/**
 * Plugin to search AMIs for the current account
 */
class AmiContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const region = args.region;
        const account = args.account;
        // Normally we'd do this only as 'debug', but searching AMIs typically takes dozens
        // of seconds, so be little more verbose about it so users know what is going on.
        (0, logging_1.print)(`Searching for AMI in ${account}:${region}`);
        (0, logging_1.debug)(`AMI search parameters: ${JSON.stringify(args)}`);
        const options = { assumeRoleArn: args.lookupRoleArn };
        const ec2 = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(account, region), credentials_1.Mode.ForReading, options)).sdk.ec2();
        const response = await ec2.describeImages({
            Owners: args.owners,
            Filters: Object.entries(args.filters).map(([key, values]) => ({
                Name: key,
                Values: values,
            })),
        }).promise();
        const images = [...response.Images || []].filter(i => i.ImageId !== undefined);
        if (images.length === 0) {
            throw new Error('No AMI found that matched the search criteria');
        }
        // Return the most recent one
        // Note: Date.parse() is not going to respect the timezone of the string,
        // but since we only care about the relative values that is okay.
        images.sort(descending(i => Date.parse(i.CreationDate || '1970')));
        (0, logging_1.debug)(`Selected image '${images[0].ImageId}' created at '${images[0].CreationDate}'`);
        return images[0].ImageId;
    }
}
exports.AmiContextProviderPlugin = AmiContextProviderPlugin;
/**
 * Make a comparator that sorts in descending order given a sort key extractor
 */
function descending(valueOf) {
    return (a, b) => {
        return valueOf(b) - valueOf(a);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1pLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYW1pLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHlDQUF5QztBQUN6Qyw2REFBbUQ7QUFHbkQsd0NBQTBDO0FBRTFDOztHQUVHO0FBQ0gsTUFBYSx3QkFBd0I7SUFDbkMsWUFBNkIsR0FBZ0I7UUFBaEIsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUM3QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUE4QjtRQUNsRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzNCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFFN0IsbUZBQW1GO1FBQ25GLGlGQUFpRjtRQUNqRixJQUFBLGVBQUssRUFBQyx3QkFBd0IsT0FBTyxJQUFJLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDbkQsSUFBQSxlQUFLLEVBQUMsMEJBQTBCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXhELE1BQU0sT0FBTyxHQUFHLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUN0RCxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLEVBQUUsa0JBQUksQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDOUgsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsY0FBYyxDQUFDO1lBQ3hDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQzVELElBQUksRUFBRSxHQUFHO2dCQUNULE1BQU0sRUFBRSxNQUFNO2FBQ2YsQ0FBQyxDQUFDO1NBQ0osQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUMsQ0FBQztRQUUvRSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO1FBQ25FLENBQUM7UUFFRCw2QkFBNkI7UUFDN0IseUVBQXlFO1FBQ3pFLGlFQUFpRTtRQUNqRSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFbkUsSUFBQSxlQUFLLEVBQUMsbUJBQW1CLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLGlCQUFpQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztRQUN0RixPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFRLENBQUM7SUFDNUIsQ0FBQztDQUNGO0FBckNELDREQXFDQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxVQUFVLENBQUksT0FBeUI7SUFDOUMsT0FBTyxDQUFDLENBQUksRUFBRSxDQUFJLEVBQUUsRUFBRTtRQUNwQixPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakMsQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4uL2FwaS9hd3MtYXV0aC9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uL2FwaS9hd3MtYXV0aC9zZGstcHJvdmlkZXInO1xuaW1wb3J0IHsgQ29udGV4dFByb3ZpZGVyUGx1Z2luIH0gZnJvbSAnLi4vYXBpL3BsdWdpbic7XG5pbXBvcnQgeyBkZWJ1ZywgcHJpbnQgfSBmcm9tICcuLi9sb2dnaW5nJztcblxuLyoqXG4gKiBQbHVnaW4gdG8gc2VhcmNoIEFNSXMgZm9yIHRoZSBjdXJyZW50IGFjY291bnRcbiAqL1xuZXhwb3J0IGNsYXNzIEFtaUNvbnRleHRQcm92aWRlclBsdWdpbiBpbXBsZW1lbnRzIENvbnRleHRQcm92aWRlclBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXdzOiBTZGtQcm92aWRlcikge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFZhbHVlKGFyZ3M6IGN4c2NoZW1hLkFtaUNvbnRleHRRdWVyeSkge1xuICAgIGNvbnN0IHJlZ2lvbiA9IGFyZ3MucmVnaW9uO1xuICAgIGNvbnN0IGFjY291bnQgPSBhcmdzLmFjY291bnQ7XG5cbiAgICAvLyBOb3JtYWxseSB3ZSdkIGRvIHRoaXMgb25seSBhcyAnZGVidWcnLCBidXQgc2VhcmNoaW5nIEFNSXMgdHlwaWNhbGx5IHRha2VzIGRvemVuc1xuICAgIC8vIG9mIHNlY29uZHMsIHNvIGJlIGxpdHRsZSBtb3JlIHZlcmJvc2UgYWJvdXQgaXQgc28gdXNlcnMga25vdyB3aGF0IGlzIGdvaW5nIG9uLlxuICAgIHByaW50KGBTZWFyY2hpbmcgZm9yIEFNSSBpbiAke2FjY291bnR9OiR7cmVnaW9ufWApO1xuICAgIGRlYnVnKGBBTUkgc2VhcmNoIHBhcmFtZXRlcnM6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG5cbiAgICBjb25zdCBvcHRpb25zID0geyBhc3N1bWVSb2xlQXJuOiBhcmdzLmxvb2t1cFJvbGVBcm4gfTtcbiAgICBjb25zdCBlYzIgPSAoYXdhaXQgdGhpcy5hd3MuZm9yRW52aXJvbm1lbnQoY3hhcGkuRW52aXJvbm1lbnRVdGlscy5tYWtlKGFjY291bnQsIHJlZ2lvbiksIE1vZGUuRm9yUmVhZGluZywgb3B0aW9ucykpLnNkay5lYzIoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVjMi5kZXNjcmliZUltYWdlcyh7XG4gICAgICBPd25lcnM6IGFyZ3Mub3duZXJzLFxuICAgICAgRmlsdGVyczogT2JqZWN0LmVudHJpZXMoYXJncy5maWx0ZXJzKS5tYXAoKFtrZXksIHZhbHVlc10pID0+ICh7XG4gICAgICAgIE5hbWU6IGtleSxcbiAgICAgICAgVmFsdWVzOiB2YWx1ZXMsXG4gICAgICB9KSksXG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgY29uc3QgaW1hZ2VzID0gWy4uLnJlc3BvbnNlLkltYWdlcyB8fCBbXV0uZmlsdGVyKGkgPT4gaS5JbWFnZUlkICE9PSB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGltYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gQU1JIGZvdW5kIHRoYXQgbWF0Y2hlZCB0aGUgc2VhcmNoIGNyaXRlcmlhJyk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBtb3N0IHJlY2VudCBvbmVcbiAgICAvLyBOb3RlOiBEYXRlLnBhcnNlKCkgaXMgbm90IGdvaW5nIHRvIHJlc3BlY3QgdGhlIHRpbWV6b25lIG9mIHRoZSBzdHJpbmcsXG4gICAgLy8gYnV0IHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCB0aGUgcmVsYXRpdmUgdmFsdWVzIHRoYXQgaXMgb2theS5cbiAgICBpbWFnZXMuc29ydChkZXNjZW5kaW5nKGkgPT4gRGF0ZS5wYXJzZShpLkNyZWF0aW9uRGF0ZSB8fCAnMTk3MCcpKSk7XG5cbiAgICBkZWJ1ZyhgU2VsZWN0ZWQgaW1hZ2UgJyR7aW1hZ2VzWzBdLkltYWdlSWR9JyBjcmVhdGVkIGF0ICcke2ltYWdlc1swXS5DcmVhdGlvbkRhdGV9J2ApO1xuICAgIHJldHVybiBpbWFnZXNbMF0uSW1hZ2VJZCE7XG4gIH1cbn1cblxuLyoqXG4gKiBNYWtlIGEgY29tcGFyYXRvciB0aGF0IHNvcnRzIGluIGRlc2NlbmRpbmcgb3JkZXIgZ2l2ZW4gYSBzb3J0IGtleSBleHRyYWN0b3JcbiAqL1xuZnVuY3Rpb24gZGVzY2VuZGluZzxBPih2YWx1ZU9mOiAoeDogQSkgPT4gbnVtYmVyKSB7XG4gIHJldHVybiAoYTogQSwgYjogQSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZU9mKGIpIC0gdmFsdWVPZihhKTtcbiAgfTtcbn1cbiJdfQ==