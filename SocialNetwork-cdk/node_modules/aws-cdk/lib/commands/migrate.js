"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromScan = exports.CfnTemplateGeneratorProvider = exports.appendWarningsToReadme = exports.buildCfnClient = exports.buildGenertedTemplateOutput = exports.isThereAWarning = exports.getMigrateScanType = exports.writeMigrateJsonFile = exports.displayTimeDiff = exports.rewriteLine = exports.printDots = exports.printBar = exports.scanProgressBar = exports.parseSourceOptions = exports.FilterType = exports.ScanStatus = exports.TemplateSourceOptions = exports.setEnvironment = exports.chunks = exports.generateTemplate = exports.readFromStack = exports.readFromPath = exports.generateStack = exports.generateCdkApp = exports.MIGRATE_SUPPORTED_LANGUAGES = void 0;
/* eslint-disable @typescript-eslint/no-require-imports */
/* eslint-disable @typescript-eslint/no-var-requires */
const fs = require("fs");
const path = require("path");
const cx_api_1 = require("@aws-cdk/cx-api");
const cdk_from_cfn = require("cdk-from-cfn");
const chalk = require("chalk");
const init_1 = require("../../lib/init");
const logging_1 = require("../../lib/logging");
const aws_auth_1 = require("../api/aws-auth");
const cloudformation_1 = require("../api/util/cloudformation");
const archive_1 = require("../util/archive");
const camelCase = require('camelcase');
const decamelize = require('decamelize');
/** The list of languages supported by the built-in noctilucent binary. */
exports.MIGRATE_SUPPORTED_LANGUAGES = cdk_from_cfn.supported_languages();
/**
 * Generates a CDK app from a yaml or json template.
 *
 * @param stackName The name to assign to the stack in the generated app
 * @param stack The yaml or json template for the stack
 * @param language The language to generate the CDK app in
 * @param outputPath The path at which to generate the CDK app
 */
async function generateCdkApp(stackName, stack, language, outputPath, compress) {
    const resolvedOutputPath = path.join(outputPath ?? process.cwd(), stackName);
    const formattedStackName = decamelize(stackName);
    try {
        fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        fs.mkdirSync(resolvedOutputPath, { recursive: true });
        const generateOnly = compress;
        await (0, init_1.cliInit)({
            type: 'app',
            language,
            canUseNetwork: true,
            generateOnly,
            workDir: resolvedOutputPath,
            stackName,
            migrate: true,
        });
        let stackFileName;
        switch (language) {
            case 'typescript':
                stackFileName = `${resolvedOutputPath}/lib/${formattedStackName}-stack.ts`;
                break;
            case 'java':
                stackFileName = `${resolvedOutputPath}/src/main/java/com/myorg/${camelCase(formattedStackName, { pascalCase: true })}Stack.java`;
                break;
            case 'python':
                stackFileName = `${resolvedOutputPath}/${formattedStackName.replace(/-/g, '_')}/${formattedStackName.replace(/-/g, '_')}_stack.py`;
                break;
            case 'csharp':
                stackFileName = `${resolvedOutputPath}/src/${camelCase(formattedStackName, { pascalCase: true })}/${camelCase(formattedStackName, { pascalCase: true })}Stack.cs`;
                break;
            case 'go':
                stackFileName = `${resolvedOutputPath}/${formattedStackName}.go`;
                break;
            default:
                throw new Error(`${language} is not supported by CDK Migrate. Please choose from: ${exports.MIGRATE_SUPPORTED_LANGUAGES.join(', ')}`);
        }
        fs.writeFileSync(stackFileName, stack);
        if (compress) {
            await (0, archive_1.zipDirectory)(resolvedOutputPath, `${resolvedOutputPath}.zip`);
            fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        }
    }
    catch (error) {
        fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        throw error;
    }
}
exports.generateCdkApp = generateCdkApp;
/**
 * Generates a CDK stack file.
 * @param template The template to translate into a CDK stack
 * @param stackName The name to assign to the stack
 * @param language The language to generate the stack in
 * @returns A string representation of a CDK stack file
 */
function generateStack(template, stackName, language) {
    const formattedStackName = `${camelCase(decamelize(stackName), { pascalCase: true })}Stack`;
    try {
        return cdk_from_cfn.transmute(template, language, formattedStackName);
    }
    catch (e) {
        throw new Error(`${formattedStackName} could not be generated because ${e.message}`);
    }
}
exports.generateStack = generateStack;
/**
 * Reads and returns a stack template from a local path.
 *
 * @param inputPath The location of the template
 * @returns A string representation of the template if present, otherwise undefined
 */
function readFromPath(inputPath) {
    let readFile;
    try {
        readFile = fs.readFileSync(inputPath, 'utf8');
    }
    catch (e) {
        throw new Error(`'${inputPath}' is not a valid path.`);
    }
    if (readFile == '') {
        throw new Error(`Cloudformation template filepath: '${inputPath}' is an empty file.`);
    }
    return readFile;
}
exports.readFromPath = readFromPath;
/**
 * Reads and returns a stack template from a deployed CloudFormation stack.
 *
 * @param stackName The name of the stack
 * @param sdkProvider The sdk provider for making CloudFormation calls
 * @param environment The account and region where the stack is deployed
 * @returns A string representation of the template if present, otherwise undefined
 */
async function readFromStack(stackName, sdkProvider, environment) {
    const cloudFormation = (await sdkProvider.forEnvironment(environment, aws_auth_1.Mode.ForReading)).sdk.cloudFormation();
    const stack = await cloudformation_1.CloudFormationStack.lookup(cloudFormation, stackName, true);
    if (stack.stackStatus.isDeploySuccess || stack.stackStatus.isRollbackSuccess) {
        return JSON.stringify(await stack.template());
    }
    else {
        throw new Error(`Stack '${stackName}' in account ${environment.account} and region ${environment.region} has a status of '${stack.stackStatus.name}' due to '${stack.stackStatus.reason}'. The stack cannot be migrated until it is in a healthy state.`);
    }
    return;
}
exports.readFromStack = readFromStack;
/**
 * Takes in a stack name and account and region and returns a generated cloudformation template using the cloudformation
 * template generator.
 *
 * @param GenerateTemplateOptions An object containing the stack name, filters, sdkProvider, environment, and newScan flag
 * @returns a generated cloudformation template
 */
async function generateTemplate(options) {
    const cfn = new CfnTemplateGeneratorProvider(await buildCfnClient(options.sdkProvider, options.environment));
    const scanId = await findLastSuccessfulScan(cfn, options);
    // if a customer accidentally ctrl-c's out of the command and runs it again, this will continue the progress bar where it left off
    const curScan = await cfn.describeResourceScan(scanId);
    if ((curScan.Status == ScanStatus.IN_PROGRESS)) {
        (0, logging_1.print)('Resource scan in progress. Please wait, this can take 10 minutes or longer.');
        await scanProgressBar(scanId, cfn);
    }
    displayTimeDiff(new Date(), new Date(curScan.StartTime));
    let resources = await cfn.listResourceScanResources(scanId, options.filters);
    (0, logging_1.print)('finding related resources.');
    let relatedResources = await cfn.getResourceScanRelatedResources(scanId, resources);
    (0, logging_1.print)(`Found ${relatedResources.length} resources.`);
    (0, logging_1.print)('Generating CFN template from scanned resources.');
    const templateArn = (await cfn.createGeneratedTemplate(options.stackName, relatedResources)).GeneratedTemplateId;
    let generatedTemplate = await cfn.describeGeneratedTemplate(templateArn);
    (0, logging_1.print)('Please wait, template creation in progress. This may take a couple minutes.');
    while (generatedTemplate.Status !== ScanStatus.COMPLETE && generatedTemplate.Status !== ScanStatus.FAILED) {
        await printDots(`[${generatedTemplate.Status}] Template Creation in Progress`, 400);
        generatedTemplate = await cfn.describeGeneratedTemplate(templateArn);
    }
    (0, logging_1.print)('');
    (0, logging_1.print)('Template successfully generated!');
    return buildGenertedTemplateOutput(generatedTemplate, (await cfn.getGeneratedTemplate(templateArn)).TemplateBody, templateArn);
}
exports.generateTemplate = generateTemplate;
async function findLastSuccessfulScan(cfn, options) {
    let resourceScanSummaries = [];
    const clientRequestToken = `cdk-migrate-${options.environment.account}-${options.environment.region}`;
    if (options.fromScan === FromScan.NEW) {
        (0, logging_1.print)(`Starting new scan for account ${options.environment.account} in region ${options.environment.region}`);
        try {
            await cfn.startResourceScan(clientRequestToken);
            resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
        }
        catch (e) {
            // continuing here because if the scan fails on a new-scan it is very likely because there is either already a scan in progress
            // or the customer hit a rate limit. In either case we want to continue with the most recent scan.
            // If this happens to fail for a credential error then that will be caught immediately after anyway.
            (0, logging_1.print)(`Scan failed to start due to error '${e.message}', defaulting to latest scan.`);
        }
    }
    else {
        resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
        await cfn.checkForResourceScan(resourceScanSummaries, options, clientRequestToken);
    }
    // get the latest scan, which we know will exist
    resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
    let scanId = resourceScanSummaries[0].ResourceScanId;
    // find the most recent scan that isn't in a failed state in case we didn't start a new one
    for (const summary of resourceScanSummaries) {
        if (summary.Status !== ScanStatus.FAILED) {
            scanId = summary.ResourceScanId;
            break;
        }
    }
    return scanId;
}
/**
 * Takes a string of filters in the format of key1=value1,key2=value2 and returns a map of the filters.
 *
 * @param filters a string of filters in the format of key1=value1,key2=value2
 * @returns a map of the filters
 */
function parseFilters(filters) {
    if (!filters) {
        return {
            'resource-identifier': undefined,
            'resource-type-prefix': undefined,
            'tag-key': undefined,
            'tag-value': undefined,
        };
    }
    ;
    const filterShorthands = {
        'identifier': FilterType.RESOURCE_IDENTIFIER,
        'id': FilterType.RESOURCE_IDENTIFIER,
        'type': FilterType.RESOURCE_TYPE_PREFIX,
        'type-prefix': FilterType.RESOURCE_TYPE_PREFIX,
    };
    const filterList = filters.split(',');
    let filterMap = {
        [FilterType.RESOURCE_IDENTIFIER]: undefined,
        [FilterType.RESOURCE_TYPE_PREFIX]: undefined,
        [FilterType.TAG_KEY]: undefined,
        [FilterType.TAG_VALUE]: undefined,
    };
    for (const fil of filterList) {
        const filter = fil.split('=');
        let filterKey = filter[0];
        const filterValue = filter[1];
        // if the key is a shorthand, replace it with the full name
        if (filterKey in filterShorthands) {
            filterKey = filterShorthands[filterKey];
        }
        if (Object.values(FilterType).includes(filterKey)) {
            filterMap[filterKey] = filterValue;
        }
        else {
            throw new Error(`Invalid filter: ${filterKey}`);
        }
    }
    return filterMap;
}
/**
 * Takes a list of any type and breaks it up into chunks of a specified size.
 *
 * @param list The list to break up
 * @param chunkSize The size of each chunk
 * @returns A list of lists of the specified size
 */
function chunks(list, chunkSize) {
    const chunkedList = [];
    for (let i = 0; i < list.length; i += chunkSize) {
        chunkedList.push(list.slice(i, i + chunkSize));
    }
    return chunkedList;
}
exports.chunks = chunks;
/**
 * Sets the account and region for making CloudFormation calls.
 * @param account The account to use
 * @param region The region to use
 * @returns The environment object
 */
function setEnvironment(account, region) {
    return { account: account ?? cx_api_1.UNKNOWN_ACCOUNT, region: region ?? cx_api_1.UNKNOWN_REGION, name: 'cdk-migrate-env' };
}
exports.setEnvironment = setEnvironment;
/**
 * Enum for the source options for the template
 */
var TemplateSourceOptions;
(function (TemplateSourceOptions) {
    TemplateSourceOptions["PATH"] = "path";
    TemplateSourceOptions["STACK"] = "stack";
    TemplateSourceOptions["SCAN"] = "scan";
})(TemplateSourceOptions || (exports.TemplateSourceOptions = TemplateSourceOptions = {}));
/**
 * Enum for the status of a resource scan
 */
var ScanStatus;
(function (ScanStatus) {
    ScanStatus["IN_PROGRESS"] = "IN_PROGRESS";
    ScanStatus["COMPLETE"] = "COMPLETE";
    ScanStatus["FAILED"] = "FAILED";
})(ScanStatus || (exports.ScanStatus = ScanStatus = {}));
var FilterType;
(function (FilterType) {
    FilterType["RESOURCE_IDENTIFIER"] = "resource-identifier";
    FilterType["RESOURCE_TYPE_PREFIX"] = "resource-type-prefix";
    FilterType["TAG_KEY"] = "tag-key";
    FilterType["TAG_VALUE"] = "tag-value";
})(FilterType || (exports.FilterType = FilterType = {}));
/**
 * Validates that exactly one source option has been provided.
 * @param fromPath The content of the flag `--from-path`
 * @param fromStack the content of the flag `--from-stack`
 */
function parseSourceOptions(fromPath, fromStack, stackName) {
    if (fromPath && fromStack) {
        throw new Error('Only one of `--from-path` or `--from-stack` may be provided.');
    }
    if (!stackName) {
        throw new Error('`--stack-name` is a required field.');
    }
    if (!fromPath && !fromStack) {
        return { source: TemplateSourceOptions.SCAN };
    }
    if (fromPath) {
        return { source: TemplateSourceOptions.PATH, templatePath: fromPath };
    }
    return { source: TemplateSourceOptions.STACK, stackName: stackName };
}
exports.parseSourceOptions = parseSourceOptions;
/**
 * Takes a set of resources and removes any with the managedbystack flag set to true.
 *
 * @param resourceList the list of resources provided by the list scanned resources calls
 * @returns a list of resources not managed by cfn stacks
 */
function excludeManaged(resourceList) {
    return resourceList.filter((r) => !r.ManagedByStack).map((r) => ({
        ResourceType: r.ResourceType,
        ResourceIdentifier: r.ResourceIdentifier,
    }));
}
/**
 * Transforms a list of resources into a list of resource identifiers by removing the ManagedByStack flag.
 * Setting the value of the field to undefined effectively removes it from the object.
 *
 * @param resourceList the list of resources provided by the list scanned resources calls
 * @returns a list of ScannedResourceIdentifiers
 */
function resourceIdentifiers(resourceList) {
    const identifiers = [];
    resourceList.forEach((r) => {
        const identifier = {
            ResourceType: r.ResourceType,
            ResourceIdentifier: r.ResourceIdentifier,
        };
        identifiers.push(identifier);
    });
    return identifiers;
}
/**
 * Takes a scan id and maintains a progress bar to display the progress of a scan to the user.
 *
 * @param scanId A string representing the scan id
 * @param cloudFormation The CloudFormation sdk client to use
 */
async function scanProgressBar(scanId, cfn) {
    let curProgress = 0.5;
    // we know it's in progress initially since we wouldn't have gotten here if it wasn't
    let curScan = { Status: ScanStatus.IN_PROGRESS };
    while (curScan.Status == ScanStatus.IN_PROGRESS) {
        curScan = await cfn.describeResourceScan(scanId);
        curProgress = curScan.PercentageCompleted ?? curProgress;
        printBar(30, curProgress);
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
    (0, logging_1.print)('');
    (0, logging_1.print)('✅ Scan Complete!');
}
exports.scanProgressBar = scanProgressBar;
/**
 * Prints a progress bar to the console. To be used in a while loop to show progress of a long running task.
 * The progress bar deletes the current line on the console and rewrites it with the progress amount.
 *
 * @param width The width of the progress bar
 * @param progress The current progress to display as a percentage of 100
 */
function printBar(width, progress) {
    if (!process.env.MIGRATE_INTEG_TEST) {
        const FULL_BLOCK = '█';
        const PARTIAL_BLOCK = ['', '▏', '▎', '▍', '▌', '▋', '▊', '▉'];
        const fraction = Math.min(progress / 100, 1);
        const innerWidth = Math.max(1, width - 2);
        const chars = innerWidth * fraction;
        const remainder = chars - Math.floor(chars);
        const fullChars = FULL_BLOCK.repeat(Math.floor(chars));
        const partialChar = PARTIAL_BLOCK[Math.floor(remainder * PARTIAL_BLOCK.length)];
        const filler = '·'.repeat(innerWidth - Math.floor(chars) - (partialChar ? 1 : 0));
        const color = chalk.green;
        rewriteLine('[' + color(fullChars + partialChar) + filler + `] (${progress}%)`);
    }
}
exports.printBar = printBar;
/**
 * Prints a message to the console with a series periods appended to it. To be used in a while loop to show progress of a long running task.
 * The message deletes the current line and rewrites it several times to display 1-3 periods to show the user that the task is still running.
 *
 * @param message The message to display
 * @param timeoutx4 The amount of time to wait before printing the next period
 */
async function printDots(message, timeoutx4) {
    if (!process.env.MIGRATE_INTEG_TEST) {
        rewriteLine(message + ' .');
        await new Promise(resolve => setTimeout(resolve, timeoutx4));
        rewriteLine(message + ' ..');
        await new Promise(resolve => setTimeout(resolve, timeoutx4));
        rewriteLine(message + ' ...');
        await new Promise(resolve => setTimeout(resolve, timeoutx4));
        rewriteLine(message);
        await new Promise(resolve => setTimeout(resolve, timeoutx4));
    }
}
exports.printDots = printDots;
/**
 * Rewrites the current line on the console and writes a new message to it.
 * This is a helper funciton for printDots and printBar.
 *
 * @param message The message to display
 */
function rewriteLine(message) {
    process.stdout.clearLine(0);
    process.stdout.cursorTo(0);
    process.stdout.write(message);
}
exports.rewriteLine = rewriteLine;
/**
 * Prints the time difference between two dates in days, hours, and minutes.
 *
 * @param time1 The first date to compare
 * @param time2 The second date to compare
 */
function displayTimeDiff(time1, time2) {
    const diff = Math.abs(time1.getTime() - time2.getTime());
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    (0, logging_1.print)(`Using the latest successful scan which is ${days} days, ${hours} hours, and ${minutes} minutes old.`);
}
exports.displayTimeDiff = displayTimeDiff;
/**
 * Writes a migrate.json file to the output directory.
 *
 * @param outputPath The path to write the migrate.json file to
 * @param stackName The name of the stack
 * @param generatedOutput The output of the template generator
 */
function writeMigrateJsonFile(outputPath, stackName, migrateJson) {
    const outputToJson = {
        '//': 'This file is generated by cdk migrate. It will be automatically deleted after the first successful deployment of this app to the environment of the original resources.',
        'Source': migrateJson.source,
        'Resources': migrateJson.resources,
    };
    fs.writeFileSync(`${path.join(outputPath ?? process.cwd(), stackName)}/migrate.json`, JSON.stringify(outputToJson, null, 2));
}
exports.writeMigrateJsonFile = writeMigrateJsonFile;
/**
 * Takes a string representing the from-scan flag and returns a FromScan enum value.
 *
 * @param scanType A string representing the from-scan flag
 * @returns A FromScan enum value
 */
function getMigrateScanType(scanType) {
    switch (scanType) {
        case 'new':
            return FromScan.NEW;
        case 'most-recent':
            return FromScan.MOST_RECENT;
        case '':
            return FromScan.DEFAULT;
        case undefined:
            return FromScan.DEFAULT;
        default:
            throw new Error(`Unknown scan type: ${scanType}`);
    }
}
exports.getMigrateScanType = getMigrateScanType;
/**
 * Takes a generatedTemplateOutput objct and returns a boolean representing whether there are any warnings on any rescources.
 *
 * @param generatedTemplateOutput A GenerateTemplateOutput object
 * @returns A boolean representing whether there are any warnings on any rescources
 */
function isThereAWarning(generatedTemplateOutput) {
    if (generatedTemplateOutput.resources) {
        for (const resource of generatedTemplateOutput.resources) {
            if (resource.Warnings && resource.Warnings.length > 0) {
                return true;
            }
        }
    }
    return false;
}
exports.isThereAWarning = isThereAWarning;
/**
 * Builds the GenerateTemplateOutput object from the DescribeGeneratedTemplateOutput and the template body.
 *
 * @param generatedTemplateSummary The output of the describe generated template call
 * @param templateBody The body of the generated template
 * @returns A GenerateTemplateOutput object
 */
function buildGenertedTemplateOutput(generatedTemplateSummary, templateBody, source) {
    const resources = generatedTemplateSummary.Resources;
    const migrateJson = {
        templateBody: templateBody,
        source: source,
        resources: generatedTemplateSummary.Resources.map((r) => ({
            ResourceType: r.ResourceType,
            LogicalResourceId: r.LogicalResourceId,
            ResourceIdentifier: r.ResourceIdentifier,
        })),
    };
    const templateId = generatedTemplateSummary.GeneratedTemplateId;
    return {
        migrateJson: migrateJson,
        resources: resources,
        templateId: templateId,
    };
}
exports.buildGenertedTemplateOutput = buildGenertedTemplateOutput;
/**
 * Builds a CloudFormation sdk client for making requests with the CFN template generator.
 *
 * @param sdkProvider The sdk provider for making CloudFormation calls
 * @param environment The account and region where the stack is deployed
 * @returns A CloudFormation sdk client
 */
async function buildCfnClient(sdkProvider, environment) {
    const cloudFormationClient = (await sdkProvider.forEnvironment(environment, aws_auth_1.Mode.ForReading)).sdk.cloudFormation();
    cloudFormationClient.config.customUserAgent = 'cdk-migrate';
    return cloudFormationClient;
}
exports.buildCfnClient = buildCfnClient;
/**
 * Appends a list of warnings to a readme file.
 *
 * @param filepath The path to the readme file
 * @param resources A list of resources to append warnings for
 */
function appendWarningsToReadme(filepath, resources) {
    const readme = fs.readFileSync(filepath, 'utf8');
    const lines = readme.split('\n');
    const index = lines.findIndex((line) => line.trim() === 'Enjoy!');
    let linesToAdd = ['\n## Warnings'];
    linesToAdd.push('### Write-only properties');
    linesToAdd.push("Write-only properties are resource property values that can be written to but can't be read by AWS CloudFormation or CDK Migrate. For more information, see [IaC generator and write-only properties](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/generate-IaC-write-only-properties.html).");
    linesToAdd.push('\n');
    linesToAdd.push('Write-only properties discovered during migration are organized here by resource ID and categorized by write-only property type. Resolve write-only properties by providing property values in your CDK app. For guidance, see [Resolve write-only properties](https://docs.aws.amazon.com/cdk/v2/guide/migrate.html#migrate-resources-writeonly).');
    for (const resource of resources) {
        if (resource.Warnings && resource.Warnings.length > 0) {
            linesToAdd.push(`### ${resource.LogicalResourceId}`);
            for (const warning of resource.Warnings) {
                linesToAdd.push(`- **${warning.Type}**: `);
                for (const property of warning.Properties) {
                    linesToAdd.push(`  - ${property.PropertyPath}: ${property.Description}`);
                }
            }
        }
    }
    lines.splice(index, 0, ...linesToAdd);
    fs.writeFileSync(filepath, lines.join('\n'));
}
exports.appendWarningsToReadme = appendWarningsToReadme;
/**
 * takes a list of resources and returns a list of unique resources based on the resource type and logical resource id.
 *
 * @param resources A list of resources to deduplicate
 * @returns A list of unique resources
 */
function deduplicateResources(resources) {
    let uniqueResources = {};
    for (const resource of resources) {
        const key = Object.keys(resource.ResourceIdentifier)[0];
        // Creating our unique identifier using the resource type, the key, and the value of the resource identifier
        // The resource identifier is a combination of a key value pair defined by a resource's schema, and the resource type of the resource.
        const uniqueIdentifer = `${resource.ResourceType}:${key}:${resource.ResourceIdentifier[key]}`;
        uniqueResources[uniqueIdentifer] = resource;
    }
    return Object.values(uniqueResources);
}
;
/**
 * Class for making CloudFormation template generator calls
 */
class CfnTemplateGeneratorProvider {
    constructor(cfn) {
        this.cfn = cfn;
    }
    async checkForResourceScan(resourceScanSummaries, options, clientRequestToken) {
        if (!resourceScanSummaries || resourceScanSummaries.length === 0) {
            if (options.fromScan === FromScan.MOST_RECENT) {
                throw new Error('No scans found. Please either start a new scan with the `--from-scan` new or do not specify a `--from-scan` option.');
            }
            else {
                (0, logging_1.print)('No scans found. Initiating a new resource scan.');
                await this.startResourceScan(clientRequestToken);
            }
        }
    }
    /**
     * Retrieves a tokenized list of resources and their associated scan. If a token is present the function
     * will loop through all pages and combine them into a single list of ScannedRelatedResources
     *
     * @param scanId scan id for the to list resources for
     * @param resources A list of resources to find related resources for
     */
    async getResourceScanRelatedResources(scanId, resources) {
        let relatedResourceList = resources;
        // break the list of resources into chunks of 100 to avoid hitting the 100 resource limit
        for (const chunk of chunks(resources, 100)) {
            // get the first page of related resources
            const res = await this.cfn.listResourceScanRelatedResources({
                ResourceScanId: scanId,
                Resources: chunk,
            }).promise();
            // add the first page to the list
            relatedResourceList.push(...(res.RelatedResources ?? []));
            let nextToken = res.NextToken;
            // if there are more pages, cycle through them and add them to the list before moving on to the next chunk
            while (nextToken) {
                const nextRelatedResources = await this.cfn.listResourceScanRelatedResources({
                    ResourceScanId: scanId,
                    Resources: resourceIdentifiers(resources),
                    NextToken: nextToken,
                }).promise();
                nextToken = nextRelatedResources.NextToken;
                relatedResourceList.push(...(nextRelatedResources.RelatedResources ?? []));
            }
        }
        relatedResourceList = deduplicateResources(relatedResourceList);
        // prune the managedbystack flag off of them again.
        return process.env.MIGRATE_INTEG_TEST ? resourceIdentifiers(relatedResourceList) : resourceIdentifiers(excludeManaged(relatedResourceList));
    }
    /**
     * Kicks off a scan of a customers account, returning the scan id. A scan can take
     * 10 minutes or longer to complete. However this will return a scan id as soon as
     * the scan has begun.
     *
     * @returns A string representing the scan id
     */
    async startResourceScan(requestToken) {
        return (await this.cfn.startResourceScan({
            ClientRequestToken: requestToken,
        }).promise()).ResourceScanId;
    }
    /**
     * Gets the most recent scans a customer has completed
     *
     * @returns a list of resource scan summaries
     */
    async listResourceScans() {
        return this.cfn.listResourceScans().promise();
    }
    /**
     * Retrieves a tokenized list of resources from a resource scan. If a token is present, this function
     * will loop through all pages and combine them into a single list of ScannedResources.
     * Additionally will apply any filters provided by the customer.
     *
     * @param scanId scan id for the to list resources for
     * @param filters a string of filters in the format of key1=value1,key2=value2
     * @returns a combined list of all resources from the scan
     */
    async listResourceScanResources(scanId, filters = []) {
        let resourceList = [];
        let resourceScanInputs;
        if (filters.length > 0) {
            (0, logging_1.print)('Applying filters to resource scan.');
            for (const filter of filters) {
                const filterList = parseFilters(filter);
                resourceScanInputs = {
                    ResourceScanId: scanId,
                    ResourceIdentifier: filterList[FilterType.RESOURCE_IDENTIFIER],
                    ResourceTypePrefix: filterList[FilterType.RESOURCE_TYPE_PREFIX],
                    TagKey: filterList[FilterType.TAG_KEY],
                    TagValue: filterList[FilterType.TAG_VALUE],
                };
                const resources = await this.cfn.listResourceScanResources(resourceScanInputs).promise();
                resourceList = resourceList.concat(resources.Resources ?? []);
                let nextToken = resources.NextToken;
                // cycle through the pages adding all resources to the list until we run out of pages
                while (nextToken) {
                    resourceScanInputs.NextToken = nextToken;
                    const nextResources = await this.cfn.listResourceScanResources(resourceScanInputs).promise();
                    nextToken = nextResources.NextToken;
                    resourceList = resourceList.concat(nextResources.Resources ?? []);
                }
            }
        }
        else {
            (0, logging_1.print)('No filters provided. Retrieving all resources from scan.');
            resourceScanInputs = {
                ResourceScanId: scanId,
            };
            const resources = await this.cfn.listResourceScanResources(resourceScanInputs).promise();
            resourceList = resourceList.concat(resources.Resources ?? []);
            let nextToken = resources.NextToken;
            // cycle through the pages adding all resources to the list until we run out of pages
            while (nextToken) {
                resourceScanInputs.NextToken = nextToken;
                const nextResources = await this.cfn.listResourceScanResources(resourceScanInputs).promise();
                nextToken = nextResources.NextToken;
                resourceList = resourceList.concat(nextResources.Resources ?? []);
            }
        }
        if (resourceList.length === 0) {
            throw new Error(`No resources found with filters ${filters.join(' ')}. Please try again with different filters.`);
        }
        resourceList = deduplicateResources(resourceList);
        return process.env.MIGRATE_INTEG_TEST ? resourceIdentifiers(resourceList) : resourceIdentifiers(excludeManaged(resourceList));
    }
    /**
     * Retrieves information about a resource scan.
     *
     * @param scanId scan id for the to list resources for
     * @returns information about the scan
     */
    async describeResourceScan(scanId) {
        return this.cfn.describeResourceScan({
            ResourceScanId: scanId,
        }).promise();
    }
    /**
     * Describes the current status of the template being generated.
     *
     * @param templateId A string representing the template id
     * @returns DescribeGeneratedTemplateOutput an object containing the template status and results
     */
    async describeGeneratedTemplate(templateId) {
        const generatedTemplate = await this.cfn.describeGeneratedTemplate({
            GeneratedTemplateName: templateId,
        }).promise();
        if (generatedTemplate.Status == ScanStatus.FAILED) {
            throw new Error(generatedTemplate.StatusReason);
        }
        return generatedTemplate;
    }
    /**
   * Retrieves a completed generated cloudformation template from the template generator.
   *
   * @param templateId A string representing the template id
   * @param cloudFormation The CloudFormation sdk client to use
   * @returns DescribeGeneratedTemplateOutput an object containing the template status and body
   */
    async getGeneratedTemplate(templateId) {
        return this.cfn.getGeneratedTemplate({
            GeneratedTemplateName: templateId,
        }).promise();
    }
    /**
   * Kicks off a template generation for a set of resources.
   *
   * @param stackName The name of the stack
   * @param resources A list of resources to generate the template from
   * @returns CreateGeneratedTemplateOutput an object containing the template arn to query on later
   */
    async createGeneratedTemplate(stackName, resources) {
        const createTemplateOutput = await this.cfn.createGeneratedTemplate({
            Resources: resources,
            GeneratedTemplateName: stackName,
        }).promise();
        if (createTemplateOutput.GeneratedTemplateId === undefined) {
            throw new Error('CreateGeneratedTemplate failed to return an Arn.');
        }
        return createTemplateOutput;
    }
    /**
     * Deletes a generated template from the template generator.
     *
     * @param templateArn The arn of the template to delete
     * @returns A promise that resolves when the template has been deleted
     */
    async deleteGeneratedTemplate(templateArn) {
        await this.cfn.deleteGeneratedTemplate({
            GeneratedTemplateName: templateArn,
        }).promise();
    }
}
exports.CfnTemplateGeneratorProvider = CfnTemplateGeneratorProvider;
/**
 * The possible ways to choose a scan to generate a CDK application from
 */
var FromScan;
(function (FromScan) {
    /**
     * Initiate a new resource scan to build the CDK application from.
     */
    FromScan[FromScan["NEW"] = 0] = "NEW";
    /**
     * Use the last successful scan to build the CDK application from. Will fail if no scan is found.
     */
    FromScan[FromScan["MOST_RECENT"] = 1] = "MOST_RECENT";
    /**
     * Starts a scan if none exists, otherwise uses the most recent successful scan to build the CDK application from.
     */
    FromScan[FromScan["DEFAULT"] = 2] = "DEFAULT";
})(FromScan || (exports.FromScan = FromScan = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWlncmF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1pZ3JhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMERBQTBEO0FBQzFELHVEQUF1RDtBQUN2RCx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDRDQUErRTtBQUUvRSw2Q0FBNkM7QUFDN0MsK0JBQStCO0FBQy9CLHlDQUF5QztBQUN6QywrQ0FBMEM7QUFDMUMsOENBQW9EO0FBQ3BELCtEQUFpRTtBQUNqRSw2Q0FBK0M7QUFDL0MsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3ZDLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN6QywwRUFBMEU7QUFDN0QsUUFBQSwyQkFBMkIsR0FBc0IsWUFBWSxDQUFDLG1CQUFtQixFQUFFLENBQUM7QUFFakc7Ozs7Ozs7R0FPRztBQUNJLEtBQUssVUFBVSxjQUFjLENBQUMsU0FBaUIsRUFBRSxLQUFhLEVBQUUsUUFBZ0IsRUFBRSxVQUFtQixFQUFFLFFBQWtCO0lBRTlILE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzdFLE1BQU0sa0JBQWtCLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRWpELElBQUksQ0FBQztRQUNILEVBQUUsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ2hFLEVBQUUsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUN0RCxNQUFNLFlBQVksR0FBRyxRQUFRLENBQUM7UUFDOUIsTUFBTSxJQUFBLGNBQU8sRUFBQztZQUNaLElBQUksRUFBRSxLQUFL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O0FBQ0gsSUFBWSxRQWVYO0FBZkQsV0FBWSxRQUFRO0lBQ2xCOztPQUVHO0lBQ0gscUNBQUcsQ0FBQTtJQUVIOztPQUVHO0lBQ0gscURBQVcsQ0FBQTtJQUVYOztPQUVHO0lBQ0gsNkNBQU8sQ0FBQTtBQUNULENBQUMsRUFmVyxRQUFRLHdCQUFSLFFBQVEsUUFlbkIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzICovXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgRW52aXJvbm1lbnQsIFVOS05PV05fQUNDT1VOVCwgVU5LTk9XTl9SRUdJT04gfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb24gfSBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCAqIGFzIGNka19mcm9tX2NmbiBmcm9tICdjZGstZnJvbS1jZm4nO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHsgY2xpSW5pdCB9IGZyb20gJy4uLy4uL2xpYi9pbml0JztcbmltcG9ydCB7IHByaW50IH0gZnJvbSAnLi4vLi4vbGliL2xvZ2dpbmcnO1xuaW1wb3J0IHsgTW9kZSwgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hcGkvYXdzLWF1dGgnO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25TdGFjayB9IGZyb20gJy4uL2FwaS91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IHppcERpcmVjdG9yeSB9IGZyb20gJy4uL3V0aWwvYXJjaGl2ZSc7XG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKCdjYW1lbGNhc2UnKTtcbmNvbnN0IGRlY2FtZWxpemUgPSByZXF1aXJlKCdkZWNhbWVsaXplJyk7XG4vKiogVGhlIGxpc3Qgb2YgbGFuZ3VhZ2VzIHN1cHBvcnRlZCBieSB0aGUgYnVpbHQtaW4gbm9jdGlsdWNlbnQgYmluYXJ5LiAqL1xuZXhwb3J0IGNvbnN0IE1JR1JBVEVfU1VQUE9SVEVEX0xBTkdVQUdFUzogcmVhZG9ubHkgc3RyaW5nW10gPSBjZGtfZnJvbV9jZm4uc3VwcG9ydGVkX2xhbmd1YWdlcygpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIENESyBhcHAgZnJvbSBhIHlhbWwgb3IganNvbiB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0gc3RhY2tOYW1lIFRoZSBuYW1lIHRvIGFzc2lnbiB0byB0aGUgc3RhY2sgaW4gdGhlIGdlbmVyYXRlZCBhcHBcbiAqIEBwYXJhbSBzdGFjayBUaGUgeWFtbCBvciBqc29uIHRlbXBsYXRlIGZvciB0aGUgc3RhY2tcbiAqIEBwYXJhbSBsYW5ndWFnZSBUaGUgbGFuZ3VhZ2UgdG8gZ2VuZXJhdGUgdGhlIENESyBhcHAgaW5cbiAqIEBwYXJhbSBvdXRwdXRQYXRoIFRoZSBwYXRoIGF0IHdoaWNoIHRvIGdlbmVyYXRlIHRoZSBDREsgYXBwXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNka0FwcChzdGFja05hbWU6IHN0cmluZywgc3RhY2s6IHN0cmluZywgbGFuZ3VhZ2U6IHN0cmluZywgb3V0cHV0UGF0aD86IHN0cmluZywgY29tcHJlc3M/OiBib29sZWFuKVxuICA6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXNvbHZlZE91dHB1dFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0UGF0aCA/PyBwcm9jZXNzLmN3ZCgpLCBzdGFja05hbWUpO1xuICBjb25zdCBmb3JtYXR0ZWRTdGFja05hbWUgPSBkZWNhbWVsaXplKHN0YWNrTmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBmcy5ybVN5bmMocmVzb2x2ZWRPdXRwdXRQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgZnMubWtkaXJTeW5jKHJlc29sdmVkT3V0cHV0UGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgY29uc3QgZ2VuZXJhdGVPbmx5ID0gY29tcHJlc3M7XG4gICAgYXdhaXQgY2xpSW5pdCh7XG4gICAgICB0eXBlOiAnYXBwJyxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgY2FuVXNlTmV0d29yazogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlT25seSxcbiAgICAgIHdvcmtEaXI6IHJlc29sdmVkT3V0cHV0UGF0aCxcbiAgICAgIHN0YWNrTmFtZSxcbiAgICAgIG1pZ3JhdGU6IHRydWUsXG4gICAgfSk7XG5cbiAgICBsZXQgc3RhY2tGaWxlTmFtZTogc3RyaW5nO1xuICAgIHN3aXRjaCAobGFuZ3VhZ2UpIHtcbiAgICAgIGNhc2UgJ3R5cGVzY3JpcHQnOlxuICAgICAgICBzdGFja0ZpbGVOYW1lID0gYCR7cmVzb2x2ZWRPdXRwdXRQYXRofS9saWIvJHtmb3JtYXR0ZWRTdGFja05hbWV9LXN0YWNrLnRzYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdqYXZhJzpcbiAgICAgICAgc3RhY2tGaWxlTmFtZSA9IGAke3Jlc29sdmVkT3V0cHV0UGF0aH0vc3JjL21haW4vamF2YS9jb20vbXlvcmcvJHtjYW1lbENhc2UoZm9ybWF0dGVkU3RhY2tOYW1lLCB7IHBhc2NhbENhc2U6IHRydWUgfSl9U3RhY2suamF2YWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHl0aG9uJzpcbiAgICAgICAgc3RhY2tGaWxlTmFtZSA9IGAke3Jlc29sdmVkT3V0cHV0UGF0aH0vJHtmb3JtYXR0ZWRTdGFja05hbWUucmVwbGFjZSgvLS9nLCAnXycpfS8ke2Zvcm1hdHRlZFN0YWNrTmFtZS5yZXBsYWNlKC8tL2csICdfJyl9X3N0YWNrLnB5YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjc2hhcnAnOlxuICAgICAgICBzdGFja0ZpbGVOYW1lID0gYCR7cmVzb2x2ZWRPdXRwdXRQYXRofS9zcmMvJHtjYW1lbENhc2UoZm9ybWF0dGVkU3RhY2tOYW1lLCB7IHBhc2NhbENhc2U6IHRydWUgfSl9LyR7Y2FtZWxDYXNlKGZvcm1hdHRlZFN0YWNrTmFtZSwgeyBwYXNjYWxDYXNlOiB0cnVlIH0pfVN0YWNrLmNzYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdnbyc6XG4gICAgICAgIHN0YWNrRmlsZU5hbWUgPSBgJHtyZXNvbHZlZE91dHB1dFBhdGh9LyR7Zm9ybWF0dGVkU3RhY2tOYW1lfS5nb2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhbmd1YWdlfSBpcyBub3Qgc3VwcG9ydGVkIGJ5IENESyBNaWdyYXRlLiBQbGVhc2UgY2hvb3NlIGZyb206ICR7TUlHUkFURV9TVVBQT1JURURfTEFOR1VBR0VTLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuICAgIGZzLndyaXRlRmlsZVN5bmMoc3RhY2tGaWxlTmFtZSwgc3RhY2spO1xuICAgIGlmIChjb21wcmVzcykge1xuICAgICAgYXdhaXQgemlwRGlyZWN0b3J5KHJlc29sdmVkT3V0cHV0UGF0aCwgYCR7cmVzb2x2ZWRPdXRwdXRQYXRofS56aXBgKTtcbiAgICAgIGZzLnJtU3luYyhyZXNvbHZlZE91dHB1dFBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZnMucm1TeW5jKHJlc29sdmVkT3V0cHV0UGF0aCwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgQ0RLIHN0YWNrIGZpbGUuXG4gKiBAcGFyYW0gdGVtcGxhdGUgVGhlIHRlbXBsYXRlIHRvIHRyYW5zbGF0ZSBpbnRvIGEgQ0RLIHN0YWNrXG4gKiBAcGFyYW0gc3RhY2tOYW1lIFRoZSBuYW1lIHRvIGFzc2lnbiB0byB0aGUgc3RhY2tcbiAqIEBwYXJhbSBsYW5ndWFnZSBUaGUgbGFuZ3VhZ2UgdG8gZ2VuZXJhdGUgdGhlIHN0YWNrIGluXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIENESyBzdGFjayBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVN0YWNrKHRlbXBsYXRlOiBzdHJpbmcsIHN0YWNrTmFtZTogc3RyaW5nLCBsYW5ndWFnZTogc3RyaW5nKSB7XG4gIGNvbnN0IGZvcm1hdHRlZFN0YWNrTmFtZSA9IGAke2NhbWVsQ2FzZShkZWNhbWVsaXplKHN0YWNrTmFtZSksIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KX1TdGFja2A7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNka19mcm9tX2Nmbi50cmFuc211dGUodGVtcGxhdGUsIGxhbmd1YWdlLCBmb3JtYXR0ZWRTdGFja05hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2Zvcm1hdHRlZFN0YWNrTmFtZX0gY291bGQgbm90IGJlIGdlbmVyYXRlZCBiZWNhdXNlICR7KGUgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkcyBhbmQgcmV0dXJucyBhIHN0YWNrIHRlbXBsYXRlIGZyb20gYSBsb2NhbCBwYXRoLlxuICpcbiAqIEBwYXJhbSBpbnB1dFBhdGggVGhlIGxvY2F0aW9uIG9mIHRoZSB0ZW1wbGF0ZVxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRlbXBsYXRlIGlmIHByZXNlbnQsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRGcm9tUGF0aChpbnB1dFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCByZWFkRmlsZTogc3RyaW5nO1xuICB0cnkge1xuICAgIHJlYWRGaWxlID0gZnMucmVhZEZpbGVTeW5jKGlucHV0UGF0aCwgJ3V0ZjgnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7aW5wdXRQYXRofScgaXMgbm90IGEgdmFsaWQgcGF0aC5gKTtcbiAgfVxuICBpZiAocmVhZEZpbGUgPT0gJycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENsb3VkZm9ybWF0aW9uIHRlbXBsYXRlIGZpbGVwYXRoOiAnJHtpbnB1dFBhdGh9JyBpcyBhbiBlbXB0eSBmaWxlLmApO1xuICB9XG4gIHJldHVybiByZWFkRmlsZTtcbn1cblxuLyoqXG4gKiBSZWFkcyBhbmQgcmV0dXJucyBhIHN0YWNrIHRlbXBsYXRlIGZyb20gYSBkZXBsb3llZCBDbG91ZEZvcm1hdGlvbiBzdGFjay5cbiAqXG4gKiBAcGFyYW0gc3RhY2tOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGFja1xuICogQHBhcmFtIHNka1Byb3ZpZGVyIFRoZSBzZGsgcHJvdmlkZXIgZm9yIG1ha2luZyBDbG91ZEZvcm1hdGlvbiBjYWxsc1xuICogQHBhcmFtIGVudmlyb25tZW50IFRoZSBhY2NvdW50IGFuZCByZWdpb24gd2hlcmUgdGhlIHN0YWNrIGlzIGRlcGxveWVkXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGVtcGxhdGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHVuZGVmaW5lZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEZyb21TdGFjayhzdGFja05hbWU6IHN0cmluZywgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLCBlbnZpcm9ubWVudDogRW52aXJvbm1lbnQpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBjbG91ZEZvcm1hdGlvbiA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnZpcm9ubWVudCwgTW9kZS5Gb3JSZWFkaW5nKSkuc2RrLmNsb3VkRm9ybWF0aW9uKCk7XG5cbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lLCB0cnVlKTtcbiAgaWYgKHN0YWNrLnN0YWNrU3RhdHVzLmlzRGVwbG95U3VjY2VzcyB8fCBzdGFjay5zdGFja1N0YXR1cy5pc1JvbGxiYWNrU3VjY2Vzcykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhd2FpdCBzdGFjay50ZW1wbGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YWNrICcke3N0YWNrTmFtZX0nIGluIGFjY291bnQgJHtlbnZpcm9ubWVudC5hY2NvdW50fSBhbmQgcmVnaW9uICR7ZW52aXJvbm1lbnQucmVnaW9ufSBoYXMgYSBzdGF0dXMgb2YgJyR7c3RhY2suc3RhY2tTdGF0dXMubmFtZX0nIGR1ZSB0byAnJHtzdGFjay5zdGFja1N0YXR1cy5yZWFzb259Jy4gVGhlIHN0YWNrIGNhbm5vdCBiZSBtaWdyYXRlZCB1bnRpbCBpdCBpcyBpbiBhIGhlYWx0aHkgc3RhdGUuYCk7XG4gIH1cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIFRha2VzIGluIGEgc3RhY2sgbmFtZSBhbmQgYWNjb3VudCBhbmQgcmVnaW9uIGFuZCByZXR1cm5zIGEgZ2VuZXJhdGVkIGNsb3VkZm9ybWF0aW9uIHRlbXBsYXRlIHVzaW5nIHRoZSBjbG91ZGZvcm1hdGlvblxuICogdGVtcGxhdGUgZ2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBHZW5lcmF0ZVRlbXBsYXRlT3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhY2sgbmFtZSwgZmlsdGVycywgc2RrUHJvdmlkZXIsIGVudmlyb25tZW50LCBhbmQgbmV3U2NhbiBmbGFnXG4gKiBAcmV0dXJucyBhIGdlbmVyYXRlZCBjbG91ZGZvcm1hdGlvbiB0ZW1wbGF0ZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZW1wbGF0ZShcbiAgb3B0aW9uczogR2VuZXJhdGVUZW1wbGF0ZU9wdGlvbnMsXG4pOiBQcm9taXNlPEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQ+IHtcbiAgY29uc3QgY2ZuID0gbmV3IENmblRlbXBsYXRlR2VuZXJhdG9yUHJvdmlkZXIoYXdhaXQgYnVpbGRDZm5DbGllbnQob3B0aW9ucy5zZGtQcm92aWRlciwgb3B0aW9ucy5lbnZpcm9ubWVudCkpO1xuXG4gIGNvbnN0IHNjYW5JZCA9IGF3YWl0IGZpbmRMYXN0U3VjY2Vzc2Z1bFNjYW4oY2ZuLCBvcHRpb25zKTtcblxuICAvLyBpZiBhIGN1c3RvbWVyIGFjY2lkZW50YWxseSBjdHJsLWMncyBvdXQgb2YgdGhlIGNvbW1hbmQgYW5kIHJ1bnMgaXQgYWdhaW4sIHRoaXMgd2lsbCBjb250aW51ZSB0aGUgcHJvZ3Jlc3MgYmFyIHdoZXJlIGl0IGxlZnQgb2ZmXG4gIGNvbnN0IGN1clNjYW4gPSBhd2FpdCBjZm4uZGVzY3JpYmVSZXNvdXJjZVNjYW4oc2NhbklkKTtcbiAgaWYgKChjdXJTY2FuLlN0YXR1cyA9PSBTY2FuU3RhdHVzLklOX1BST0dSRVNTKSkge1xuICAgIHByaW50KCdSZXNvdXJjZSBzY2FuIGluIHByb2dyZXNzLiBQbGVhc2Ugd2FpdCwgdGhpcyBjYW4gdGFrZSAxMCBtaW51dGVzIG9yIGxvbmdlci4nKTtcbiAgICBhd2FpdCBzY2FuUHJvZ3Jlc3NCYXIoc2NhbklkLCBjZm4pO1xuICB9XG5cbiAgZGlzcGxheVRpbWVEaWZmKG5ldyBEYXRlKCksIG5ldyBEYXRlKGN1clNjYW4uU3RhcnRUaW1lISkpO1xuXG4gIGxldCByZXNvdXJjZXM6IENsb3VkRm9ybWF0aW9uLlNjYW5uZWRSZXNvdXJjZXMgPSBhd2FpdCBjZm4ubGlzdFJlc291cmNlU2NhblJlc291cmNlcyhzY2FuSWQhLCBvcHRpb25zLmZpbHRlcnMpO1xuXG4gIHByaW50KCdmaW5kaW5nIHJlbGF0ZWQgcmVzb3VyY2VzLicpO1xuICBsZXQgcmVsYXRlZFJlc291cmNlcyA9IGF3YWl0IGNmbi5nZXRSZXNvdXJjZVNjYW5SZWxhdGVkUmVzb3VyY2VzKHNjYW5JZCEsIHJlc291cmNlcyk7XG5cbiAgcHJpbnQoYEZvdW5kICR7cmVsYXRlZFJlc291cmNlcy5sZW5ndGh9IHJlc291cmNlcy5gKTtcblxuICBwcmludCgnR2VuZXJhdGluZyBDRk4gdGVtcGxhdGUgZnJvbSBzY2FubmVkIHJlc291cmNlcy4nKTtcbiAgY29uc3QgdGVtcGxhdGVBcm4gPSAoYXdhaXQgY2ZuLmNyZWF0ZUdlbmVyYXRlZFRlbXBsYXRlKG9wdGlvbnMuc3RhY2tOYW1lLCByZWxhdGVkUmVzb3VyY2VzKSkuR2VuZXJhdGVkVGVtcGxhdGVJZCE7XG5cbiAgbGV0IGdlbmVyYXRlZFRlbXBsYXRlID0gYXdhaXQgY2ZuLmRlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGUodGVtcGxhdGVBcm4pO1xuXG4gIHByaW50KCdQbGVhc2Ugd2FpdCwgdGVtcGxhdGUgY3JlYXRpb24gaW4gcHJvZ3Jlc3MuIFRoaXMgbWF5IHRha2UgYSBjb3VwbGUgbWludXRlcy4nKTtcbiAgd2hpbGUgKGdlbmVyYXRlZFRlbXBsYXRlLlN0YXR1cyAhPT0gU2NhblN0YXR1cy5DT01QTEVURSAmJiBnZW5lcmF0ZWRUZW1wbGF0ZS5TdGF0dXMgIT09IFNjYW5TdGF0dXMuRkFJTEVEKSB7XG4gICAgYXdhaXQgcHJpbnREb3RzKGBbJHtnZW5lcmF0ZWRUZW1wbGF0ZS5TdGF0dXN9XSBUZW1wbGF0ZSBDcmVhdGlvbiBpbiBQcm9ncmVzc2AsIDQwMCk7XG4gICAgZ2VuZXJhdGVkVGVtcGxhdGUgPSBhd2FpdCBjZm4uZGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZSh0ZW1wbGF0ZUFybik7XG4gIH1cbiAgcHJpbnQoJycpO1xuICBwcmludCgnVGVtcGxhdGUgc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZCEnKTtcbiAgcmV0dXJuIGJ1aWxkR2VuZXJ0ZWRUZW1wbGF0ZU91dHB1dChnZW5lcmF0ZWRUZW1wbGF0ZSwgKGF3YWl0IGNmbi5nZXRHZW5lcmF0ZWRUZW1wbGF0ZSh0ZW1wbGF0ZUFybikpLlRlbXBsYXRlQm9keSEsIHRlbXBsYXRlQXJuKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZExhc3RTdWNjZXNzZnVsU2NhbihjZm46IENmblRlbXBsYXRlR2VuZXJhdG9yUHJvdmlkZXIsIG9wdGlvbnM6IEdlbmVyYXRlVGVtcGxhdGVPcHRpb25zKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgbGV0IHJlc291cmNlU2NhblN1bW1hcmllczogQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VTY2FuU3VtbWFyaWVzIHwgdW5kZWZpbmVkID0gW107XG4gIGNvbnN0IGNsaWVudFJlcXVlc3RUb2tlbiA9IGBjZGstbWlncmF0ZS0ke29wdGlvbnMuZW52aXJvbm1lbnQuYWNjb3VudH0tJHtvcHRpb25zLmVudmlyb25tZW50LnJlZ2lvbn1gO1xuICBpZiAob3B0aW9ucy5mcm9tU2NhbiA9PT0gRnJvbVNjYW4uTkVXKSB7XG4gICAgcHJpbnQoYFN0YXJ0aW5nIG5ldyBzY2FuIGZvciBhY2NvdW50ICR7b3B0aW9ucy5lbnZpcm9ubWVudC5hY2NvdW50fSBpbiByZWdpb24gJHtvcHRpb25zLmVudmlyb25tZW50LnJlZ2lvbn1gKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2ZuLnN0YXJ0UmVzb3VyY2VTY2FuKGNsaWVudFJlcXVlc3RUb2tlbik7XG4gICAgICByZXNvdXJjZVNjYW5TdW1tYXJpZXMgPSAoYXdhaXQgY2ZuLmxpc3RSZXNvdXJjZVNjYW5zKCkpLlJlc291cmNlU2NhblN1bW1hcmllcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBjb250aW51aW5nIGhlcmUgYmVjYXVzZSBpZiB0aGUgc2NhbiBmYWlscyBvbiBhIG5ldy1zY2FuIGl0IGlzIHZlcnkgbGlrZWx5IGJlY2F1c2UgdGhlcmUgaXMgZWl0aGVyIGFscmVhZHkgYSBzY2FuIGluIHByb2dyZXNzXG4gICAgICAvLyBvciB0aGUgY3VzdG9tZXIgaGl0IGEgcmF0ZSBsaW1pdC4gSW4gZWl0aGVyIGNhc2Ugd2Ugd2FudCB0byBjb250aW51ZSB3aXRoIHRoZSBtb3N0IHJlY2VudCBzY2FuLlxuICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIHRvIGZhaWwgZm9yIGEgY3JlZGVudGlhbCBlcnJvciB0aGVuIHRoYXQgd2lsbCBiZSBjYXVnaHQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55d2F5LlxuICAgICAgcHJpbnQoYFNjYW4gZmFpbGVkIHRvIHN0YXJ0IGR1ZSB0byBlcnJvciAnJHsoZSBhcyBFcnJvcikubWVzc2FnZX0nLCBkZWZhdWx0aW5nIHRvIGxhdGVzdCBzY2FuLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXNvdXJjZVNjYW5TdW1tYXJpZXMgPSAoYXdhaXQgY2ZuLmxpc3RSZXNvdXJjZVNjYW5zKCkpLlJlc291cmNlU2NhblN1bW1hcmllcztcbiAgICBhd2FpdCBjZm4uY2hlY2tGb3JSZXNvdXJjZVNjYW4ocmVzb3VyY2VTY2FuU3VtbWFyaWVzLCBvcHRpb25zLCBjbGllbnRSZXF1ZXN0VG9rZW4pO1xuICB9XG4gIC8vIGdldCB0aGUgbGF0ZXN0IHNjYW4sIHdoaWNoIHdlIGtub3cgd2lsbCBleGlzdFxuICByZXNvdXJjZVNjYW5TdW1tYXJpZXMgPSAoYXdhaXQgY2ZuLmxpc3RSZXNvdXJjZVNjYW5zKCkpLlJlc291cmNlU2NhblN1bW1hcmllcztcbiAgbGV0IHNjYW5JZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gcmVzb3VyY2VTY2FuU3VtbWFyaWVzIVswXS5SZXNvdXJjZVNjYW5JZDtcblxuICAvLyBmaW5kIHRoZSBtb3N0IHJlY2VudCBzY2FuIHRoYXQgaXNuJ3QgaW4gYSBmYWlsZWQgc3RhdGUgaW4gY2FzZSB3ZSBkaWRuJ3Qgc3RhcnQgYSBuZXcgb25lXG4gIGZvciAoY29uc3Qgc3VtbWFyeSBvZiByZXNvdXJjZVNjYW5TdW1tYXJpZXMhKSB7XG4gICAgaWYgKHN1bW1hcnkuU3RhdHVzICE9PSBTY2FuU3RhdHVzLkZBSUxFRCkge1xuICAgICAgc2NhbklkID0gc3VtbWFyeS5SZXNvdXJjZVNjYW5JZCE7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2NhbklkITtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHN0cmluZyBvZiBmaWx0ZXJzIGluIHRoZSBmb3JtYXQgb2Yga2V5MT12YWx1ZTEsa2V5Mj12YWx1ZTIgYW5kIHJldHVybnMgYSBtYXAgb2YgdGhlIGZpbHRlcnMuXG4gKlxuICogQHBhcmFtIGZpbHRlcnMgYSBzdHJpbmcgb2YgZmlsdGVycyBpbiB0aGUgZm9ybWF0IG9mIGtleTE9dmFsdWUxLGtleTI9dmFsdWUyXG4gKiBAcmV0dXJucyBhIG1hcCBvZiB0aGUgZmlsdGVyc1xuICovXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMoZmlsdGVyczogc3RyaW5nKToge1trZXkgaW4gRmlsdGVyVHlwZV06IHN0cmluZyB8IHVuZGVmaW5lZCB9IHtcbiAgaWYgKCFmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdyZXNvdXJjZS1pZGVudGlmaWVyJzogdW5kZWZpbmVkLFxuICAgICAgJ3Jlc291cmNlLXR5cGUtcHJlZml4JzogdW5kZWZpbmVkLFxuICAgICAgJ3RhZy1rZXknOiB1bmRlZmluZWQsXG4gICAgICAndGFnLXZhbHVlJzogdW5kZWZpbmVkLFxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgZmlsdGVyU2hvcnRoYW5kczogeyBba2V5OiBzdHJpbmddOiBGaWx0ZXJUeXBlIH0gPSB7XG4gICAgJ2lkZW50aWZpZXInOiBGaWx0ZXJUeXBlLlJFU09VUkNFX0lERU5USUZJRVIsXG4gICAgJ2lkJzogRmlsdGVyVHlwZS5SRVNPVVJDRV9JREVOVElGSUVSLFxuICAgICd0eXBlJzogRmlsdGVyVHlwZS5SRVNPVVJDRV9UWVBFX1BSRUZJWCxcbiAgICAndHlwZS1wcmVmaXgnOiBGaWx0ZXJUeXBlLlJFU09VUkNFX1RZUEVfUFJFRklYLFxuICB9O1xuXG4gIGNvbnN0IGZpbHRlckxpc3QgPSBmaWx0ZXJzLnNwbGl0KCcsJyk7XG5cbiAgbGV0IGZpbHRlck1hcDogeyBba2V5IGluIEZpbHRlclR5cGVdOiBzdHJpbmcgfCB1bmRlZmluZWR9ID0ge1xuICAgIFtGaWx0ZXJUeXBlLlJFU09VUkNFX0lERU5USUZJRVJdOiB1bmRlZmluZWQsXG4gICAgW0ZpbHRlclR5cGUuUkVTT1VSQ0VfVFlQRV9QUkVGSVhdOiB1bmRlZmluZWQsXG4gICAgW0ZpbHRlclR5cGUuVEFHX0tFWV06IHVuZGVmaW5lZCxcbiAgICBbRmlsdGVyVHlwZS5UQUdfVkFMVUVdOiB1bmRlZmluZWQsXG4gIH07XG5cbiAgZm9yIChjb25zdCBmaWwgb2YgZmlsdGVyTGlzdCkge1xuICAgIGNvbnN0IGZpbHRlciA9IGZpbC5zcGxpdCgnPScpO1xuICAgIGxldCBmaWx0ZXJLZXkgPSBmaWx0ZXJbMF07XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSBmaWx0ZXJbMV07XG4gICAgLy8gaWYgdGhlIGtleSBpcyBhIHNob3J0aGFuZCwgcmVwbGFjZSBpdCB3aXRoIHRoZSBmdWxsIG5hbWVcbiAgICBpZiAoZmlsdGVyS2V5IGluIGZpbHRlclNob3J0aGFuZHMpIHtcbiAgICAgIGZpbHRlcktleSA9IGZpbHRlclNob3J0aGFuZHNbZmlsdGVyS2V5XTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoRmlsdGVyVHlwZSkuaW5jbHVkZXMoZmlsdGVyS2V5IGFzIGFueSkpIHtcbiAgICAgIGZpbHRlck1hcFtmaWx0ZXJLZXkgYXMga2V5b2YgdHlwZW9mIGZpbHRlck1hcF0gPSBmaWx0ZXJWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpbHRlcjogJHtmaWx0ZXJLZXl9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJNYXA7XG59XG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIGFueSB0eXBlIGFuZCBicmVha3MgaXQgdXAgaW50byBjaHVua3Mgb2YgYSBzcGVjaWZpZWQgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gbGlzdCBUaGUgbGlzdCB0byBicmVhayB1cFxuICogQHBhcmFtIGNodW5rU2l6ZSBUaGUgc2l6ZSBvZiBlYWNoIGNodW5rXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgbGlzdHMgb2YgdGhlIHNwZWNpZmllZCBzaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaHVua3MobGlzdDogYW55W10sIGNodW5rU2l6ZTogbnVtYmVyKTogYW55W11bXSB7XG4gIGNvbnN0IGNodW5rZWRMaXN0OiBhbnlbXVtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgY2h1bmtlZExpc3QucHVzaChsaXN0LnNsaWNlKGksIGkgKyBjaHVua1NpemUpKTtcbiAgfVxuICByZXR1cm4gY2h1bmtlZExpc3Q7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYWNjb3VudCBhbmQgcmVnaW9uIGZvciBtYWtpbmcgQ2xvdWRGb3JtYXRpb24gY2FsbHMuXG4gKiBAcGFyYW0gYWNjb3VudCBUaGUgYWNjb3VudCB0byB1c2VcbiAqIEBwYXJhbSByZWdpb24gVGhlIHJlZ2lvbiB0byB1c2VcbiAqIEByZXR1cm5zIFRoZSBlbnZpcm9ubWVudCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEVudmlyb25tZW50KGFjY291bnQ/OiBzdHJpbmcsIHJlZ2lvbj86IHN0cmluZyk6IEVudmlyb25tZW50IHtcbiAgcmV0dXJuIHsgYWNjb3VudDogYWNjb3VudCA/PyBVTktOT1dOX0FDQ09VTlQsIHJlZ2lvbjogcmVnaW9uID8/IFVOS05PV05fUkVHSU9OLCBuYW1lOiAnY2RrLW1pZ3JhdGUtZW52JyB9O1xufVxuXG4vKipcbiAqIEVudW0gZm9yIHRoZSBzb3VyY2Ugb3B0aW9ucyBmb3IgdGhlIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBlbnVtIFRlbXBsYXRlU291cmNlT3B0aW9ucyB7XG4gIFBBVEggPSAncGF0aCcsXG4gIFNUQUNLID0gJ3N0YWNrJyxcbiAgU0NBTiA9ICdzY2FuJyxcbn1cblxuLyoqXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzb3VyY2Ugb2YgYSB0ZW1wbGF0ZS5cbiAqL1xudHlwZSBUZW1wbGF0ZVNvdXJjZSA9XG4gIHwgeyBzb3VyY2U6IFRlbXBsYXRlU291cmNlT3B0aW9ucy5TQ0FOIH1cbiAgfCB7IHNvdXJjZTogVGVtcGxhdGVTb3VyY2VPcHRpb25zLlBBVEg7IHRlbXBsYXRlUGF0aDogc3RyaW5nIH1cbiAgfCB7IHNvdXJjZTogVGVtcGxhdGVTb3VyY2VPcHRpb25zLlNUQUNLOyBzdGFja05hbWU6IHN0cmluZyB9XG4gIDtcblxuLyoqXG4gKiBFbnVtIGZvciB0aGUgc3RhdHVzIG9mIGEgcmVzb3VyY2Ugc2NhblxuICovXG5leHBvcnQgZW51bSBTY2FuU3RhdHVzIHtcbiAgSU5fUFJPR1JFU1MgPSAnSU5fUFJPR1JFU1MnLFxuICBDT01QTEVURSA9ICdDT01QTEVURScsXG4gIEZBSUxFRCA9ICdGQUlMRUQnLFxufVxuXG5leHBvcnQgZW51bSBGaWx0ZXJUeXBlIHtcbiAgUkVTT1VSQ0VfSURFTlRJRklFUiA9ICdyZXNvdXJjZS1pZGVudGlmaWVyJyxcbiAgUkVTT1VSQ0VfVFlQRV9QUkVGSVggPSAncmVzb3VyY2UtdHlwZS1wcmVmaXgnLFxuICBUQUdfS0VZID0gJ3RhZy1rZXknLFxuICBUQUdfVkFMVUUgPSAndGFnLXZhbHVlJyxcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBleGFjdGx5IG9uZSBzb3VyY2Ugb3B0aW9uIGhhcyBiZWVuIHByb3ZpZGVkLlxuICogQHBhcmFtIGZyb21QYXRoIFRoZSBjb250ZW50IG9mIHRoZSBmbGFnIGAtLWZyb20tcGF0aGBcbiAqIEBwYXJhbSBmcm9tU3RhY2sgdGhlIGNvbnRlbnQgb2YgdGhlIGZsYWcgYC0tZnJvbS1zdGFja2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU291cmNlT3B0aW9ucyhmcm9tUGF0aD86IHN0cmluZywgZnJvbVN0YWNrPzogYm9vbGVhbiwgc3RhY2tOYW1lPzogc3RyaW5nKTogVGVtcGxhdGVTb3VyY2Uge1xuICBpZiAoZnJvbVBhdGggJiYgZnJvbVN0YWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBvZiBgLS1mcm9tLXBhdGhgIG9yIGAtLWZyb20tc3RhY2tgIG1heSBiZSBwcm92aWRlZC4nKTtcbiAgfVxuICBpZiAoIXN0YWNrTmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYC0tc3RhY2stbmFtZWAgaXMgYSByZXF1aXJlZCBmaWVsZC4nKTtcbiAgfVxuICBpZiAoIWZyb21QYXRoICYmICFmcm9tU3RhY2spIHtcbiAgICByZXR1cm4geyBzb3VyY2U6IFRlbXBsYXRlU291cmNlT3B0aW9ucy5TQ0FOIH07XG4gIH1cbiAgaWYgKGZyb21QYXRoKSB7XG4gICAgcmV0dXJuIHsgc291cmNlOiBUZW1wbGF0ZVNvdXJjZU9wdGlvbnMuUEFUSCwgdGVtcGxhdGVQYXRoOiBmcm9tUGF0aCB9O1xuICB9XG4gIHJldHVybiB7IHNvdXJjZTogVGVtcGxhdGVTb3VyY2VPcHRpb25zLlNUQUNLLCBzdGFja05hbWU6IHN0YWNrTmFtZSEgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHNldCBvZiByZXNvdXJjZXMgYW5kIHJlbW92ZXMgYW55IHdpdGggdGhlIG1hbmFnZWRieXN0YWNrIGZsYWcgc2V0IHRvIHRydWUuXG4gKlxuICogQHBhcmFtIHJlc291cmNlTGlzdCB0aGUgbGlzdCBvZiByZXNvdXJjZXMgcHJvdmlkZWQgYnkgdGhlIGxpc3Qgc2Nhbm5lZCByZXNvdXJjZXMgY2FsbHNcbiAqIEByZXR1cm5zIGEgbGlzdCBvZiByZXNvdXJjZXMgbm90IG1hbmFnZWQgYnkgY2ZuIHN0YWNrc1xuICovXG5mdW5jdGlvbiBleGNsdWRlTWFuYWdlZChyZXNvdXJjZUxpc3Q6IENsb3VkRm9ybWF0aW9uLlNjYW5uZWRSZXNvdXJjZXMpOiBDbG91ZEZvcm1hdGlvbi5TY2FubmVkUmVzb3VyY2VJZGVudGlmaWVycyB7XG4gIHJldHVybiByZXNvdXJjZUxpc3QuZmlsdGVyKChyKSA9PiAhci5NYW5hZ2VkQnlTdGFjaykubWFwKChyKSA9PiAoe1xuICAgIFJlc291cmNlVHlwZTogci5SZXNvdXJjZVR5cGUhLFxuICAgIFJlc291cmNlSWRlbnRpZmllcjogci5SZXNvdXJjZUlkZW50aWZpZXIhLFxuICB9KSk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGxpc3Qgb2YgcmVzb3VyY2VzIGludG8gYSBsaXN0IG9mIHJlc291cmNlIGlkZW50aWZpZXJzIGJ5IHJlbW92aW5nIHRoZSBNYW5hZ2VkQnlTdGFjayBmbGFnLlxuICogU2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkIHRvIHVuZGVmaW5lZCBlZmZlY3RpdmVseSByZW1vdmVzIGl0IGZyb20gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcmVzb3VyY2VMaXN0IHRoZSBsaXN0IG9mIHJlc291cmNlcyBwcm92aWRlZCBieSB0aGUgbGlzdCBzY2FubmVkIHJlc291cmNlcyBjYWxsc1xuICogQHJldHVybnMgYSBsaXN0IG9mIFNjYW5uZWRSZXNvdXJjZUlkZW50aWZpZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc291cmNlSWRlbnRpZmllcnMocmVzb3VyY2VMaXN0OiBDbG91ZEZvcm1hdGlvbi5TY2FubmVkUmVzb3VyY2VzKTogQ2xvdWRGb3JtYXRpb24uU2Nhbm5lZFJlc291cmNlSWRlbnRpZmllcnMge1xuICBjb25zdCBpZGVudGlmaWVyczogQ2xvdWRGb3JtYXRpb24uU2Nhbm5lZFJlc291cmNlSWRlbnRpZmllcnMgPSBbXTtcbiAgcmVzb3VyY2VMaXN0LmZvckVhY2goKHIpID0+IHtcbiAgICBjb25zdCBpZGVudGlmaWVyOiBDbG91ZEZvcm1hdGlvbi5TY2FubmVkUmVzb3VyY2VJZGVudGlmaWVyID0ge1xuICAgICAgUmVzb3VyY2VUeXBlOiByLlJlc291cmNlVHlwZSEsXG4gICAgICBSZXNvdXJjZUlkZW50aWZpZXI6IHIuUmVzb3VyY2VJZGVudGlmaWVyISxcbiAgICB9O1xuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH0pO1xuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzY2FuIGlkIGFuZCBtYWludGFpbnMgYSBwcm9ncmVzcyBiYXIgdG8gZGlzcGxheSB0aGUgcHJvZ3Jlc3Mgb2YgYSBzY2FuIHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwYXJhbSBzY2FuSWQgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzY2FuIGlkXG4gKiBAcGFyYW0gY2xvdWRGb3JtYXRpb24gVGhlIENsb3VkRm9ybWF0aW9uIHNkayBjbGllbnQgdG8gdXNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzY2FuUHJvZ3Jlc3NCYXIoc2NhbklkOiBzdHJpbmcsIGNmbjogQ2ZuVGVtcGxhdGVHZW5lcmF0b3JQcm92aWRlcikge1xuICBsZXQgY3VyUHJvZ3Jlc3MgPSAwLjU7XG4gIC8vIHdlIGtub3cgaXQncyBpbiBwcm9ncmVzcyBpbml0aWFsbHkgc2luY2Ugd2Ugd291bGRuJ3QgaGF2ZSBnb3R0ZW4gaGVyZSBpZiBpdCB3YXNuJ3RcbiAgbGV0IGN1clNjYW46IENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlUmVzb3VyY2VTY2FuT3V0cHV0ID0geyBTdGF0dXM6IFNjYW5TdGF0dXMuSU5fUFJPR1JFU1MgfTtcbiAgd2hpbGUgKGN1clNjYW4uU3RhdHVzID09IFNjYW5TdGF0dXMuSU5fUFJPR1JFU1MpIHtcbiAgICBjdXJTY2FuID0gYXdhaXQgY2ZuLmRlc2NyaWJlUmVzb3VyY2VTY2FuKHNjYW5JZCk7XG4gICAgY3VyUHJvZ3Jlc3MgPSBjdXJTY2FuLlBlcmNlbnRhZ2VDb21wbGV0ZWQgPz8gY3VyUHJvZ3Jlc3M7XG4gICAgcHJpbnRCYXIoMzAsIGN1clByb2dyZXNzKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xuICB9XG4gIHByaW50KCcnKTtcbiAgcHJpbnQoJ+KchSBTY2FuIENvbXBsZXRlIScpO1xufVxuXG4vKipcbiAqIFByaW50cyBhIHByb2dyZXNzIGJhciB0byB0aGUgY29uc29sZS4gVG8gYmUgdXNlZCBpbiBhIHdoaWxlIGxvb3AgdG8gc2hvdyBwcm9ncmVzcyBvZiBhIGxvbmcgcnVubmluZyB0YXNrLlxuICogVGhlIHByb2dyZXNzIGJhciBkZWxldGVzIHRoZSBjdXJyZW50IGxpbmUgb24gdGhlIGNvbnNvbGUgYW5kIHJld3JpdGVzIGl0IHdpdGggdGhlIHByb2dyZXNzIGFtb3VudC5cbiAqXG4gKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXJcbiAqIEBwYXJhbSBwcm9ncmVzcyBUaGUgY3VycmVudCBwcm9ncmVzcyB0byBkaXNwbGF5IGFzIGEgcGVyY2VudGFnZSBvZiAxMDBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50QmFyKHdpZHRoOiBudW1iZXIsIHByb2dyZXNzOiBudW1iZXIpIHtcbiAgaWYgKCFwcm9jZXNzLmVudi5NSUdSQVRFX0lOVEVHX1RFU1QpIHtcbiAgICBjb25zdCBGVUxMX0JMT0NLID0gJ+KWiCc7XG4gICAgY29uc3QgUEFSVElBTF9CTE9DSyA9IFsnJywgJ+KWjycsICfilo4nLCAn4paNJywgJ+KWjCcsICfilosnLCAn4paKJywgJ+KWiSddO1xuICAgIGNvbnN0IGZyYWN0aW9uID0gTWF0aC5taW4ocHJvZ3Jlc3MgLyAxMDAsIDEpO1xuICAgIGNvbnN0IGlubmVyV2lkdGggPSBNYXRoLm1heCgxLCB3aWR0aCAtIDIpO1xuICAgIGNvbnN0IGNoYXJzID0gaW5uZXJXaWR0aCAqIGZyYWN0aW9uO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IGNoYXJzIC0gTWF0aC5mbG9vcihjaGFycyk7XG5cbiAgICBjb25zdCBmdWxsQ2hhcnMgPSBGVUxMX0JMT0NLLnJlcGVhdChNYXRoLmZsb29yKGNoYXJzKSk7XG4gICAgY29uc3QgcGFydGlhbENoYXIgPSBQQVJUSUFMX0JMT0NLW01hdGguZmxvb3IocmVtYWluZGVyICogUEFSVElBTF9CTE9DSy5sZW5ndGgpXTtcbiAgICBjb25zdCBmaWxsZXIgPSAnwrcnLnJlcGVhdChpbm5lcldpZHRoIC0gTWF0aC5mbG9vcihjaGFycykgLSAocGFydGlhbENoYXIgPyAxIDogMCkpO1xuXG4gICAgY29uc3QgY29sb3IgPSBjaGFsay5ncmVlbjtcblxuICAgIHJld3JpdGVMaW5lKCdbJyArIGNvbG9yKGZ1bGxDaGFycyArIHBhcnRpYWxDaGFyKSArIGZpbGxlciArIGBdICgke3Byb2dyZXNzfSUpYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcmludHMgYSBtZXNzYWdlIHRvIHRoZSBjb25zb2xlIHdpdGggYSBzZXJpZXMgcGVyaW9kcyBhcHBlbmRlZCB0byBpdC4gVG8gYmUgdXNlZCBpbiBhIHdoaWxlIGxvb3AgdG8gc2hvdyBwcm9ncmVzcyBvZiBhIGxvbmcgcnVubmluZyB0YXNrLlxuICogVGhlIG1lc3NhZ2UgZGVsZXRlcyB0aGUgY3VycmVudCBsaW5lIGFuZCByZXdyaXRlcyBpdCBzZXZlcmFsIHRpbWVzIHRvIGRpc3BsYXkgMS0zIHBlcmlvZHMgdG8gc2hvdyB0aGUgdXNlciB0aGF0IHRoZSB0YXNrIGlzIHN0aWxsIHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheVxuICogQHBhcmFtIHRpbWVvdXR4NCBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgcHJpbnRpbmcgdGhlIG5leHQgcGVyaW9kXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmludERvdHMobWVzc2FnZTogc3RyaW5nLCB0aW1lb3V0eDQ6IG51bWJlcikge1xuXG4gIGlmICghcHJvY2Vzcy5lbnYuTUlHUkFURV9JTlRFR19URVNUKSB7XG4gICAgcmV3cml0ZUxpbmUobWVzc2FnZSArICcgLicpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0eDQpKTtcblxuICAgIHJld3JpdGVMaW5lKG1lc3NhZ2UgKyAnIC4uJyk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXR4NCkpO1xuXG4gICAgcmV3cml0ZUxpbmUobWVzc2FnZSArICcgLi4uJyk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXR4NCkpO1xuXG4gICAgcmV3cml0ZUxpbmUobWVzc2FnZSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXR4NCkpO1xuICB9XG5cbn1cblxuLyoqXG4gKiBSZXdyaXRlcyB0aGUgY3VycmVudCBsaW5lIG9uIHRoZSBjb25zb2xlIGFuZCB3cml0ZXMgYSBuZXcgbWVzc2FnZSB0byBpdC5cbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY2l0b24gZm9yIHByaW50RG90cyBhbmQgcHJpbnRCYXIuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV3cml0ZUxpbmUobWVzc2FnZTogc3RyaW5nKSB7XG4gIHByb2Nlc3Muc3Rkb3V0LmNsZWFyTGluZSgwKTtcbiAgcHJvY2Vzcy5zdGRvdXQuY3Vyc29yVG8oMCk7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIFByaW50cyB0aGUgdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGRhdGVzIGluIGRheXMsIGhvdXJzLCBhbmQgbWludXRlcy5cbiAqXG4gKiBAcGFyYW0gdGltZTEgVGhlIGZpcnN0IGRhdGUgdG8gY29tcGFyZVxuICogQHBhcmFtIHRpbWUyIFRoZSBzZWNvbmQgZGF0ZSB0byBjb21wYXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5VGltZURpZmYodGltZTE6IERhdGUsIHRpbWUyOiBEYXRlKTogdm9pZCB7XG4gIGNvbnN0IGRpZmYgPSBNYXRoLmFicyh0aW1lMS5nZXRUaW1lKCkgLSB0aW1lMi5nZXRUaW1lKCkpO1xuXG4gIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKGRpZmYgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IoKGRpZmYgJSAoMTAwMCAqIDYwICogNjAgKiAyNCkpIC8gKDEwMDAgKiA2MCAqIDYwKSk7XG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChkaWZmICUgKDEwMDAgKiA2MCAqIDYwKSkgLyAoMTAwMCAqIDYwKSk7XG5cbiAgcHJpbnQoYFVzaW5nIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCBzY2FuIHdoaWNoIGlzICR7ZGF5c30gZGF5cywgJHtob3Vyc30gaG91cnMsIGFuZCAke21pbnV0ZXN9IG1pbnV0ZXMgb2xkLmApO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhIG1pZ3JhdGUuanNvbiBmaWxlIHRvIHRoZSBvdXRwdXQgZGlyZWN0b3J5LlxuICpcbiAqIEBwYXJhbSBvdXRwdXRQYXRoIFRoZSBwYXRoIHRvIHdyaXRlIHRoZSBtaWdyYXRlLmpzb24gZmlsZSB0b1xuICogQHBhcmFtIHN0YWNrTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RhY2tcbiAqIEBwYXJhbSBnZW5lcmF0ZWRPdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgdGVtcGxhdGUgZ2VuZXJhdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZU1pZ3JhdGVKc29uRmlsZShvdXRwdXRQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIHN0YWNrTmFtZTogc3RyaW5nLCBtaWdyYXRlSnNvbjogTWlncmF0ZUpzb25Gb3JtYXQpIHtcbiAgY29uc3Qgb3V0cHV0VG9Kc29uID0ge1xuICAgICcvLyc6ICdUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNkayBtaWdyYXRlLiBJdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZGVsZXRlZCBhZnRlciB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCBkZXBsb3ltZW50IG9mIHRoaXMgYXBwIHRvIHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgb3JpZ2luYWwgcmVzb3VyY2VzLicsXG4gICAgJ1NvdXJjZSc6IG1pZ3JhdGVKc29uLnNvdXJjZSxcbiAgICAnUmVzb3VyY2VzJzogbWlncmF0ZUpzb24ucmVzb3VyY2VzLFxuICB9O1xuICBmcy53cml0ZUZpbGVTeW5jKGAke3BhdGguam9pbihvdXRwdXRQYXRoID8/IHByb2Nlc3MuY3dkKCksIHN0YWNrTmFtZSl9L21pZ3JhdGUuanNvbmAsIEpTT04uc3RyaW5naWZ5KG91dHB1dFRvSnNvbiwgbnVsbCwgMikpO1xufVxuXG4vKipcbiAqIFRha2VzIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnJvbS1zY2FuIGZsYWcgYW5kIHJldHVybnMgYSBGcm9tU2NhbiBlbnVtIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBzY2FuVHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyb20tc2NhbiBmbGFnXG4gKiBAcmV0dXJucyBBIEZyb21TY2FuIGVudW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pZ3JhdGVTY2FuVHlwZShzY2FuVHlwZTogc3RyaW5nKSB7XG4gIHN3aXRjaCAoc2NhblR5cGUpIHtcbiAgICBjYXNlICduZXcnOlxuICAgICAgcmV0dXJuIEZyb21TY2FuLk5FVztcbiAgICBjYXNlICdtb3N0LXJlY2VudCc6XG4gICAgICByZXR1cm4gRnJvbVNjYW4uTU9TVF9SRUNFTlQ7XG4gICAgY2FzZSAnJzpcbiAgICAgIHJldHVybiBGcm9tU2Nhbi5ERUZBVUxUO1xuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgcmV0dXJuIEZyb21TY2FuLkRFRkFVTFQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY2FuIHR5cGU6ICR7c2NhblR5cGV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhIGdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0IG9iamN0IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGVyZSBhcmUgYW55IHdhcm5pbmdzIG9uIGFueSByZXNjb3VyY2VzLlxuICpcbiAqIEBwYXJhbSBnZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dCBBIEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQgb2JqZWN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhlcmUgYXJlIGFueSB3YXJuaW5ncyBvbiBhbnkgcmVzY291cmNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUaGVyZUFXYXJuaW5nKGdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0OiBHZW5lcmF0ZVRlbXBsYXRlT3V0cHV0KSB7XG4gIGlmIChnZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dC5yZXNvdXJjZXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIGdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0LnJlc291cmNlcykge1xuICAgICAgaWYgKHJlc291cmNlLldhcm5pbmdzICYmIHJlc291cmNlLldhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQgb2JqZWN0IGZyb20gdGhlIERlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQgYW5kIHRoZSB0ZW1wbGF0ZSBib2R5LlxuICpcbiAqIEBwYXJhbSBnZW5lcmF0ZWRUZW1wbGF0ZVN1bW1hcnkgVGhlIG91dHB1dCBvZiB0aGUgZGVzY3JpYmUgZ2VuZXJhdGVkIHRlbXBsYXRlIGNhbGxcbiAqIEBwYXJhbSB0ZW1wbGF0ZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZVxuICogQHJldHVybnMgQSBHZW5lcmF0ZVRlbXBsYXRlT3V0cHV0IG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZW5lcnRlZFRlbXBsYXRlT3V0cHV0KGdlbmVyYXRlZFRlbXBsYXRlU3VtbWFyeTogQ2xvdWRGb3JtYXRpb24uRGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dCxcbiAgdGVtcGxhdGVCb2R5OiBzdHJpbmcsIHNvdXJjZTogc3RyaW5nKTogR2VuZXJhdGVUZW1wbGF0ZU91dHB1dCB7XG4gIGNvbnN0IHJlc291cmNlczogQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VEZXRhaWxzIHwgdW5kZWZpbmVkID0gZ2VuZXJhdGVkVGVtcGxhdGVTdW1tYXJ5LlJlc291cmNlcztcbiAgY29uc3QgbWlncmF0ZUpzb246IE1pZ3JhdGVKc29uRm9ybWF0ID0ge1xuICAgIHRlbXBsYXRlQm9keTogdGVtcGxhdGVCb2R5LFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHJlc291cmNlczogZ2VuZXJhdGVkVGVtcGxhdGVTdW1tYXJ5LlJlc291cmNlcyEubWFwKChyKSA9PiAoe1xuICAgICAgUmVzb3VyY2VUeXBlOiByLlJlc291cmNlVHlwZSEsXG4gICAgICBMb2dpY2FsUmVzb3VyY2VJZDogci5Mb2dpY2FsUmVzb3VyY2VJZCEsXG4gICAgICBSZXNvdXJjZUlkZW50aWZpZXI6IHIuUmVzb3VyY2VJZGVudGlmaWVyISxcbiAgICB9KSksXG4gIH07XG4gIGNvbnN0IHRlbXBsYXRlSWQgPSBnZW5lcmF0ZWRUZW1wbGF0ZVN1bW1hcnkuR2VuZXJhdGVkVGVtcGxhdGVJZCE7XG4gIHJldHVybiB7XG4gICAgbWlncmF0ZUpzb246IG1pZ3JhdGVKc29uLFxuICAgIHJlc291cmNlczogcmVzb3VyY2VzLFxuICAgIHRlbXBsYXRlSWQ6IHRlbXBsYXRlSWQsXG4gIH07XG59XG5cbi8qKlxuICogQnVpbGRzIGEgQ2xvdWRGb3JtYXRpb24gc2RrIGNsaWVudCBmb3IgbWFraW5nIHJlcXVlc3RzIHdpdGggdGhlIENGTiB0ZW1wbGF0ZSBnZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIHNka1Byb3ZpZGVyIFRoZSBzZGsgcHJvdmlkZXIgZm9yIG1ha2luZyBDbG91ZEZvcm1hdGlvbiBjYWxsc1xuICogQHBhcmFtIGVudmlyb25tZW50IFRoZSBhY2NvdW50IGFuZCByZWdpb24gd2hlcmUgdGhlIHN0YWNrIGlzIGRlcGxveWVkXG4gKiBAcmV0dXJucyBBIENsb3VkRm9ybWF0aW9uIHNkayBjbGllbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkQ2ZuQ2xpZW50KHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlciwgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50KSB7XG4gIGNvbnN0IGNsb3VkRm9ybWF0aW9uQ2xpZW50ID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KGVudmlyb25tZW50LCBNb2RlLkZvclJlYWRpbmcpKS5zZGsuY2xvdWRGb3JtYXRpb24oKTtcblxuICBjbG91ZEZvcm1hdGlvbkNsaWVudC5jb25maWcuY3VzdG9tVXNlckFnZW50ID0gJ2Nkay1taWdyYXRlJztcblxuICByZXR1cm4gY2xvdWRGb3JtYXRpb25DbGllbnQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyBhIGxpc3Qgb2Ygd2FybmluZ3MgdG8gYSByZWFkbWUgZmlsZS5cbiAqXG4gKiBAcGFyYW0gZmlsZXBhdGggVGhlIHBhdGggdG8gdGhlIHJlYWRtZSBmaWxlXG4gKiBAcGFyYW0gcmVzb3VyY2VzIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8gYXBwZW5kIHdhcm5pbmdzIGZvclxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kV2FybmluZ3NUb1JlYWRtZShmaWxlcGF0aDogc3RyaW5nLCByZXNvdXJjZXM6IENsb3VkRm9ybWF0aW9uLlJlc291cmNlRGV0YWlscykge1xuICBjb25zdCByZWFkbWUgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgsICd1dGY4Jyk7XG4gIGNvbnN0IGxpbmVzID0gcmVhZG1lLnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgaW5kZXggPSBsaW5lcy5maW5kSW5kZXgoKGxpbmUpID0+IGxpbmUudHJpbSgpID09PSAnRW5qb3khJyk7XG4gIGxldCBsaW5lc1RvQWRkID0gWydcXG4jIyBXYXJuaW5ncyddO1xuICBsaW5lc1RvQWRkLnB1c2goJyMjIyBXcml0ZS1vbmx5IHByb3BlcnRpZXMnKTtcbiAgbGluZXNUb0FkZC5wdXNoKFwiV3JpdGUtb25seSBwcm9wZXJ0aWVzIGFyZSByZXNvdXJjZSBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBjYW4gYmUgd3JpdHRlbiB0byBidXQgY2FuJ3QgYmUgcmVhZCBieSBBV1MgQ2xvdWRGb3JtYXRpb24gb3IgQ0RLIE1pZ3JhdGUuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgW0lhQyBnZW5lcmF0b3IgYW5kIHdyaXRlLW9ubHkgcHJvcGVydGllc10oaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvZ2VuZXJhdGUtSWFDLXdyaXRlLW9ubHktcHJvcGVydGllcy5odG1sKS5cIik7XG4gIGxpbmVzVG9BZGQucHVzaCgnXFxuJyk7XG4gIGxpbmVzVG9BZGQucHVzaCgnV3JpdGUtb25seSBwcm9wZXJ0aWVzIGRpc2NvdmVyZWQgZHVyaW5nIG1pZ3JhdGlvbiBhcmUgb3JnYW5pemVkIGhlcmUgYnkgcmVzb3VyY2UgSUQgYW5kIGNhdGVnb3JpemVkIGJ5IHdyaXRlLW9ubHkgcHJvcGVydHkgdHlwZS4gUmVzb2x2ZSB3cml0ZS1vbmx5IHByb3BlcnRpZXMgYnkgcHJvdmlkaW5nIHByb3BlcnR5IHZhbHVlcyBpbiB5b3VyIENESyBhcHAuIEZvciBndWlkYW5jZSwgc2VlIFtSZXNvbHZlIHdyaXRlLW9ubHkgcHJvcGVydGllc10oaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay92Mi9ndWlkZS9taWdyYXRlLmh0bWwjbWlncmF0ZS1yZXNvdXJjZXMtd3JpdGVvbmx5KS4nKTtcbiAgZm9yIChjb25zdCByZXNvdXJjZSBvZiByZXNvdXJjZXMpIHtcbiAgICBpZiAocmVzb3VyY2UuV2FybmluZ3MgJiYgcmVzb3VyY2UuV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgbGluZXNUb0FkZC5wdXNoKGAjIyMgJHtyZXNvdXJjZS5Mb2dpY2FsUmVzb3VyY2VJZH1gKTtcbiAgICAgIGZvciAoY29uc3Qgd2FybmluZyBvZiByZXNvdXJjZS5XYXJuaW5ncykge1xuICAgICAgICBsaW5lc1RvQWRkLnB1c2goYC0gKioke3dhcm5pbmcuVHlwZX0qKjogYCk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2Ygd2FybmluZy5Qcm9wZXJ0aWVzISkge1xuICAgICAgICAgIGxpbmVzVG9BZGQucHVzaChgICAtICR7cHJvcGVydHkuUHJvcGVydHlQYXRofTogJHtwcm9wZXJ0eS5EZXNjcmlwdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsaW5lcy5zcGxpY2UoaW5kZXgsIDAsIC4uLmxpbmVzVG9BZGQpO1xuICBmcy53cml0ZUZpbGVTeW5jKGZpbGVwYXRoLCBsaW5lcy5qb2luKCdcXG4nKSk7XG59XG5cbi8qKlxuICogdGFrZXMgYSBsaXN0IG9mIHJlc291cmNlcyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgdW5pcXVlIHJlc291cmNlcyBiYXNlZCBvbiB0aGUgcmVzb3VyY2UgdHlwZSBhbmQgbG9naWNhbCByZXNvdXJjZSBpZC5cbiAqXG4gKiBAcGFyYW0gcmVzb3VyY2VzIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8gZGVkdXBsaWNhdGVcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiB1bmlxdWUgcmVzb3VyY2VzXG4gKi9cbmZ1bmN0aW9uIGRlZHVwbGljYXRlUmVzb3VyY2VzKHJlc291cmNlczogQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VEZXRhaWxzKSB7XG4gIGxldCB1bmlxdWVSZXNvdXJjZXM6IHtba2V5OiBzdHJpbmddOiBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZURldGFpbH0gPSB7fTtcblxuICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHJlc291cmNlcykge1xuICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKHJlc291cmNlLlJlc291cmNlSWRlbnRpZmllciEpWzBdO1xuXG4gICAgLy8gQ3JlYXRpbmcgb3VyIHVuaXF1ZSBpZGVudGlmaWVyIHVzaW5nIHRoZSByZXNvdXJjZSB0eXBlLCB0aGUga2V5LCBhbmQgdGhlIHZhbHVlIG9mIHRoZSByZXNvdXJjZSBpZGVudGlmaWVyXG4gICAgLy8gVGhlIHJlc291cmNlIGlkZW50aWZpZXIgaXMgYSBjb21iaW5hdGlvbiBvZiBhIGtleSB2YWx1ZSBwYWlyIGRlZmluZWQgYnkgYSByZXNvdXJjZSdzIHNjaGVtYSwgYW5kIHRoZSByZXNvdXJjZSB0eXBlIG9mIHRoZSByZXNvdXJjZS5cbiAgICBjb25zdCB1bmlxdWVJZGVudGlmZXIgPSBgJHtyZXNvdXJjZS5SZXNvdXJjZVR5cGV9OiR7a2V5fToke3Jlc291cmNlLlJlc291cmNlSWRlbnRpZmllciFba2V5XX1gO1xuICAgIHVuaXF1ZVJlc291cmNlc1t1bmlxdWVJZGVudGlmZXJdID0gcmVzb3VyY2U7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LnZhbHVlcyh1bmlxdWVSZXNvdXJjZXMpO1xufTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgbWFraW5nIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlIGdlbmVyYXRvciBjYWxsc1xuICovXG5leHBvcnQgY2xhc3MgQ2ZuVGVtcGxhdGVHZW5lcmF0b3JQcm92aWRlciB7XG4gIHByaXZhdGUgY2ZuOiBDbG91ZEZvcm1hdGlvbjtcbiAgY29uc3RydWN0b3IoY2ZuOiBDbG91ZEZvcm1hdGlvbikge1xuICAgIHRoaXMuY2ZuID0gY2ZuO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tGb3JSZXNvdXJjZVNjYW4ocmVzb3VyY2VTY2FuU3VtbWFyaWVzOiBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZVNjYW5TdW1tYXJpZXMgfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogR2VuZXJhdGVUZW1wbGF0ZU9wdGlvbnMsIGNsaWVudFJlcXVlc3RUb2tlbjogc3RyaW5nKSB7XG5cbiAgICBpZiAoIXJlc291cmNlU2NhblN1bW1hcmllcyB8fCByZXNvdXJjZVNjYW5TdW1tYXJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAob3B0aW9ucy5mcm9tU2NhbiA9PT0gRnJvbVNjYW4uTU9TVF9SRUNFTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzY2FucyBmb3VuZC4gUGxlYXNlIGVpdGhlciBzdGFydCBhIG5ldyBzY2FuIHdpdGggdGhlIGAtLWZyb20tc2NhbmAgbmV3IG9yIGRvIG5vdCBzcGVjaWZ5IGEgYC0tZnJvbS1zY2FuYCBvcHRpb24uJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmludCgnTm8gc2NhbnMgZm91bmQuIEluaXRpYXRpbmcgYSBuZXcgcmVzb3VyY2Ugc2Nhbi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zdGFydFJlc291cmNlU2NhbihjbGllbnRSZXF1ZXN0VG9rZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB0b2tlbml6ZWQgbGlzdCBvZiByZXNvdXJjZXMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgc2Nhbi4gSWYgYSB0b2tlbiBpcyBwcmVzZW50IHRoZSBmdW5jdGlvblxuICAgKiB3aWxsIGxvb3AgdGhyb3VnaCBhbGwgcGFnZXMgYW5kIGNvbWJpbmUgdGhlbSBpbnRvIGEgc2luZ2xlIGxpc3Qgb2YgU2Nhbm5lZFJlbGF0ZWRSZXNvdXJjZXNcbiAgICpcbiAgICogQHBhcmFtIHNjYW5JZCBzY2FuIGlkIGZvciB0aGUgdG8gbGlzdCByZXNvdXJjZXMgZm9yXG4gICAqIEBwYXJhbSByZXNvdXJjZXMgQSBsaXN0IG9mIHJlc291cmNlcyB0byBmaW5kIHJlbGF0ZWQgcmVzb3VyY2VzIGZvclxuICAgKi9cbiAgYXN5bmMgZ2V0UmVzb3VyY2VTY2FuUmVsYXRlZFJlc291cmNlcyhzY2FuSWQ6IHN0cmluZywgcmVzb3VyY2VzOiBDbG91ZEZvcm1hdGlvbi5TY2FubmVkUmVzb3VyY2VzIClcbiAgICA6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uU2Nhbm5lZFJlc291cmNlSWRlbnRpZmllcnM+IHtcbiAgICBsZXQgcmVsYXRlZFJlc291cmNlTGlzdCA9IHJlc291cmNlcztcblxuICAgIC8vIGJyZWFrIHRoZSBsaXN0IG9mIHJlc291cmNlcyBpbnRvIGNodW5rcyBvZiAxMDAgdG8gYXZvaWQgaGl0dGluZyB0aGUgMTAwIHJlc291cmNlIGxpbWl0XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MocmVzb3VyY2VzLCAxMDApKSB7XG4gICAgICAvLyBnZXQgdGhlIGZpcnN0IHBhZ2Ugb2YgcmVsYXRlZCByZXNvdXJjZXNcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZWxhdGVkUmVzb3VyY2VzKHtcbiAgICAgICAgUmVzb3VyY2VTY2FuSWQ6IHNjYW5JZCxcbiAgICAgICAgUmVzb3VyY2VzOiBjaHVuayxcbiAgICAgIH0pLnByb21pc2UoKTtcblxuICAgICAgLy8gYWRkIHRoZSBmaXJzdCBwYWdlIHRvIHRoZSBsaXN0XG4gICAgICByZWxhdGVkUmVzb3VyY2VMaXN0LnB1c2goLi4uKHJlcy5SZWxhdGVkUmVzb3VyY2VzID8/IFtdKSk7XG4gICAgICBsZXQgbmV4dFRva2VuID0gcmVzLk5leHRUb2tlbjtcblxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgcGFnZXMsIGN5Y2xlIHRocm91Z2ggdGhlbSBhbmQgYWRkIHRoZW0gdG8gdGhlIGxpc3QgYmVmb3JlIG1vdmluZyBvbiB0byB0aGUgbmV4dCBjaHVua1xuICAgICAgd2hpbGUgKG5leHRUb2tlbikge1xuICAgICAgICBjb25zdCBuZXh0UmVsYXRlZFJlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZWxhdGVkUmVzb3VyY2VzKHtcbiAgICAgICAgICBSZXNvdXJjZVNjYW5JZDogc2NhbklkLFxuICAgICAgICAgIFJlc291cmNlczogcmVzb3VyY2VJZGVudGlmaWVycyhyZXNvdXJjZXMpLFxuICAgICAgICAgIE5leHRUb2tlbjogbmV4dFRva2VuLFxuICAgICAgICB9KS5wcm9taXNlKCk7XG4gICAgICAgIG5leHRUb2tlbiA9IG5leHRSZWxhdGVkUmVzb3VyY2VzLk5leHRUb2tlbjtcbiAgICAgICAgcmVsYXRlZFJlc291cmNlTGlzdC5wdXNoKC4uLihuZXh0UmVsYXRlZFJlc291cmNlcy5SZWxhdGVkUmVzb3VyY2VzID8/IFtdKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVsYXRlZFJlc291cmNlTGlzdCA9IGRlZHVwbGljYXRlUmVzb3VyY2VzKHJlbGF0ZWRSZXNvdXJjZUxpc3QpO1xuXG4gICAgLy8gcHJ1bmUgdGhlIG1hbmFnZWRieXN0YWNrIGZsYWcgb2ZmIG9mIHRoZW0gYWdhaW4uXG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk1JR1JBVEVfSU5URUdfVEVTVCA/IHJlc291cmNlSWRlbnRpZmllcnMocmVsYXRlZFJlc291cmNlTGlzdCkgOiByZXNvdXJjZUlkZW50aWZpZXJzKGV4Y2x1ZGVNYW5hZ2VkKHJlbGF0ZWRSZXNvdXJjZUxpc3QpKSA7XG4gIH1cblxuICAvKipcbiAgICogS2lja3Mgb2ZmIGEgc2NhbiBvZiBhIGN1c3RvbWVycyBhY2NvdW50LCByZXR1cm5pbmcgdGhlIHNjYW4gaWQuIEEgc2NhbiBjYW4gdGFrZVxuICAgKiAxMCBtaW51dGVzIG9yIGxvbmdlciB0byBjb21wbGV0ZS4gSG93ZXZlciB0aGlzIHdpbGwgcmV0dXJuIGEgc2NhbiBpZCBhcyBzb29uIGFzXG4gICAqIHRoZSBzY2FuIGhhcyBiZWd1bi5cbiAgICpcbiAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzY2FuIGlkXG4gICAqL1xuICBhc3luYyBzdGFydFJlc291cmNlU2NhbihyZXF1ZXN0VG9rZW46IHN0cmluZyApIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuY2ZuLnN0YXJ0UmVzb3VyY2VTY2FuKHtcbiAgICAgIENsaWVudFJlcXVlc3RUb2tlbjogcmVxdWVzdFRva2VuLFxuICAgIH0pLnByb21pc2UoKSkuUmVzb3VyY2VTY2FuSWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9zdCByZWNlbnQgc2NhbnMgYSBjdXN0b21lciBoYXMgY29tcGxldGVkXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbGlzdCBvZiByZXNvdXJjZSBzY2FuIHN1bW1hcmllc1xuICAgKi9cbiAgYXN5bmMgbGlzdFJlc291cmNlU2NhbnMoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5jZm4ubGlzdFJlc291cmNlU2NhbnMoKS5wcm9taXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdG9rZW5pemVkIGxpc3Qgb2YgcmVzb3VyY2VzIGZyb20gYSByZXNvdXJjZSBzY2FuLiBJZiBhIHRva2VuIGlzIHByZXNlbnQsIHRoaXMgZnVuY3Rpb25cbiAgICogd2lsbCBsb29wIHRocm91Z2ggYWxsIHBhZ2VzIGFuZCBjb21iaW5lIHRoZW0gaW50byBhIHNpbmdsZSBsaXN0IG9mIFNjYW5uZWRSZXNvdXJjZXMuXG4gICAqIEFkZGl0aW9uYWxseSB3aWxsIGFwcGx5IGFueSBmaWx0ZXJzIHByb3ZpZGVkIGJ5IHRoZSBjdXN0b21lci5cbiAgICpcbiAgICogQHBhcmFtIHNjYW5JZCBzY2FuIGlkIGZvciB0aGUgdG8gbGlzdCByZXNvdXJjZXMgZm9yXG4gICAqIEBwYXJhbSBmaWx0ZXJzIGEgc3RyaW5nIG9mIGZpbHRlcnMgaW4gdGhlIGZvcm1hdCBvZiBrZXkxPXZhbHVlMSxrZXkyPXZhbHVlMlxuICAgKiBAcmV0dXJucyBhIGNvbWJpbmVkIGxpc3Qgb2YgYWxsIHJlc291cmNlcyBmcm9tIHRoZSBzY2FuXG4gICAqL1xuICBhc3luYyBsaXN0UmVzb3VyY2VTY2FuUmVzb3VyY2VzKHNjYW5JZDogc3RyaW5nLCBmaWx0ZXJzOiBzdHJpbmdbXSA9IFtdIClcbiAgICA6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uU2Nhbm5lZFJlc291cmNlSWRlbnRpZmllcnM+IHtcblxuICAgIGxldCByZXNvdXJjZUxpc3Q6IENsb3VkRm9ybWF0aW9uLlNjYW5uZWRSZXNvdXJjZXMgPSBbXTtcbiAgICBsZXQgcmVzb3VyY2VTY2FuSW5wdXRzOiBDbG91ZEZvcm1hdGlvbi5MaXN0UmVzb3VyY2VTY2FuUmVzb3VyY2VzSW5wdXQ7XG5cbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBwcmludCgnQXBwbHlpbmcgZmlsdGVycyB0byByZXNvdXJjZSBzY2FuLicpO1xuICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgICBjb25zdCBmaWx0ZXJMaXN0ID0gcGFyc2VGaWx0ZXJzKGZpbHRlcik7XG4gICAgICAgIHJlc291cmNlU2NhbklucHV0cyA9IHtcbiAgICAgICAgICBSZXNvdXJjZVNjYW5JZDogc2NhbklkLFxuICAgICAgICAgIFJlc291cmNlSWRlbnRpZmllcjogZmlsdGVyTGlzdFtGaWx0ZXJUeXBlLlJFU09VUkNFX0lERU5USUZJRVJdLFxuICAgICAgICAgIFJlc291cmNlVHlwZVByZWZpeDogZmlsdGVyTGlzdFtGaWx0ZXJUeXBlLlJFU09VUkNFX1RZUEVfUFJFRklYXSxcbiAgICAgICAgICBUYWdLZXk6IGZpbHRlckxpc3RbRmlsdGVyVHlwZS5UQUdfS0VZXSxcbiAgICAgICAgICBUYWdWYWx1ZTogZmlsdGVyTGlzdFtGaWx0ZXJUeXBlLlRBR19WQUxVRV0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXMocmVzb3VyY2VTY2FuSW5wdXRzKS5wcm9taXNlKCk7XG4gICAgICAgIHJlc291cmNlTGlzdCA9IHJlc291cmNlTGlzdC5jb25jYXQocmVzb3VyY2VzLlJlc291cmNlcyA/PyBbXSk7XG4gICAgICAgIGxldCBuZXh0VG9rZW4gPSByZXNvdXJjZXMuTmV4dFRva2VuO1xuXG4gICAgICAgIC8vIGN5Y2xlIHRocm91Z2ggdGhlIHBhZ2VzIGFkZGluZyBhbGwgcmVzb3VyY2VzIHRvIHRoZSBsaXN0IHVudGlsIHdlIHJ1biBvdXQgb2YgcGFnZXNcbiAgICAgICAgd2hpbGUgKG5leHRUb2tlbikge1xuICAgICAgICAgIHJlc291cmNlU2NhbklucHV0cy5OZXh0VG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICAgICAgY29uc3QgbmV4dFJlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXMocmVzb3VyY2VTY2FuSW5wdXRzKS5wcm9taXNlKCk7XG4gICAgICAgICAgbmV4dFRva2VuID0gbmV4dFJlc291cmNlcy5OZXh0VG9rZW47XG4gICAgICAgICAgcmVzb3VyY2VMaXN0ID0gcmVzb3VyY2VMaXN0IS5jb25jYXQobmV4dFJlc291cmNlcy5SZXNvdXJjZXMgPz8gW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50KCdObyBmaWx0ZXJzIHByb3ZpZGVkLiBSZXRyaWV2aW5nIGFsbCByZXNvdXJjZXMgZnJvbSBzY2FuLicpO1xuICAgICAgcmVzb3VyY2VTY2FuSW5wdXRzID0ge1xuICAgICAgICBSZXNvdXJjZVNjYW5JZDogc2NhbklkLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXMocmVzb3VyY2VTY2FuSW5wdXRzKS5wcm9taXNlKCk7XG4gICAgICByZXNvdXJjZUxpc3QgPSByZXNvdXJjZUxpc3QhLmNvbmNhdChyZXNvdXJjZXMuUmVzb3VyY2VzID8/IFtdKTtcbiAgICAgIGxldCBuZXh0VG9rZW4gPSByZXNvdXJjZXMuTmV4dFRva2VuO1xuXG4gICAgICAvLyBjeWNsZSB0aHJvdWdoIHRoZSBwYWdlcyBhZGRpbmcgYWxsIHJlc291cmNlcyB0byB0aGUgbGlzdCB1bnRpbCB3ZSBydW4gb3V0IG9mIHBhZ2VzXG4gICAgICB3aGlsZSAobmV4dFRva2VuKSB7XG4gICAgICAgIHJlc291cmNlU2NhbklucHV0cy5OZXh0VG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICAgIGNvbnN0IG5leHRSZXNvdXJjZXMgPSBhd2FpdCB0aGlzLmNmbi5saXN0UmVzb3VyY2VTY2FuUmVzb3VyY2VzKHJlc291cmNlU2NhbklucHV0cykucHJvbWlzZSgpO1xuICAgICAgICBuZXh0VG9rZW4gPSBuZXh0UmVzb3VyY2VzLk5leHRUb2tlbjtcbiAgICAgICAgcmVzb3VyY2VMaXN0ID0gcmVzb3VyY2VMaXN0IS5jb25jYXQobmV4dFJlc291cmNlcy5SZXNvdXJjZXMgPz8gW10pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzb3VyY2VMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByZXNvdXJjZXMgZm91bmQgd2l0aCBmaWx0ZXJzICR7ZmlsdGVycy5qb2luKCcgJyl9LiBQbGVhc2UgdHJ5IGFnYWluIHdpdGggZGlmZmVyZW50IGZpbHRlcnMuYCk7XG4gICAgfVxuICAgIHJlc291cmNlTGlzdCA9IGRlZHVwbGljYXRlUmVzb3VyY2VzKHJlc291cmNlTGlzdCk7XG5cbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTUlHUkFURV9JTlRFR19URVNUID8gcmVzb3VyY2VJZGVudGlmaWVycyhyZXNvdXJjZUxpc3QpIDogcmVzb3VyY2VJZGVudGlmaWVycyhleGNsdWRlTWFuYWdlZChyZXNvdXJjZUxpc3QpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgYSByZXNvdXJjZSBzY2FuLlxuICAgKlxuICAgKiBAcGFyYW0gc2NhbklkIHNjYW4gaWQgZm9yIHRoZSB0byBsaXN0IHJlc291cmNlcyBmb3JcbiAgICogQHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNjYW5cbiAgICovXG4gIGFzeW5jIGRlc2NyaWJlUmVzb3VyY2VTY2FuKHNjYW5JZDogc3RyaW5nICk6XG4gIFByb21pc2U8Q2xvdWRGb3JtYXRpb24uRGVzY3JpYmVSZXNvdXJjZVNjYW5PdXRwdXQ+IHtcblxuICAgIHJldHVybiB0aGlzLmNmbi5kZXNjcmliZVJlc291cmNlU2Nhbih7XG4gICAgICBSZXNvdXJjZVNjYW5JZDogc2NhbklkLFxuICAgIH0pLnByb21pc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSB0ZW1wbGF0ZSBiZWluZyBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZUlkIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdGVtcGxhdGUgaWRcbiAgICogQHJldHVybnMgRGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdGVtcGxhdGUgc3RhdHVzIGFuZCByZXN1bHRzXG4gICAqL1xuICBhc3luYyBkZXNjcmliZUdlbmVyYXRlZFRlbXBsYXRlKHRlbXBsYXRlSWQ6IHN0cmluZyApOlxuICBQcm9taXNlPENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQ+IHtcblxuICAgIGNvbnN0IGdlbmVyYXRlZFRlbXBsYXRlID0gYXdhaXQgdGhpcy5jZm4uZGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZSh7XG4gICAgICBHZW5lcmF0ZWRUZW1wbGF0ZU5hbWU6IHRlbXBsYXRlSWQsXG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgaWYgKGdlbmVyYXRlZFRlbXBsYXRlLlN0YXR1cyA9PSBTY2FuU3RhdHVzLkZBSUxFRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGdlbmVyYXRlZFRlbXBsYXRlLlN0YXR1c1JlYXNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlbmVyYXRlZFRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gKiBSZXRyaWV2ZXMgYSBjb21wbGV0ZWQgZ2VuZXJhdGVkIGNsb3VkZm9ybWF0aW9uIHRlbXBsYXRlIGZyb20gdGhlIHRlbXBsYXRlIGdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGVJZCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHRlbXBsYXRlIGlkXG4gKiBAcGFyYW0gY2xvdWRGb3JtYXRpb24gVGhlIENsb3VkRm9ybWF0aW9uIHNkayBjbGllbnQgdG8gdXNlXG4gKiBAcmV0dXJucyBEZXNjcmliZUdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZSBzdGF0dXMgYW5kIGJvZHlcbiAqL1xuICBhc3luYyBnZXRHZW5lcmF0ZWRUZW1wbGF0ZSh0ZW1wbGF0ZUlkOiBzdHJpbmcgKTpcbiAgUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5HZXRHZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dD4ge1xuXG4gICAgcmV0dXJuIHRoaXMuY2ZuLmdldEdlbmVyYXRlZFRlbXBsYXRlKHtcbiAgICAgIEdlbmVyYXRlZFRlbXBsYXRlTmFtZTogdGVtcGxhdGVJZCxcbiAgICB9KS5wcm9taXNlKCk7XG4gIH1cblxuICAvKipcbiAqIEtpY2tzIG9mZiBhIHRlbXBsYXRlIGdlbmVyYXRpb24gZm9yIGEgc2V0IG9mIHJlc291cmNlcy5cbiAqXG4gKiBAcGFyYW0gc3RhY2tOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGFja1xuICogQHBhcmFtIHJlc291cmNlcyBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGdlbmVyYXRlIHRoZSB0ZW1wbGF0ZSBmcm9tXG4gKiBAcmV0dXJucyBDcmVhdGVHZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdGVtcGxhdGUgYXJuIHRvIHF1ZXJ5IG9uIGxhdGVyXG4gKi9cbiAgYXN5bmMgY3JlYXRlR2VuZXJhdGVkVGVtcGxhdGUoc3RhY2tOYW1lOiBzdHJpbmcsIHJlc291cmNlczogQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VEZWZpbml0aW9ucyApIHtcblxuICAgIGNvbnN0IGNyZWF0ZVRlbXBsYXRlT3V0cHV0ID0gYXdhaXQgdGhpcy5jZm4uY3JlYXRlR2VuZXJhdGVkVGVtcGxhdGUoe1xuICAgICAgUmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICBHZW5lcmF0ZWRUZW1wbGF0ZU5hbWU6IHN0YWNrTmFtZSxcbiAgICB9KS5wcm9taXNlKCk7XG5cbiAgICBpZiAoY3JlYXRlVGVtcGxhdGVPdXRwdXQuR2VuZXJhdGVkVGVtcGxhdGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyZWF0ZUdlbmVyYXRlZFRlbXBsYXRlIGZhaWxlZCB0byByZXR1cm4gYW4gQXJuLicpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVGVtcGxhdGVPdXRwdXQ7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGdlbmVyYXRlZCB0ZW1wbGF0ZSBmcm9tIHRoZSB0ZW1wbGF0ZSBnZW5lcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZUFybiBUaGUgYXJuIG9mIHRoZSB0ZW1wbGF0ZSB0byBkZWxldGVcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdGVtcGxhdGUgaGFzIGJlZW4gZGVsZXRlZFxuICAgKi9cbiAgYXN5bmMgZGVsZXRlR2VuZXJhdGVkVGVtcGxhdGUodGVtcGxhdGVBcm46IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuY2ZuLmRlbGV0ZUdlbmVyYXRlZFRlbXBsYXRlKHtcbiAgICAgIEdlbmVyYXRlZFRlbXBsYXRlTmFtZTogdGVtcGxhdGVBcm4sXG4gICAgfSkucHJvbWlzZSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHBvc3NpYmxlIHdheXMgdG8gY2hvb3NlIGEgc2NhbiB0byBnZW5lcmF0ZSBhIENESyBhcHBsaWNhdGlvbiBmcm9tXG4gKi9cbmV4cG9ydCBlbnVtIEZyb21TY2FuIHtcbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgbmV3IHJlc291cmNlIHNjYW4gdG8gYnVpbGQgdGhlIENESyBhcHBsaWNhdGlvbiBmcm9tLlxuICAgKi9cbiAgTkVXLFxuXG4gIC8qKlxuICAgKiBVc2UgdGhlIGxhc3Qgc3VjY2Vzc2Z1bCBzY2FuIHRvIGJ1aWxkIHRoZSBDREsgYXBwbGljYXRpb24gZnJvbS4gV2lsbCBmYWlsIGlmIG5vIHNjYW4gaXMgZm91bmQuXG4gICAqL1xuICBNT1NUX1JFQ0VOVCxcblxuICAvKipcbiAgICogU3RhcnRzIGEgc2NhbiBpZiBub25lIGV4aXN0cywgb3RoZXJ3aXNlIHVzZXMgdGhlIG1vc3QgcmVjZW50IHN1Y2Nlc3NmdWwgc2NhbiB0byBidWlsZCB0aGUgQ0RLIGFwcGxpY2F0aW9uIGZyb20uXG4gICAqL1xuICBERUZBVUxULFxufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byB0aGUgZ2VuZXJhdGVUZW1wbGF0ZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YWNrXG4gKiBAcGFyYW0gZmlsdGVycyBBIGxpc3Qgb2YgZmlsdGVycyB0byBhcHBseSB0byB0aGUgc2NhblxuICogQHBhcmFtIGZyb21TY2FuIEFuIGVudW0gdmFsdWUgc3BlY2lmeWluZyB3aGV0aGVyIGEgbmV3IHNjYW4gc2hvdWxkIGJlIHN0YXJ0ZWQgb3IgdGhlIG1vc3QgcmVjZW50IHN1Y2Nlc3NmdWwgc2NhbiBzaG91bGQgYmUgdXNlZFxuICogQHBhcmFtIHNka1Byb3ZpZGVyIFRoZSBzZGsgcHJvdmlkZXIgZm9yIG1ha2luZyBDbG91ZEZvcm1hdGlvbiBjYWxsc1xuICogQHBhcmFtIGVudmlyb25tZW50IFRoZSBhY2NvdW50IGFuZCByZWdpb24gd2hlcmUgdGhlIHN0YWNrIGlzIGRlcGxveWVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVUZW1wbGF0ZU9wdGlvbnMge1xuICBzdGFja05hbWU6IHN0cmluZztcbiAgZmlsdGVycz86IHN0cmluZ1tdO1xuICBmcm9tU2Nhbj86IEZyb21TY2FuO1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG4gIGVudmlyb25tZW50OiBFbnZpcm9ubWVudDtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBvdXRwdXQgb2YgdGhlIGdlbmVyYXRlVGVtcGxhdGUgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gbWlncmF0ZUpzb24gVGhlIGdlbmVyYXRlZCBNaWdyYXRlLmpzb24gZmlsZVxuICogQHBhcmFtIHJlc291cmNlcyBUaGUgZ2VuZXJhdGVkIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVUZW1wbGF0ZU91dHB1dCB7XG4gIG1pZ3JhdGVKc29uOiBNaWdyYXRlSnNvbkZvcm1hdDtcbiAgcmVzb3VyY2VzPzogQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VEZXRhaWxzO1xuICB0ZW1wbGF0ZUlkPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBkZWZpbmluZyB0aGUgZm9ybWF0IG9mIHRoZSBnZW5lcmF0ZWQgTWlncmF0ZS5qc29uIGZpbGVcbiAqXG4gKiBAcGFyYW0gVGVtcGxhdGVCb2R5IFRoZSBnZW5lcmF0ZWQgdGVtcGxhdGVcbiAqIEBwYXJhbSBTb3VyY2UgVGhlIHNvdXJjZSBvZiB0aGUgdGVtcGxhdGVcbiAqIEBwYXJhbSBSZXNvdXJjZXMgQSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IHdlcmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNaWdyYXRlSnNvbkZvcm1hdCB7XG4gIHRlbXBsYXRlQm9keTogc3RyaW5nO1xuICBzb3VyY2U6IHN0cmluZztcbiAgcmVzb3VyY2VzPzogR2VuZXJhdGVkUmVzb3VyY2VJbXBvcnRJZGVudGlmaWVyW107XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgZm9ybWF0IG9mIGEgcmVzb3VyY2UgaWRlbnRpZmllciByZXF1aXJlZCBmb3IgcmVzb3VyY2UgaW1wb3J0XG4gKlxuICogQHBhcmFtIFJlc291cmNlVHlwZSBUaGUgdHlwZSBvZiByZXNvdXJjZVxuICogQHBhcmFtIExvZ2ljYWxSZXNvdXJjZUlkIFRoZSBsb2dpY2FsIGlkIG9mIHRoZSByZXNvdXJjZVxuICogQHBhcmFtIFJlc291cmNlSWRlbnRpZmllciBUaGUgcmVzb3VyY2UgaWRlbnRpZmllciBvZiB0aGUgcmVzb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0ZWRSZXNvdXJjZUltcG9ydElkZW50aWZpZXIge1xuICAvLyBjZGsgZGVwbG95IGV4cGVjdHMgdGhlIG1pZ3JhdGUuanNvbiByZXNvdXJjZSBpZGVudGlmaWVycyB0byBiZSBQYXNjYWxDYXNlLCBub3QgY2FtZWxDYXNlLlxuICBSZXNvdXJjZVR5cGU6IHN0cmluZztcbiAgTG9naWNhbFJlc291cmNlSWQ6IHN0cmluZztcbiAgUmVzb3VyY2VJZGVudGlmaWVyOiBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzO1xufVxuIl19