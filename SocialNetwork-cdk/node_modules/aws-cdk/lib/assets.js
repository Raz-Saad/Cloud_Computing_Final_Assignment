"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMetadataAssetsToManifest = void 0;
// eslint-disable-next-line max-len
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const logging_1 = require("./logging");
/**
 * Take the metadata assets from the given stack and add them to the given asset manifest
 *
 * Returns the CloudFormation parameters that need to be sent to the template to
 * pass Asset coordinates.
 */
// eslint-disable-next-line max-len
async function addMetadataAssetsToManifest(stack, assetManifest, envResources, reuse) {
    reuse = reuse || [];
    const assets = stack.assets;
    if (assets.length === 0) {
        return {};
    }
    const toolkitInfo = await envResources.lookupToolkit();
    if (!toolkitInfo.found) {
        // eslint-disable-next-line max-len
        throw new Error(`This stack uses assets, so the toolkit stack must be deployed to the environment (Run "${chalk.blue('cdk bootstrap ' + stack.environment.name)}")`);
    }
    const params = {};
    for (const asset of assets) {
        // FIXME: Should have excluded by construct path here instead of by unique ID, preferably using
        // minimatch so we can support globs. Maybe take up during artifact refactoring.
        const reuseAsset = reuse.indexOf(asset.id) > -1;
        if (reuseAsset) {
            (0, logging_1.debug)(`Reusing asset ${asset.id}: ${JSON.stringify(asset)}`);
            continue;
        }
        (0, logging_1.debug)(`Preparing asset ${asset.id}: ${JSON.stringify(asset)}`);
        if (!stack.assembly) {
            throw new Error('Unexpected: stack assembly is required in order to find assets in assembly directory');
        }
        Object.assign(params, await prepareAsset(asset, assetManifest, envResources, toolkitInfo));
    }
    return params;
}
exports.addMetadataAssetsToManifest = addMetadataAssetsToManifest;
// eslint-disable-next-line max-len
async function prepareAsset(asset, assetManifest, envResources, toolkitInfo) {
    switch (asset.packaging) {
        case 'zip':
        case 'file':
            return prepareFileAsset(asset, assetManifest, toolkitInfo, asset.packaging === 'zip' ? cxschema.FileAssetPackaging.ZIP_DIRECTORY : cxschema.FileAssetPackaging.FILE);
        case 'container-image':
            return prepareDockerImageAsset(asset, assetManifest, envResources);
        default:
            // eslint-disable-next-line max-len
            throw new Error(`Unsupported packaging type: ${asset.packaging}. You might need to upgrade your aws-cdk toolkit to support this asset type.`);
    }
}
function prepareFileAsset(asset, assetManifest, toolkitInfo, packaging) {
    const extension = packaging === cxschema.FileAssetPackaging.ZIP_DIRECTORY ? '.zip' : path.extname(asset.path);
    const baseName = `${asset.sourceHash}${extension}`;
    // Simplify key: assets/abcdef/abcdef.zip is kinda silly and unnecessary, so if they're the same just pick one component.
    const s3Prefix = asset.id === asset.sourceHash ? 'assets/' : `assets/${asset.id}/`;
    const key = `${s3Prefix}${baseName}`;
    const s3url = `s3://${toolkitInfo.bucketName}/${key}`;
    (0, logging_1.debug)(`Storing asset ${asset.path} at ${s3url}`);
    assetManifest.addFileAsset(asset.sourceHash, {
        path: asset.path,
        packaging,
    }, {
        bucketName: toolkitInfo.bucketName,
        objectKey: key,
    });
    return {
        [asset.s3BucketParameter]: toolkitInfo.bucketName,
        [asset.s3KeyParameter]: `${s3Prefix}${cxapi.ASSET_PREFIX_SEPARATOR}${baseName}`,
        [asset.artifactHashParameter]: asset.sourceHash,
    };
}
async function prepareDockerImageAsset(asset, assetManifest, envResources) {
    // Pre-1.21.0, repositoryName can be specified by the user or can be left out, in which case we make
    // a per-asset repository which will get adopted and cleaned up along with the stack.
    // Post-1.21.0, repositoryName will always be specified and it will be a shared repository between
    // all assets, and asset will have imageTag specified as well. Validate the combination.
    if (!asset.imageNameParameter && (!asset.repositoryName || !asset.imageTag)) {
        throw new Error('Invalid Docker image asset configuration: "repositoryName" and "imageTag" are required when "imageNameParameter" is left out');
    }
    const repositoryName = asset.repositoryName ?? 'cdk/' + asset.id.replace(/[:/]/g, '-').toLowerCase();
    // Make sure the repository exists, since the 'cdk-assets' tool will not create it for us.
    const { repositoryUri } = await envResources.prepareEcrRepository(repositoryName);
    const imageTag = asset.imageTag ?? asset.sourceHash;
    assetManifest.addDockerImageAsset(asset.sourceHash, {
        directory: asset.path,
        dockerBuildArgs: asset.buildArgs,
        dockerBuildSsh: asset.buildSsh,
        dockerBuildTarget: asset.target,
        dockerFile: asset.file,
        networkMode: asset.networkMode,
        platform: asset.platform,
        dockerOutputs: asset.outputs,
    }, {
        repositoryName,
        imageTag,
    });
    if (!asset.imageNameParameter) {
        return {};
    }
    return { [asset.imageNameParameter]: `${repositoryUri}:${imageTag}` };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXNzZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQyw2QkFBNkI7QUFDN0IsMkRBQTJEO0FBQzNELHlDQUF5QztBQUN6QywrQkFBK0I7QUFHL0IsdUNBQWtDO0FBR2xDOzs7OztHQUtHO0FBQ0gsbUNBQW1DO0FBQzVCLEtBQUssVUFBVSwyQkFBMkIsQ0FBQyxLQUF3QyxFQUFFLGFBQW1DLEVBQUUsWUFBa0MsRUFBRSxLQUFnQjtJQUNuTCxLQUFLLEdBQUcsS0FBSyxJQUFJLEVBQUUsQ0FBQztJQUNwQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBRTVCLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUN4QixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxNQUFNLFdBQVcsR0FBRyxNQUFNLFlBQVksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2RCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3ZCLG1DQUFtQztRQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLDBGQUEwRixLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxXQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3hLLENBQUM7SUFFRCxNQUFNLE1BQU0sR0FBMkIsRUFBRSxDQUFDO0lBRTFDLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFLENBQUM7UUFDM0IsK0ZBQStGO1FBQy9GLGdGQUFnRjtRQUNoRixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUVoRCxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ2YsSUFBQSxlQUFLLEVBQUMsaUJBQWlCLEtBQUssQ0FBQyxFQUFFLEtBQUss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TztLQUM3QixFQUFFO1FBQ0QsY0FBYztRQUNkLFFBQVE7S0FDVCxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFBQyxPQUFPLEVBQUUsQ0FBQztJQUFDLENBQUM7SUFDN0MsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsR0FBRyxhQUFhLElBQUksUUFBUSxFQUFFLEVBQUUsQ0FBQztBQUN4RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IEVudmlyb25tZW50UmVzb3VyY2VzIH0gZnJvbSAnLi9hcGkvZW52aXJvbm1lbnQtcmVzb3VyY2VzJztcbmltcG9ydCB7IFRvb2xraXRJbmZvIH0gZnJvbSAnLi9hcGkvdG9vbGtpdC1pbmZvJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IEFzc2V0TWFuaWZlc3RCdWlsZGVyIH0gZnJvbSAnLi91dGlsL2Fzc2V0LW1hbmlmZXN0LWJ1aWxkZXInO1xuXG4vKipcbiAqIFRha2UgdGhlIG1ldGFkYXRhIGFzc2V0cyBmcm9tIHRoZSBnaXZlbiBzdGFjayBhbmQgYWRkIHRoZW0gdG8gdGhlIGdpdmVuIGFzc2V0IG1hbmlmZXN0XG4gKlxuICogUmV0dXJucyB0aGUgQ2xvdWRGb3JtYXRpb24gcGFyYW1ldGVycyB0aGF0IG5lZWQgdG8gYmUgc2VudCB0byB0aGUgdGVtcGxhdGUgdG9cbiAqIHBhc3MgQXNzZXQgY29vcmRpbmF0ZXMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkTWV0YWRhdGFBc3NldHNUb01hbmlmZXN0KHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsIGFzc2V0TWFuaWZlc3Q6IEFzc2V0TWFuaWZlc3RCdWlsZGVyLCBlbnZSZXNvdXJjZXM6IEVudmlyb25tZW50UmVzb3VyY2VzLCByZXVzZT86IHN0cmluZ1tdKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gIHJldXNlID0gcmV1c2UgfHwgW107XG4gIGNvbnN0IGFzc2V0cyA9IHN0YWNrLmFzc2V0cztcblxuICBpZiAoYXNzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHRvb2xraXRJbmZvID0gYXdhaXQgZW52UmVzb3VyY2VzLmxvb2t1cFRvb2xraXQoKTtcbiAgaWYgKCF0b29sa2l0SW5mby5mb3VuZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIHN0YWNrIHVzZXMgYXNzZXRzLCBzbyB0aGUgdG9vbGtpdCBzdGFjayBtdXN0IGJlIGRlcGxveWVkIHRvIHRoZSBlbnZpcm9ubWVudCAoUnVuIFwiJHtjaGFsay5ibHVlKCdjZGsgYm9vdHN0cmFwICcgKyBzdGFjay5lbnZpcm9ubWVudCEubmFtZSl9XCIpYCk7XG4gIH1cblxuICBjb25zdCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICBmb3IgKGNvbnN0IGFzc2V0IG9mIGFzc2V0cykge1xuICAgIC8vIEZJWE1FOiBTaG91bGQgaGF2ZSBleGNsdWRlZCBieSBjb25zdHJ1Y3QgcGF0aCBoZXJlIGluc3RlYWQgb2YgYnkgdW5pcXVlIElELCBwcmVmZXJhYmx5IHVzaW5nXG4gICAgLy8gbWluaW1hdGNoIHNvIHdlIGNhbiBzdXBwb3J0IGdsb2JzLiBNYXliZSB0YWtlIHVwIGR1cmluZyBhcnRpZmFjdCByZWZhY3RvcmluZy5cbiAgICBjb25zdCByZXVzZUFzc2V0ID0gcmV1c2UuaW5kZXhPZihhc3NldC5pZCkgPiAtMTtcblxuICAgIGlmIChyZXVzZUFzc2V0KSB7XG4gICAgICBkZWJ1ZyhgUmV1c2luZyBhc3NldCAke2Fzc2V0LmlkfTogJHtKU09OLnN0cmluZ2lmeShhc3NldCl9YCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhgUHJlcGFyaW5nIGFzc2V0ICR7YXNzZXQuaWR9OiAke0pTT04uc3RyaW5naWZ5KGFzc2V0KX1gKTtcbiAgICBpZiAoIXN0YWNrLmFzc2VtYmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQ6IHN0YWNrIGFzc2VtYmx5IGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGZpbmQgYXNzZXRzIGluIGFzc2VtYmx5IGRpcmVjdG9yeScpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLCBhd2FpdCBwcmVwYXJlQXNzZXQoYXNzZXQsIGFzc2V0TWFuaWZlc3QsIGVudlJlc291cmNlcywgdG9vbGtpdEluZm8pKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlQXNzZXQoYXNzZXQ6IGN4c2NoZW1hLkFzc2V0TWV0YWRhdGFFbnRyeSwgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsIGVudlJlc291cmNlczogRW52aXJvbm1lbnRSZXNvdXJjZXMsIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICBzd2l0Y2ggKGFzc2V0LnBhY2thZ2luZykge1xuICAgIGNhc2UgJ3ppcCc6XG4gICAgY2FzZSAnZmlsZSc6XG4gICAgICByZXR1cm4gcHJlcGFyZUZpbGVBc3NldChcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIGFzc2V0TWFuaWZlc3QsXG4gICAgICAgIHRvb2xraXRJbmZvLFxuICAgICAgICBhc3NldC5wYWNrYWdpbmcgPT09ICd6aXAnID8gY3hzY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nLlpJUF9ESVJFQ1RPUlkgOiBjeHNjaGVtYS5GaWxlQXNzZXRQYWNrYWdpbmcuRklMRSk7XG4gICAgY2FzZSAnY29udGFpbmVyLWltYWdlJzpcbiAgICAgIHJldHVybiBwcmVwYXJlRG9ja2VySW1hZ2VBc3NldChhc3NldCwgYXNzZXRNYW5pZmVzdCwgZW52UmVzb3VyY2VzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFja2FnaW5nIHR5cGU6ICR7KGFzc2V0IGFzIGFueSkucGFja2FnaW5nfS4gWW91IG1pZ2h0IG5lZWQgdG8gdXBncmFkZSB5b3VyIGF3cy1jZGsgdG9vbGtpdCB0byBzdXBwb3J0IHRoaXMgYXNzZXQgdHlwZS5gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlRmlsZUFzc2V0KFxuICBhc3NldDogY3hzY2hlbWEuRmlsZUFzc2V0TWV0YWRhdGFFbnRyeSxcbiAgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsXG4gIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyxcbiAgcGFja2FnaW5nOiBjeHNjaGVtYS5GaWxlQXNzZXRQYWNrYWdpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcblxuICBjb25zdCBleHRlbnNpb24gPSBwYWNrYWdpbmcgPT09IGN4c2NoZW1hLkZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZID8gJy56aXAnIDogcGF0aC5leHRuYW1lKGFzc2V0LnBhdGgpO1xuICBjb25zdCBiYXNlTmFtZSA9IGAke2Fzc2V0LnNvdXJjZUhhc2h9JHtleHRlbnNpb259YDtcbiAgLy8gU2ltcGxpZnkga2V5OiBhc3NldHMvYWJjZGVmL2FiY2RlZi56aXAgaXMga2luZGEgc2lsbHkgYW5kIHVubmVjZXNzYXJ5LCBzbyBpZiB0aGV5J3JlIHRoZSBzYW1lIGp1c3QgcGljayBvbmUgY29tcG9uZW50LlxuICBjb25zdCBzM1ByZWZpeCA9IGFzc2V0LmlkID09PSBhc3NldC5zb3VyY2VIYXNoID8gJ2Fzc2V0cy8nIDogYGFzc2V0cy8ke2Fzc2V0LmlkfS9gO1xuICBjb25zdCBrZXkgPSBgJHtzM1ByZWZpeH0ke2Jhc2VOYW1lfWA7XG4gIGNvbnN0IHMzdXJsID0gYHMzOi8vJHt0b29sa2l0SW5mby5idWNrZXROYW1lfS8ke2tleX1gO1xuXG4gIGRlYnVnKGBTdG9yaW5nIGFzc2V0ICR7YXNzZXQucGF0aH0gYXQgJHtzM3VybH1gKTtcblxuICBhc3NldE1hbmlmZXN0LmFkZEZpbGVBc3NldChhc3NldC5zb3VyY2VIYXNoLCB7XG4gICAgcGF0aDogYXNzZXQucGF0aCxcbiAgICBwYWNrYWdpbmcsXG4gIH0sIHtcbiAgICBidWNrZXROYW1lOiB0b29sa2l0SW5mby5idWNrZXROYW1lLFxuICAgIG9iamVjdEtleToga2V5LFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIFthc3NldC5zM0J1Y2tldFBhcmFtZXRlcl06IHRvb2xraXRJbmZvLmJ1Y2tldE5hbWUsXG4gICAgW2Fzc2V0LnMzS2V5UGFyYW1ldGVyXTogYCR7czNQcmVmaXh9JHtjeGFwaS5BU1NFVF9QUkVGSVhfU0VQQVJBVE9SfSR7YmFzZU5hbWV9YCxcbiAgICBbYXNzZXQuYXJ0aWZhY3RIYXNoUGFyYW1ldGVyXTogYXNzZXQuc291cmNlSGFzaCxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZURvY2tlckltYWdlQXNzZXQoXG4gIGFzc2V0OiBjeHNjaGVtYS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSxcbiAgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsXG4gIGVudlJlc291cmNlczogRW52aXJvbm1lbnRSZXNvdXJjZXMpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcblxuICAvLyBQcmUtMS4yMS4wLCByZXBvc2l0b3J5TmFtZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIG9yIGNhbiBiZSBsZWZ0IG91dCwgaW4gd2hpY2ggY2FzZSB3ZSBtYWtlXG4gIC8vIGEgcGVyLWFzc2V0IHJlcG9zaXRvcnkgd2hpY2ggd2lsbCBnZXQgYWRvcHRlZCBhbmQgY2xlYW5lZCB1cCBhbG9uZyB3aXRoIHRoZSBzdGFjay5cbiAgLy8gUG9zdC0xLjIxLjAsIHJlcG9zaXRvcnlOYW1lIHdpbGwgYWx3YXlzIGJlIHNwZWNpZmllZCBhbmQgaXQgd2lsbCBiZSBhIHNoYXJlZCByZXBvc2l0b3J5IGJldHdlZW5cbiAgLy8gYWxsIGFzc2V0cywgYW5kIGFzc2V0IHdpbGwgaGF2ZSBpbWFnZVRhZyBzcGVjaWZpZWQgYXMgd2VsbC4gVmFsaWRhdGUgdGhlIGNvbWJpbmF0aW9uLlxuICBpZiAoIWFzc2V0LmltYWdlTmFtZVBhcmFtZXRlciAmJiAoIWFzc2V0LnJlcG9zaXRvcnlOYW1lIHx8ICFhc3NldC5pbWFnZVRhZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRG9ja2VyIGltYWdlIGFzc2V0IGNvbmZpZ3VyYXRpb246IFwicmVwb3NpdG9yeU5hbWVcIiBhbmQgXCJpbWFnZVRhZ1wiIGFyZSByZXF1aXJlZCB3aGVuIFwiaW1hZ2VOYW1lUGFyYW1ldGVyXCIgaXMgbGVmdCBvdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHJlcG9zaXRvcnlOYW1lID0gYXNzZXQucmVwb3NpdG9yeU5hbWUgPz8gJ2Nkay8nICsgYXNzZXQuaWQucmVwbGFjZSgvWzovXS9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSByZXBvc2l0b3J5IGV4aXN0cywgc2luY2UgdGhlICdjZGstYXNzZXRzJyB0b29sIHdpbGwgbm90IGNyZWF0ZSBpdCBmb3IgdXMuXG4gIGNvbnN0IHsgcmVwb3NpdG9yeVVyaSB9ID0gYXdhaXQgZW52UmVzb3VyY2VzLnByZXBhcmVFY3JSZXBvc2l0b3J5KHJlcG9zaXRvcnlOYW1lKTtcbiAgY29uc3QgaW1hZ2VUYWcgPSBhc3NldC5pbWFnZVRhZyA/PyBhc3NldC5zb3VyY2VIYXNoO1xuXG4gIGFzc2V0TWFuaWZlc3QuYWRkRG9ja2VySW1hZ2VBc3NldChhc3NldC5zb3VyY2VIYXNoLCB7XG4gICAgZGlyZWN0b3J5OiBhc3NldC5wYXRoLFxuICAgIGRvY2tlckJ1aWxkQXJnczogYXNzZXQuYnVpbGRBcmdzLFxuICAgIGRvY2tlckJ1aWxkU3NoOiBhc3NldC5idWlsZFNzaCxcbiAgICBkb2NrZXJCdWlsZFRhcmdldDogYXNzZXQudGFyZ2V0LFxuICAgIGRvY2tlckZpbGU6IGFzc2V0LmZpbGUsXG4gICAgbmV0d29ya01vZGU6IGFzc2V0Lm5ldHdvcmtNb2RlLFxuICAgIHBsYXRmb3JtOiBhc3NldC5wbGF0Zm9ybSxcbiAgICBkb2NrZXJPdXRwdXRzOiBhc3NldC5vdXRwdXRzLFxuICB9LCB7XG4gICAgcmVwb3NpdG9yeU5hbWUsXG4gICAgaW1hZ2VUYWcsXG4gIH0pO1xuXG4gIGlmICghYXNzZXQuaW1hZ2VOYW1lUGFyYW1ldGVyKSB7IHJldHVybiB7fTsgfVxuICByZXR1cm4geyBbYXNzZXQuaW1hZ2VOYW1lUGFyYW1ldGVyXTogYCR7cmVwb3NpdG9yeVVyaX06JHtpbWFnZVRhZ31gIH07XG59XG4iXX0=