"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitBySize = exports.deepMerge = exports.deepSet = exports.deepGet = exports.makeObject = exports.mapObject = exports.deepClone = exports.isEmpty = exports.applyDefaults = void 0;
const types_1 = require("./types");
/**
 * Return a new object by adding missing keys into another object
 */
function applyDefaults(hash, defaults) {
    const result = {};
    Object.keys(hash).forEach(k => result[k] = hash[k]);
    Object.keys(defaults)
        .filter(k => !(k in result))
        .forEach(k => result[k] = defaults[k]);
    return result;
}
exports.applyDefaults = applyDefaults;
/**
 * Return whether the given parameter is an empty object or empty list.
 */
function isEmpty(x) {
    if (x == null) {
        return false;
    }
    if ((0, types_1.isArray)(x)) {
        return x.length === 0;
    }
    return Object.keys(x).length === 0;
}
exports.isEmpty = isEmpty;
/**
 * Deep clone a tree of objects, lists or scalars
 *
 * Does not support cycles.
 */
function deepClone(x) {
    if (typeof x === 'undefined') {
        return undefined;
    }
    if (x === null) {
        return null;
    }
    if ((0, types_1.isArray)(x)) {
        return x.map(deepClone);
    }
    if ((0, types_1.isObject)(x)) {
        return makeObject(mapObject(x, (k, v) => [k, deepClone(v)]));
    }
    return x;
}
exports.deepClone = deepClone;
/**
 * Map over an object, treating it as a dictionary
 */
function mapObject(x, fn) {
    const ret = [];
    Object.keys(x).forEach(key => {
        ret.push(fn(key, x[key]));
    });
    return ret;
}
exports.mapObject = mapObject;
/**
 * Construct an object from a list of (k, v) pairs
 */
function makeObject(pairs) {
    const ret = {};
    for (const pair of pairs) {
        ret[pair[0]] = pair[1];
    }
    return ret;
}
exports.makeObject = makeObject;
/**
 * Deep get a value from a tree of nested objects
 *
 * Returns undefined if any part of the path was unset or
 * not an object.
 */
function deepGet(x, path) {
    path = path.slice();
    while (path.length > 0 && (0, types_1.isObject)(x)) {
        const key = path.shift();
        x = x[key];
    }
    return path.length === 0 ? x : undefined;
}
exports.deepGet = deepGet;
/**
 * Deep set a value in a tree of nested objects
 *
 * Throws an error if any part of the path is not an object.
 */
function deepSet(x, path, value) {
    path = path.slice();
    if (path.length === 0) {
        throw new Error('Path may not be empty');
    }
    while (path.length > 1 && (0, types_1.isObject)(x)) {
        const key = path.shift();
        if (!(key in x)) {
            x[key] = {};
        }
        x = x[key];
    }
    if (!(0, types_1.isObject)(x)) {
        throw new Error(`Expected an object, got '${x}'`);
    }
    if (value !== undefined) {
        x[path[0]] = value;
    }
    else {
        delete x[path[0]];
    }
}
exports.deepSet = deepSet;
/**
 * Recursively merge objects together
 *
 * The leftmost object is mutated and returned. Arrays are not merged
 * but overwritten just like scalars.
 *
 * If an object is merged into a non-object, the non-object is lost.
 */
function deepMerge(...objects) {
    function mergeOne(target, source) {
        for (const key of Object.keys(source)) {
            if (key === '__proto__' || key === 'constructor') {
                continue;
            }
            const value = source[key];
            if ((0, types_1.isObject)(value)) {
                if (!(0, types_1.isObject)(target[key])) {
                    target[key] = {};
                } // Overwrite on purpose
                mergeOne(target[key], value);
            }
            else if (typeof value !== 'undefined') {
                target[key] = value;
            }
        }
    }
    const others = objects.filter(x => x != null);
    if (others.length === 0) {
        return {};
    }
    const into = others.splice(0, 1)[0];
    others.forEach(other => mergeOne(into, other));
    return into;
}
exports.deepMerge = deepMerge;
/**
 * Splits the given object into two, such that:
 *
 * 1. The size of the first object (after stringified in UTF-8) is less than or equal to the provided size limit.
 * 2. Merging the two objects results in the original one.
 */
function splitBySize(data, maxSizeBytes) {
    if (maxSizeBytes < 2) {
        // It's impossible to fit anything in the first object
        return [undefined, data];
    }
    const entries = Object.entries(data);
    return recurse(0, 0);
    function recurse(index, runningTotalSize) {
        if (index >= entries.length) {
            // Everything fits in the first object
            return [data, undefined];
        }
        const size = runningTotalSize + entrySize(entries[index]);
        return (size > maxSizeBytes) ? cutAt(index) : recurse(index + 1, size);
    }
    function entrySize(entry) {
        return Buffer.byteLength(JSON.stringify(Object.fromEntries([entry])));
    }
    function cutAt(index) {
        return [
            Object.fromEntries(entries.slice(0, index)),
            Object.fromEntries(entries.slice(index)),
        ];
    }
}
exports.splitBySize = splitBySize;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9iamVjdHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWlEO0FBRWpEOztHQUVHO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLElBQVMsRUFBRSxRQUFhO0lBQ3BELE1BQU0sTUFBTSxHQUFRLEVBQUcsQ0FBQztJQUV4QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVwRCxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztTQUNsQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDO1NBQzNCLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV6QyxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBVkQsc0NBVUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLE9BQU8sQ0FBQyxDQUFNO0lBQzVCLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQUMsT0FBTyxLQUFLLENBQUM7SUFBQyxDQUFDO0lBQ2hDLElBQUksSUFBQSxlQUFPLEVBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7SUFBQyxDQUFDO0lBQzFDLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQ3JDLENBQUM7QUFKRCwwQkFJQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixTQUFTLENBQUMsQ0FBTTtJQUM5QixJQUFJLE9BQU8s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QUMsQ0FBQztRQUMxRCxPQUFPLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRCxTQUFTLFNBQVMsQ0FBQyxLQUF3QjtRQUN6QyxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVELFNBQVMsS0FBSyxDQUFDLEtBQWE7UUFDMUIsT0FBTztZQUNMLE1BQU0sQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDM0MsTUFBTSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3pDLENBQUM7SUFDSixDQUFDO0FBQ0gsQ0FBQztBQTVCRCxrQ0E0QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0FycmF5LCBpc09iamVjdCwgT2JqIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IG9iamVjdCBieSBhZGRpbmcgbWlzc2luZyBrZXlzIGludG8gYW5vdGhlciBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMoaGFzaDogYW55LCBkZWZhdWx0czogYW55KSB7XG4gIGNvbnN0IHJlc3VsdDogYW55ID0geyB9O1xuXG4gIE9iamVjdC5rZXlzKGhhc2gpLmZvckVhY2goayA9PiByZXN1bHRba10gPSBoYXNoW2tdKTtcblxuICBPYmplY3Qua2V5cyhkZWZhdWx0cylcbiAgICAuZmlsdGVyKGsgPT4gIShrIGluIHJlc3VsdCkpXG4gICAgLmZvckVhY2goayA9PiByZXN1bHRba10gPSBkZWZhdWx0c1trXSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIGFuIGVtcHR5IG9iamVjdCBvciBlbXB0eSBsaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eSh4OiBhbnkpIHtcbiAgaWYgKHggPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGlzQXJyYXkoeCkpIHsgcmV0dXJuIHgubGVuZ3RoID09PSAwOyB9XG4gIHJldHVybiBPYmplY3Qua2V5cyh4KS5sZW5ndGggPT09IDA7XG59XG5cbi8qKlxuICogRGVlcCBjbG9uZSBhIHRyZWUgb2Ygb2JqZWN0cywgbGlzdHMgb3Igc2NhbGFyc1xuICpcbiAqIERvZXMgbm90IHN1cHBvcnQgY3ljbGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcENsb25lKHg6IGFueSk6IGFueSB7XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICBpZiAoeCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICBpZiAoaXNBcnJheSh4KSkgeyByZXR1cm4geC5tYXAoZGVlcENsb25lKTsgfVxuICBpZiAoaXNPYmplY3QoeCkpIHsgcmV0dXJuIG1ha2VPYmplY3QobWFwT2JqZWN0KHgsIChrLCB2KSA9PiBbaywgZGVlcENsb25lKHYpXSBhcyBbc3RyaW5nLCBhbnldKSk7IH1cbiAgcmV0dXJuIHg7XG59XG5cbi8qKlxuICogTWFwIG92ZXIgYW4gb2JqZWN0LCB0cmVhdGluZyBpdCBhcyBhIGRpY3Rpb25hcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9iamVjdDxULCBVPih4OiBPYmo8VD4sIGZuOiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBUKSA9PiBVKTogVVtdIHtcbiAgY29uc3QgcmV0OiBVW10gPSBbXTtcbiAgT2JqZWN0LmtleXMoeCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIHJldC5wdXNoKGZuKGtleSwgeFtrZXldKSk7XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhbiBvYmplY3QgZnJvbSBhIGxpc3Qgb2YgKGssIHYpIHBhaXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT2JqZWN0PFQ+KHBhaXJzOiBBcnJheTxbc3RyaW5nLCBUXT4pOiBPYmo8VD4ge1xuICBjb25zdCByZXQ6IE9iajxUPiA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICByZXRbcGFpclswXV0gPSBwYWlyWzFdO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRGVlcCBnZXQgYSB2YWx1ZSBmcm9tIGEgdHJlZSBvZiBuZXN0ZWQgb2JqZWN0c1xuICpcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIGFueSBwYXJ0IG9mIHRoZSBwYXRoIHdhcyB1bnNldCBvclxuICogbm90IGFuIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBHZXQoeDogYW55LCBwYXRoOiBzdHJpbmdbXSk6IGFueSB7XG4gIHBhdGggPSBwYXRoLnNsaWNlKCk7XG5cbiAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCAmJiBpc09iamVjdCh4KSkge1xuICAgIGNvbnN0IGtleSA9IHBhdGguc2hpZnQoKSE7XG4gICAgeCA9IHhba2V5XTtcbiAgfVxuICByZXR1cm4gcGF0aC5sZW5ndGggPT09IDAgPyB4IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERlZXAgc2V0IGEgdmFsdWUgaW4gYSB0cmVlIG9mIG5lc3RlZCBvYmplY3RzXG4gKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGFueSBwYXJ0IG9mIHRoZSBwYXRoIGlzIG5vdCBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwU2V0KHg6IGFueSwgcGF0aDogc3RyaW5nW10sIHZhbHVlOiBhbnkpIHtcbiAgcGF0aCA9IHBhdGguc2xpY2UoKTtcblxuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbWF5IG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMSAmJiBpc09iamVjdCh4KSkge1xuICAgIGNvbnN0IGtleSA9IHBhdGguc2hpZnQoKSE7XG4gICAgaWYgKCEoa2V5IGluIHgpKSB7IHhba2V5XSA9IHt9OyB9XG4gICAgeCA9IHhba2V5XTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QoeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIG9iamVjdCwgZ290ICcke3h9J2ApO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB4W3BhdGhbMF1dID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHhbcGF0aFswXV07XG4gIH1cbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIHRvZ2V0aGVyXG4gKlxuICogVGhlIGxlZnRtb3N0IG9iamVjdCBpcyBtdXRhdGVkIGFuZCByZXR1cm5lZC4gQXJyYXlzIGFyZSBub3QgbWVyZ2VkXG4gKiBidXQgb3ZlcndyaXR0ZW4ganVzdCBsaWtlIHNjYWxhcnMuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIG1lcmdlZCBpbnRvIGEgbm9uLW9iamVjdCwgdGhlIG5vbi1vYmplY3QgaXMgbG9zdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNZXJnZSguLi5vYmplY3RzOiBBcnJheTxPYmo8YW55PiB8IHVuZGVmaW5lZD4pIHtcbiAgZnVuY3Rpb24gbWVyZ2VPbmUodGFyZ2V0OiBPYmo8YW55Piwgc291cmNlOiBPYmo8YW55Pikge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHRhcmdldFtrZXldKSkgeyB0YXJnZXRba2V5XSA9IHt9OyB9IC8vIE92ZXJ3cml0ZSBvbiBwdXJwb3NlXG4gICAgICAgIG1lcmdlT25lKHRhcmdldFtrZXldLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvdGhlcnMgPSBvYmplY3RzLmZpbHRlcih4ID0+IHggIT0gbnVsbCkgYXMgQXJyYXk8T2JqPGFueT4+O1xuXG4gIGlmIChvdGhlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybiB7fTsgfVxuICBjb25zdCBpbnRvID0gb3RoZXJzLnNwbGljZSgwLCAxKVswXTtcblxuICBvdGhlcnMuZm9yRWFjaChvdGhlciA9PiBtZXJnZU9uZShpbnRvLCBvdGhlcikpO1xuICByZXR1cm4gaW50bztcbn1cblxuLyoqXG4gKiBTcGxpdHMgdGhlIGdpdmVuIG9iamVjdCBpbnRvIHR3bywgc3VjaCB0aGF0OlxuICpcbiAqIDEuIFRoZSBzaXplIG9mIHRoZSBmaXJzdCBvYmplY3QgKGFmdGVyIHN0cmluZ2lmaWVkIGluIFVURi04KSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIHNpemUgbGltaXQuXG4gKiAyLiBNZXJnaW5nIHRoZSB0d28gb2JqZWN0cyByZXN1bHRzIGluIHRoZSBvcmlnaW5hbCBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEJ5U2l6ZShkYXRhOiBhbnksIG1heFNpemVCeXRlczogbnVtYmVyKTogW2FueSwgYW55XSB7XG4gIGlmIChtYXhTaXplQnl0ZXMgPCAyKSB7XG4gICAgLy8gSXQncyBpbXBvc3NpYmxlIHRvIGZpdCBhbnl0aGluZyBpbiB0aGUgZmlyc3Qgb2JqZWN0XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGRhdGFdO1xuICB9XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhkYXRhKTtcbiAgcmV0dXJuIHJlY3Vyc2UoMCwgMCk7XG5cbiAgZnVuY3Rpb24gcmVjdXJzZShpbmRleDogbnVtYmVyLCBydW5uaW5nVG90YWxTaXplOiBudW1iZXIpOiBbYW55LCBhbnldIHtcbiAgICBpZiAoaW5kZXggPj0gZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZml0cyBpbiB0aGUgZmlyc3Qgb2JqZWN0XG4gICAgICByZXR1cm4gW2RhdGEsIHVuZGVmaW5lZF07XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IHJ1bm5pbmdUb3RhbFNpemUgKyBlbnRyeVNpemUoZW50cmllc1tpbmRleF0pO1xuICAgIHJldHVybiAoc2l6ZSA+IG1heFNpemVCeXRlcykgPyBjdXRBdChpbmRleCkgOiByZWN1cnNlKGluZGV4ICsgMSwgc2l6ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRyeVNpemUoZW50cnk6IFtzdHJpbmcsIHVua25vd25dKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyhbZW50cnldKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3V0QXQoaW5kZXg6IG51bWJlcik6IFthbnksIGFueV0ge1xuICAgIHJldHVybiBbXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcy5zbGljZSgwLCBpbmRleCkpLFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMuc2xpY2UoaW5kZXgpKSxcbiAgICBdO1xuICB9XG59Il19