"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAccessKeyCache = void 0;
const path = require("path");
const fs = require("fs-extra");
const _env_1 = require("./_env");
/**
 * Disk cache which maps access key IDs to account IDs.
 * Usage:
 *   cache.get(accessKey) => accountId | undefined
 *   cache.put(accessKey, accountId)
 */
class AccountAccessKeyCache {
    /**
     * @param filePath Path to the cache file
     */
    constructor(filePath) {
        this.cacheFile = filePath || path.join((0, _env_1.accountCacheDir)(), 'accounts_partitions.json');
    }
    /**
     * Tries to fetch the account ID from cache. If it's not in the cache, invokes
     * the resolver function which should retrieve the account ID and return it.
     * Then, it will be stored into disk cache returned.
     *
     * Example:
     *
     *    const accountId = cache.fetch(accessKey, async () => {
     *      return await fetchAccountIdFromSomewhere(accessKey);
     *    });
     *
     * @param accessKeyId
     * @param resolver
     */
    async fetch(accessKeyId, resolver) {
        // try to get account ID based on this access key ID from disk.
        const cached = await this.get(accessKeyId);
        if (cached) {
            (0, _env_1.debug)(`Retrieved account ID ${cached.accountId} from disk cache`);
            return cached;
        }
        // if it's not in the cache, resolve and put in cache.
        const account = await resolver();
        if (account) {
            await this.put(accessKeyId, account);
        }
        return account;
    }
    /** Get the account ID from an access key or undefined if not in cache */
    async get(accessKeyId) {
        const map = await this.loadMap();
        return map[accessKeyId];
    }
    /** Put a mapping between access key and account ID */
    async put(accessKeyId, account) {
        let map = await this.loadMap();
        // nuke cache if it's too big.
        if (Object.keys(map).length >= AccountAccessKeyCache.MAX_ENTRIES) {
            map = {};
        }
        map[accessKeyId] = account;
        await this.saveMap(map);
    }
    async loadMap() {
        try {
            return await fs.readJson(this.cacheFile);
        }
        catch (e) {
            // File doesn't exist or is not readable. This is a cache,
            // pretend we successfully loaded an empty map.
            if (e.code === 'ENOENT' || e.code === 'EACCES') {
                return {};
            }
            // File is not JSON, could be corrupted because of concurrent writes.
            // Again, an empty cache is fine.
            if (e instanceof SyntaxError) {
                return {};
            }
            throw e;
        }
    }
    async saveMap(map) {
        try {
            await fs.ensureFile(this.cacheFile);
            await fs.writeJson(this.cacheFile, map, { spaces: 2 });
        }
        catch (e) {
            // File doesn't exist or file/dir isn't writable. This is a cache,
            // if we can't write it then too bad.
            if (e.code === 'ENOENT' || e.code === 'EACCES' || e.code === 'EROFS') {
                return;
            }
            throw e;
        }
    }
}
exports.AccountAccessKeyCache = AccountAccessKeyCache;
/**
 * Max number of entries in the cache, after which the cache will be reset.
 */
AccountAccessKeyCache.MAX_ENTRIES = 1000;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC1jYWNoZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFjY291bnQtY2FjaGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixpQ0FBZ0Q7QUFHaEQ7Ozs7O0dBS0c7QUFDSCxNQUFhLHFCQUFxQjtJQVFoQzs7T0FFRztJQUNILFlBQVksUUFBaUI7UUFDM0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFBLHNCQUFlLEdBQUUsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO0lBQ3hGLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksS0FBSyxDQUFDLEtBQUssQ0FBb0IsV0FBbUIsRUFBRSxRQUEwQjtRQUNuRiwrREFBK0Q7UUFDL0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzNDLElBQUksTUFBTSxFQUFFLENBQUM7WUFDWCxJQUFBLFlBQUssRUFBQyx3QkFBd0IsTUFBTSxDQUFDLFNBQVMsa0JBQWtCLENBQUMsQ0FBQztZQUNsRSxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQsc0RBQXNEO1FBQ3RELE1BQU0sT0FBTyxHQUFHLE1BQU0sUUFBUSxFQUFFLENBQUM7UUFDakMsSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUNaLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDdkMsQ0FBQztRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCx5RUFBeUU7SUFDbEUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxXQUFtQjtRQUNsQyxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqQyxPQUFPLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQsc0RBQXNEO0lBQy9DLEtBQUssQ0FBQyxHQUFHLENBQUMsV0FBbUIsRUFBRSxPQUFnQjtRQUNwRCxJQUFJLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUUvQiw4QkFBOEI7UUFDOUIsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxxQkFBcUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNqRSxHQUFHLEdBQUcsRUFBRyxDQUFDO1FBQ1osQ0FBQztRQUVELEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDM0IsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFTyxLQUFLLENBQUMsT0FBTztRQUNuQixJQUFJLENBQUM7WUFDSCxPQUFPLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0MsQ0FBQztRQUFDLE9BQU8sQ0FBTSxFQUFFLENBQUM7WUFDaEIsMERBQTBEO1lBQzFELCtDQUErQztZQUMvQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFLENBQUM7Z0JBQUMsT0FBTyxFQUFFLENBQUM7WUFBQyxDQUFDO1lBQzlELHFFQUFxRTtZQUNyRSxpQ0FBaUM7WUFDakMsSUFBSSxDQUFDLFlBQVksV0FBVyxFQUFFLENBQUM7Z0JBQUMsT0FBTyxFQUFFLENBQUM7WUFBQyxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxDQUFDO1FBQ1YsQ0FBQztJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQXVDO1FBQzNELElBQUksQ0FBQztZQUNILE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDcEMsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDekQsQ0FBQztRQUFDLE9BQU8sQ0FBTSxFQUFFLENBQUM7WUFDaEIsa0VBQWtFO1lBQ2xFLHFDQUFxQztZQUNyQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssT0FBTyxFQUFFLENBQUM7Z0JBQUMsT0FBTztZQUFDLENBQUM7WUFDakYsTUFBTSxDQUFDLENBQUM7UUFDVixDQUFDO0lBQ0gsQ0FBQzs7QUF6Rkgsc0RBMEZDO0FBekZDOztHQUVHO0FBQ29CLGlDQUFXLEdBQUcsSUFBSSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IGFjY291bnRDYWNoZURpciwgZGVidWcgfSBmcm9tICcuL19lbnYnO1xuaW1wb3J0IHsgQWNjb3VudCB9IGZyb20gJy4vc2RrLXByb3ZpZGVyJztcblxuLyoqXG4gKiBEaXNrIGNhY2hlIHdoaWNoIG1hcHMgYWNjZXNzIGtleSBJRHMgdG8gYWNjb3VudCBJRHMuXG4gKiBVc2FnZTpcbiAqICAgY2FjaGUuZ2V0KGFjY2Vzc0tleSkgPT4gYWNjb3VudElkIHwgdW5kZWZpbmVkXG4gKiAgIGNhY2hlLnB1dChhY2Nlc3NLZXksIGFjY291bnRJZClcbiAqL1xuZXhwb3J0IGNsYXNzIEFjY291bnRBY2Nlc3NLZXlDYWNoZSB7XG4gIC8qKlxuICAgKiBNYXggbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNhY2hlLCBhZnRlciB3aGljaCB0aGUgY2FjaGUgd2lsbCBiZSByZXNldC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTUFYX0VOVFJJRVMgPSAxMDAwO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGVGaWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBmaWxlUGF0aCBQYXRoIHRvIHRoZSBjYWNoZSBmaWxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmaWxlUGF0aD86IHN0cmluZykge1xuICAgIHRoaXMuY2FjaGVGaWxlID0gZmlsZVBhdGggfHwgcGF0aC5qb2luKGFjY291bnRDYWNoZURpcigpLCAnYWNjb3VudHNfcGFydGl0aW9ucy5qc29uJyk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gZmV0Y2ggdGhlIGFjY291bnQgSUQgZnJvbSBjYWNoZS4gSWYgaXQncyBub3QgaW4gdGhlIGNhY2hlLCBpbnZva2VzXG4gICAqIHRoZSByZXNvbHZlciBmdW5jdGlvbiB3aGljaCBzaG91bGQgcmV0cmlldmUgdGhlIGFjY291bnQgSUQgYW5kIHJldHVybiBpdC5cbiAgICogVGhlbiwgaXQgd2lsbCBiZSBzdG9yZWQgaW50byBkaXNrIGNhY2hlIHJldHVybmVkLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgICBjb25zdCBhY2NvdW50SWQgPSBjYWNoZS5mZXRjaChhY2Nlc3NLZXksIGFzeW5jICgpID0+IHtcbiAgICogICAgICByZXR1cm4gYXdhaXQgZmV0Y2hBY2NvdW50SWRGcm9tU29tZXdoZXJlKGFjY2Vzc0tleSk7XG4gICAqICAgIH0pO1xuICAgKlxuICAgKiBAcGFyYW0gYWNjZXNzS2V5SWRcbiAgICogQHBhcmFtIHJlc29sdmVyXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZmV0Y2g8QSBleHRlbmRzIEFjY291bnQ+KGFjY2Vzc0tleUlkOiBzdHJpbmcsIHJlc29sdmVyOiAoKSA9PiBQcm9taXNlPEE+KSB7XG4gICAgLy8gdHJ5IHRvIGdldCBhY2NvdW50IElEIGJhc2VkIG9uIHRoaXMgYWNjZXNzIGtleSBJRCBmcm9tIGRpc2suXG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgdGhpcy5nZXQoYWNjZXNzS2V5SWQpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIGRlYnVnKGBSZXRyaWV2ZWQgYWNjb3VudCBJRCAke2NhY2hlZC5hY2NvdW50SWR9IGZyb20gZGlzayBjYWNoZWApO1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIG5vdCBpbiB0aGUgY2FjaGUsIHJlc29sdmUgYW5kIHB1dCBpbiBjYWNoZS5cbiAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgcmVzb2x2ZXIoKTtcbiAgICBpZiAoYWNjb3VudCkge1xuICAgICAgYXdhaXQgdGhpcy5wdXQoYWNjZXNzS2V5SWQsIGFjY291bnQpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NvdW50O1xuICB9XG5cbiAgLyoqIEdldCB0aGUgYWNjb3VudCBJRCBmcm9tIGFuIGFjY2VzcyBrZXkgb3IgdW5kZWZpbmVkIGlmIG5vdCBpbiBjYWNoZSAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0KGFjY2Vzc0tleUlkOiBzdHJpbmcpOiBQcm9taXNlPEFjY291bnQgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBtYXAgPSBhd2FpdCB0aGlzLmxvYWRNYXAoKTtcbiAgICByZXR1cm4gbWFwW2FjY2Vzc0tleUlkXTtcbiAgfVxuXG4gIC8qKiBQdXQgYSBtYXBwaW5nIGJldHdlZW4gYWNjZXNzIGtleSBhbmQgYWNjb3VudCBJRCAqL1xuICBwdWJsaWMgYXN5bmMgcHV0KGFjY2Vzc0tleUlkOiBzdHJpbmcsIGFjY291bnQ6IEFjY291bnQpIHtcbiAgICBsZXQgbWFwID0gYXdhaXQgdGhpcy5sb2FkTWFwKCk7XG5cbiAgICAvLyBudWtlIGNhY2hlIGlmIGl0J3MgdG9vIGJpZy5cbiAgICBpZiAoT2JqZWN0LmtleXMobWFwKS5sZW5ndGggPj0gQWNjb3VudEFjY2Vzc0tleUNhY2hlLk1BWF9FTlRSSUVTKSB7XG4gICAgICBtYXAgPSB7IH07XG4gICAgfVxuXG4gICAgbWFwW2FjY2Vzc0tleUlkXSA9IGFjY291bnQ7XG4gICAgYXdhaXQgdGhpcy5zYXZlTWFwKG1hcCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWRNYXAoKTogUHJvbWlzZTx7IFthY2Nlc3NLZXlJZDogc3RyaW5nXTogQWNjb3VudCB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBmcy5yZWFkSnNvbih0aGlzLmNhY2hlRmlsZSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBGaWxlIGRvZXNuJ3QgZXhpc3Qgb3IgaXMgbm90IHJlYWRhYmxlLiBUaGlzIGlzIGEgY2FjaGUsXG4gICAgICAvLyBwcmV0ZW5kIHdlIHN1Y2Nlc3NmdWxseSBsb2FkZWQgYW4gZW1wdHkgbWFwLlxuICAgICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcgfHwgZS5jb2RlID09PSAnRUFDQ0VTJykgeyByZXR1cm4ge307IH1cbiAgICAgIC8vIEZpbGUgaXMgbm90IEpTT04sIGNvdWxkIGJlIGNvcnJ1cHRlZCBiZWNhdXNlIG9mIGNvbmN1cnJlbnQgd3JpdGVzLlxuICAgICAgLy8gQWdhaW4sIGFuIGVtcHR5IGNhY2hlIGlzIGZpbmUuXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7IHJldHVybiB7fTsgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNhdmVNYXAobWFwOiB7IFthY2Nlc3NLZXlJZDogc3RyaW5nXTogQWNjb3VudCB9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLmVuc3VyZUZpbGUodGhpcy5jYWNoZUZpbGUpO1xuICAgICAgYXdhaXQgZnMud3JpdGVKc29uKHRoaXMuY2FjaGVGaWxlLCBtYXAsIHsgc3BhY2VzOiAyIH0pO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gRmlsZSBkb2Vzbid0IGV4aXN0IG9yIGZpbGUvZGlyIGlzbid0IHdyaXRhYmxlLiBUaGlzIGlzIGEgY2FjaGUsXG4gICAgICAvLyBpZiB3ZSBjYW4ndCB3cml0ZSBpdCB0aGVuIHRvbyBiYWQuXG4gICAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJyB8fCBlLmNvZGUgPT09ICdFQUNDRVMnIHx8IGUuY29kZSA9PT0gJ0VST0ZTJykgeyByZXR1cm47IH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG4iXX0=