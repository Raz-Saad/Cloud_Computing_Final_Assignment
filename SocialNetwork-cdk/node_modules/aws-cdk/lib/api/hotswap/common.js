"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportNonHotswappableResource = exports.reportNonHotswappableChange = exports.classifyChanges = exports.ClassifiedChanges = exports.lowerCaseFirstCharacter = exports.transformObjectKeys = exports.HotswappableChangeCandidate = exports.HotswapMode = exports.ICON = void 0;
exports.ICON = 'âœ¨';
var HotswapMode;
(function (HotswapMode) {
    /**
     * Will fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["FALL_BACK"] = "fall-back";
    /**
     * Will not fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["HOTSWAP_ONLY"] = "hotswap-only";
    /**
     * Will not attempt to hotswap anything and instead go straight to CloudFormation
     */
    HotswapMode["FULL_DEPLOYMENT"] = "full-deployment";
})(HotswapMode || (exports.HotswapMode = HotswapMode = {}));
/**
 * Represents a change that can be hotswapped.
 */
class HotswappableChangeCandidate {
    constructor(logicalId, oldValue, newValue, propertyUpdates) {
        this.logicalId = logicalId;
        this.oldValue = oldValue;
        this.newValue = newValue;
        this.propertyUpdates = propertyUpdates;
    }
}
exports.HotswappableChangeCandidate = HotswappableChangeCandidate;
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @param exclude The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform, exclude = {}) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        // For arrays we just pass parent's exclude object directly
        // since it makes no sense to specify different exclude options for each array element
        return val.map((input) => transformObjectKeys(input, transform, exclude));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        const childExclude = exclude[k];
        if (childExclude === true) {
            // we don't transform this object if the key is specified in exclude
            ret[transform(k)] = v;
        }
        else {
            ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
        }
    }
    return ret;
}
exports.transformObjectKeys = transformObjectKeys;
/**
 * This function lower cases the first character of the string provided.
 */
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}
exports.lowerCaseFirstCharacter = lowerCaseFirstCharacter;
class ClassifiedChanges {
    constructor(change, hotswappableProps, nonHotswappableProps) {
        this.change = change;
        this.hotswappableProps = hotswappableProps;
        this.nonHotswappableProps = nonHotswappableProps;
    }
    reportNonHotswappablePropertyChanges(ret) {
        const nonHotswappablePropNames = Object.keys(this.nonHotswappableProps);
        if (nonHotswappablePropNames.length > 0) {
            const tagOnlyChange = nonHotswappablePropNames.length === 1 && nonHotswappablePropNames[0] === 'Tags';
            reportNonHotswappableChange(ret, this.change, this.nonHotswappableProps, tagOnlyChange ? 'Tags are not hotswappable' : `resource properties '${nonHotswappablePropNames}' are not hotswappable on this resource type`);
        }
    }
    get namesOfHotswappableProps() {
        return Object.keys(this.hotswappableProps);
    }
}
exports.ClassifiedChanges = ClassifiedChanges;
function classifyChanges(xs, hotswappablePropNames) {
    const hotswappableProps = {};
    const nonHotswappableProps = {};
    for (const [name, propDiff] of Object.entries(xs.propertyUpdates)) {
        if (hotswappablePropNames.includes(name)) {
            hotswappableProps[name] = propDiff;
        }
        else {
            nonHotswappableProps[name] = propDiff;
        }
    }
    return new ClassifiedChanges(xs, hotswappableProps, nonHotswappableProps);
}
exports.classifyChanges = classifyChanges;
function reportNonHotswappableChange(ret, change, nonHotswappableProps, reason, hotswapOnlyVisible) {
    let hotswapOnlyVisibility = true;
    if (hotswapOnlyVisible === false) {
        hotswapOnlyVisibility = false;
    }
    ret.push({
        hotswappable: false,
        rejectedChanges: Object.keys(nonHotswappableProps ?? change.propertyUpdates),
        logicalId: change.logicalId,
        resourceType: change.newValue.Type,
        reason,
        hotswapOnlyVisible: hotswapOnlyVisibility,
    });
}
exports.reportNonHotswappableChange = reportNonHotswappableChange;
function reportNonHotswappableResource(change, reason) {
    return [{
            hotswappable: false,
            rejectedChanges: Object.keys(change.propertyUpdates),
            logicalId: change.logicalId,
            resourceType: change.newValue.Type,
            reason,
        }];
}
exports.reportNonHotswappableResource = reportNonHotswappableResource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdhLFFBQUEsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQThDeEIsSUFBWSxXQWVYO0FBZkQsV0FBWSxXQUFXO0lBQ3JCOztPQUVHO0lBQ0gsc0NBQXVCLENBQUE7SUFFdkI7O09BRUc7SUFDSCw0Q0FBNkIsQ0FBQTtJQUU3Qjs7T0FFRztJQUNILGtEQUFtQyxDQUFBO0FBQ3JDLENBQUMsRUFmVyxXQUFXLDJCQUFYLFdBQVcsUUFldEI7QUFFRDs7R0FFRztBQUNILE1BQWEsMkJBQTJCO0lBcUJ0QyxZQUFtQixTQUFpQixFQUFFLFFBQTJCLEVBQUUsUUFBMkIsRUFBRSxlQUEwQjtRQUN4SCxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0NBQ0Y7QUEzQkQsa0VBMkJDO0FBSUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLG1CQUFtQixDQUFDLEdBQVEsRUFBRSxTQUFrQyxFQUFFLFVBQW1CLEVBQUU7SUFDckcsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQzNDLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3ZCLDJEQUEyRDtRQUMzRCxzRkFBc0Y7UUFDdEYsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBVSxFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDakYsQ0FBQztJQUNE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QWdCLDJCQUEyQixDQUN6QyxHQUF3QixFQUN4QixNQUFtQyxFQUNuQyxvQkFBZ0MsRUFDaEMsTUFBZSxFQUNmLGtCQUE0QjtJQUU1QixJQUFJLHFCQUFxQixHQUFHLElBQUksQ0FBQztJQUNqQyxJQUFJLGtCQUFrQixLQUFLLEtBQUssRUFBRSxDQUFDO1FBQ2pDLHFCQUFxQixHQUFHLEtBQUssQ0FBQztJQUNoQyxDQUFDO0lBQ0QsR0FBRyxDQUFDLElBQUksQ0FBQztRQUNQLFlBQVksRUFBRSxLQUFLO1FBQ25CLGVBQWUsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixJQUFJLE1BQU0sQ0FBQyxlQUFlLENBQUM7UUFDNUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTO1FBQzNCLFlBQVksRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUk7UUFDbEMsTUFBTTtRQUNOLGtCQUFrQixFQUFFLHFCQUFxQjtLQUMxQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBbkJELGtFQW1CQztBQUVELFNBQWdCLDZCQUE2QixDQUMzQyxNQUFtQyxFQUNuQyxNQUFlO0lBRWYsT0FBTyxDQUFDO1lBQ04sWUFBWSxFQUFFLEtBQUs7WUFDbkIsZUFBZSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztZQUNwRCxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7WUFDM0IsWUFBWSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSTtZQUNsQyxNQUFNO1NBQ1AsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQVhELHNFQVdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2ZuX2RpZmYgZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuXG5leHBvcnQgY29uc3QgSUNPTiA9ICfinKgnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhvdHN3YXBwYWJsZUNoYW5nZSB7XG4gIHJlYWRvbmx5IGhvdHN3YXBwYWJsZTogdHJ1ZTtcbiAgcmVhZG9ubHkgcmVzb3VyY2VUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHByb3BzQ2hhbmdlZDogQXJyYXk8c3RyaW5nPjtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBzZXJ2aWNlIGJlaW5nIGhvdHN3YXBwZWQuXG4gICAqIFVzZWQgdG8gc2V0IGEgY3VzdG9tIFVzZXItQWdlbnQgZm9yIFNESyBjYWxscy5cbiAgICovXG4gIHJlYWRvbmx5IHNlcnZpY2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWVzIG9mIHRoZSByZXNvdXJjZXMgYmVpbmcgaG90c3dhcHBlZC5cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlTmFtZXM6IHN0cmluZ1tdO1xuXG4gIHJlYWRvbmx5IGFwcGx5OiAoc2RrOiBJU0RLKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vbkhvdHN3YXBwYWJsZUNoYW5nZSB7XG4gIHJlYWRvbmx5IGhvdHN3YXBwYWJsZTogZmFsc2U7XG4gIHJlYWRvbmx5IHJlc291cmNlVHlwZTogc3RyaW5nO1xuICByZWFkb25seSByZWplY3RlZENoYW5nZXM6IEFycmF5PHN0cmluZz47XG4gIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuICAvKipcbiAgICogVGVsbHMgdGhlIHVzZXIgZXhhY3RseSB3aHkgdGhpcyBjaGFuZ2Ugd2FzIGRlZW1lZCBub24taG90c3dhcHBhYmxlIGFuZCB3aGF0IGl0cyBsb2dpY2FsIElEIGlzLlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBgcmVhc29uYCB3aWxsIGJlIGF1dG9maWxsZWQgdG8gc3RhdGUgdGhhdCB0aGUgcHJvcGVydGllcyBsaXN0ZWQgaW4gYHJlamVjdGVkQ2hhbmdlc2AgYXJlIG5vdCBob3Rzd2FwcGFibGUuXG4gICAqL1xuICByZWFkb25seSByZWFzb24/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0byBzaG93IHRoaXMgY2hhbmdlIHdoZW4gbGlzdGluZyBub24taG90c3dhcHBhYmxlIGNoYW5nZXMgaW4gSE9UU1dBUF9PTkxZIG1vZGUuIERvZXMgbm90IGFmZmVjdFxuICAgKiBsaXN0aW5nIGluIEZBTExfQkFDSyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBob3Rzd2FwT25seVZpc2libGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBDaGFuZ2VIb3Rzd2FwUmVzdWx0ID0gQXJyYXk8SG90c3dhcHBhYmxlQ2hhbmdlIHwgTm9uSG90c3dhcHBhYmxlQ2hhbmdlPjtcblxuZXhwb3J0IGludGVyZmFjZSBDbGFzc2lmaWVkUmVzb3VyY2VDaGFuZ2VzIHtcbiAgaG90c3dhcHBhYmxlQ2hhbmdlczogSG90c3dhcHBhYmxlQ2hhbmdlW107XG4gIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IE5vbkhvdHN3YXBwYWJsZUNoYW5nZVtdO1xufVxuXG5leHBvcnQgZW51bSBIb3Rzd2FwTW9kZSB7XG4gIC8qKlxuICAgKiBXaWxsIGZhbGwgYmFjayB0byBDbG91ZEZvcm1hdGlvbiB3aGVuIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UgaXMgZGV0ZWN0ZWRcbiAgICovXG4gIEZBTExfQkFDSyA9ICdmYWxsLWJhY2snLFxuXG4gIC8qKlxuICAgKiBXaWxsIG5vdCBmYWxsIGJhY2sgdG8gQ2xvdWRGb3JtYXRpb24gd2hlbiBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlIGlzIGRldGVjdGVkXG4gICAqL1xuICBIT1RTV0FQX09OTFkgPSAnaG90c3dhcC1vbmx5JyxcblxuICAvKipcbiAgICogV2lsbCBub3QgYXR0ZW1wdCB0byBob3Rzd2FwIGFueXRoaW5nIGFuZCBpbnN0ZWFkIGdvIHN0cmFpZ2h0IHRvIENsb3VkRm9ybWF0aW9uXG4gICAqL1xuICBGVUxMX0RFUExPWU1FTlQgPSAnZnVsbC1kZXBsb3ltZW50Jyxcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhbmdlIHRoYXQgY2FuIGJlIGhvdHN3YXBwZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUge1xuICAvKipcbiAgICogVGhlIGxvZ2ljYWwgSUQgb2YgdGhlIHJlc291cmNlIHdoaWNoIGlzIGJlaW5nIGNoYW5nZWRcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBsb2dpY2FsSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHZhbHVlIHRoZSByZXNvdXJjZSBpcyBiZWluZyB1cGRhdGVkIGZyb21cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBvbGRWYWx1ZTogY2ZuX2RpZmYuUmVzb3VyY2U7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSB0aGUgcmVzb3VyY2UgaXMgYmVpbmcgdXBkYXRlZCB0b1xuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG5ld1ZhbHVlOiBjZm5fZGlmZi5SZXNvdXJjZTtcblxuICAvKipcbiAgICogVGhlIGNoYW5nZXMgbWFkZSB0byB0aGUgcmVzb3VyY2UgcHJvcGVydGllc1xuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHByb3BlcnR5VXBkYXRlczogUHJvcERpZmZzO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihsb2dpY2FsSWQ6IHN0cmluZywgb2xkVmFsdWU6IGNmbl9kaWZmLlJlc291cmNlLCBuZXdWYWx1ZTogY2ZuX2RpZmYuUmVzb3VyY2UsIHByb3BlcnR5VXBkYXRlczogUHJvcERpZmZzKSB7XG4gICAgdGhpcy5sb2dpY2FsSWQgPSBsb2dpY2FsSWQ7XG4gICAgdGhpcy5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgIHRoaXMubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLnByb3BlcnR5VXBkYXRlcyA9IHByb3BlcnR5VXBkYXRlcztcbiAgfVxufVxuXG50eXBlIEV4Y2x1ZGUgPSB7IFtrZXk6IHN0cmluZ106IEV4Y2x1ZGUgfCB0cnVlIH1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyYW5zZm9ybXMgYWxsIGtleXMgKHJlY3Vyc2l2ZWx5KSBpbiB0aGUgcHJvdmlkZWQgYHZhbGAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWwgVGhlIG9iamVjdCB3aG9zZSBrZXlzIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0gdHJhbnNmb3JtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBlYWNoIGtleS5cbiAqIEBwYXJhbSBleGNsdWRlIFRoZSBrZXlzIHRoYXQgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWQgYW5kIGNvcGllZCB0byBvdXRwdXQgZGlyZWN0bHlcbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyBgdmFsYCwgYnV0IHdpdGggYWxsIGtleXMgdHJhbnNmb3JtZWQgYWNjb3JkaW5nIHRvIGB0cmFuc2Zvcm1gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtT2JqZWN0S2V5cyh2YWw6IGFueSwgdHJhbnNmb3JtOiAoc3RyOiBzdHJpbmcpID0+IHN0cmluZywgZXhjbHVkZTogRXhjbHVkZSA9IHt9KTogYW55IHtcbiAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gRm9yIGFycmF5cyB3ZSBqdXN0IHBhc3MgcGFyZW50J3MgZXhjbHVkZSBvYmplY3QgZGlyZWN0bHlcbiAgICAvLyBzaW5jZSBpdCBtYWtlcyBubyBzZW5zZSB0byBzcGVjaWZ5IGRpZmZlcmVudCBleGNsdWRlIG9wdGlvbnMgZm9yIGVhY2ggYXJyYXkgZWxlbWVudFxuICAgIHJldHVybiB2YWwubWFwKChpbnB1dDogYW55KSA9PiB0cmFuc2Zvcm1PYmplY3RLZXlzKGlucHV0LCB0cmFuc2Zvcm0sIGV4Y2x1ZGUpKTtcbiAgfVxuICBjb25zdCByZXQ6IHsgW2s6IHN0cmluZ106IGFueSB9ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbCkpIHtcbiAgICBjb25zdCBjaGlsZEV4Y2x1ZGUgPSBleGNsdWRlW2tdO1xuICAgIGlmIChjaGlsZEV4Y2x1ZGUgPT09IHRydWUpIHtcbiAgICAgIC8vIHdlIGRvbid0IHRyYW5zZm9ybSB0aGlzIG9iamVjdCBpZiB0aGUga2V5IGlzIHNwZWNpZmllZCBpbiBleGNsdWRlXG4gICAgICByZXRbdHJhbnNmb3JtKGspXSA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFt0cmFuc2Zvcm0oayldID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh2LCB0cmFuc2Zvcm0sIGNoaWxkRXhjbHVkZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsb3dlciBjYXNlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3dlckNhc2VGaXJzdENoYXJhY3RlcihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIubGVuZ3RoID4gMCA/IGAke3N0clswXS50b0xvd2VyQ2FzZSgpfSR7c3RyLnNsaWNlKDEpfWAgOiBzdHI7XG59XG5cbmV4cG9ydCB0eXBlIFByb3BEaWZmcyA9IFJlY29yZDxzdHJpbmcsIGNmbl9kaWZmLlByb3BlcnR5RGlmZmVyZW5jZTxhbnk+PjtcblxuZXhwb3J0IGNsYXNzIENsYXNzaWZpZWRDaGFuZ2VzIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgaG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgbm9uSG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyxcbiAgKSB7IH1cblxuICBwdWJsaWMgcmVwb3J0Tm9uSG90c3dhcHBhYmxlUHJvcGVydHlDaGFuZ2VzKHJldDogQ2hhbmdlSG90c3dhcFJlc3VsdCk6dm9pZCB7XG4gICAgY29uc3Qgbm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5ub25Ib3Rzd2FwcGFibGVQcm9wcyk7XG4gICAgaWYgKG5vbkhvdHN3YXBwYWJsZVByb3BOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0YWdPbmx5Q2hhbmdlID0gbm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzLmxlbmd0aCA9PT0gMSAmJiBub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXNbMF0gPT09ICdUYWdzJztcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShcbiAgICAgICAgcmV0LFxuICAgICAgICB0aGlzLmNoYW5nZSxcbiAgICAgICAgdGhpcy5ub25Ib3Rzd2FwcGFibGVQcm9wcyxcbiAgICAgICAgdGFnT25seUNoYW5nZSA/ICdUYWdzIGFyZSBub3QgaG90c3dhcHBhYmxlJyA6IGByZXNvdXJjZSBwcm9wZXJ0aWVzICcke25vbkhvdHN3YXBwYWJsZVByb3BOYW1lc30nIGFyZSBub3QgaG90c3dhcHBhYmxlIG9uIHRoaXMgcmVzb3VyY2UgdHlwZWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZXNPZkhvdHN3YXBwYWJsZVByb3BzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5ob3Rzd2FwcGFibGVQcm9wcyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZ5Q2hhbmdlcyhcbiAgeHM6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgaG90c3dhcHBhYmxlUHJvcE5hbWVzOiBzdHJpbmdbXSxcbik6IENsYXNzaWZpZWRDaGFuZ2VzIHtcbiAgY29uc3QgaG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyA9IHt9O1xuICBjb25zdCBub25Ib3Rzd2FwcGFibGVQcm9wczogUHJvcERpZmZzID0ge307XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgcHJvcERpZmZdIG9mIE9iamVjdC5lbnRyaWVzKHhzLnByb3BlcnR5VXBkYXRlcykpIHtcbiAgICBpZiAoaG90c3dhcHBhYmxlUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICBob3Rzd2FwcGFibGVQcm9wc1tuYW1lXSA9IHByb3BEaWZmO1xuICAgIH0gZWxzZSB7XG4gICAgICBub25Ib3Rzd2FwcGFibGVQcm9wc1tuYW1lXSA9IHByb3BEaWZmO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQ2xhc3NpZmllZENoYW5nZXMoeHMsIGhvdHN3YXBwYWJsZVByb3BzLCBub25Ib3Rzd2FwcGFibGVQcm9wcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UoXG4gIHJldDogQ2hhbmdlSG90c3dhcFJlc3VsdCxcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIG5vbkhvdHN3YXBwYWJsZVByb3BzPzogUHJvcERpZmZzLFxuICByZWFzb24/OiBzdHJpbmcsXG4gIGhvdHN3YXBPbmx5VmlzaWJsZT86IGJvb2xlYW4sXG4pOiB2b2lkIHtcbiAgbGV0IGhvdHN3YXBPbmx5VmlzaWJpbGl0eSA9IHRydWU7XG4gIGlmIChob3Rzd2FwT25seVZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgaG90c3dhcE9ubHlWaXNpYmlsaXR5ID0gZmFsc2U7XG4gIH1cbiAgcmV0LnB1c2goe1xuICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgcmVqZWN0ZWRDaGFuZ2VzOiBPYmplY3Qua2V5cyhub25Ib3Rzd2FwcGFibGVQcm9wcyA/PyBjaGFuZ2UucHJvcGVydHlVcGRhdGVzKSxcbiAgICBsb2dpY2FsSWQ6IGNoYW5nZS5sb2dpY2FsSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICByZWFzb24sXG4gICAgaG90c3dhcE9ubHlWaXNpYmxlOiBob3Rzd2FwT25seVZpc2liaWxpdHksXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0Tm9uSG90c3dhcHBhYmxlUmVzb3VyY2UoXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICByZWFzb24/OiBzdHJpbmcsXG4pOiBDaGFuZ2VIb3Rzd2FwUmVzdWx0IHtcbiAgcmV0dXJuIFt7XG4gICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICByZWplY3RlZENoYW5nZXM6IE9iamVjdC5rZXlzKGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpLFxuICAgIGxvZ2ljYWxJZDogY2hhbmdlLmxvZ2ljYWxJZCxcbiAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZS5UeXBlLFxuICAgIHJlYXNvbixcbiAgfV07XG59XG4iXX0=