"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate) {
    // the only resource change we can evaluate here is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return [];
    }
    const ret = [];
    // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
    // it contains the image and environment variables, so seems like a safe bet for now.
    // We might revisit this decision in the future though!
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['ContainerDefinitions']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0) {
        // if there are no resources referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'No ECS services reference the changed task definition', false);
    }
    if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if something besides an ECS Service is referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter(r => r.Type !== 'AWS::ECS::Service');
        for (const taskRef of nonEcsServiceTaskDefRefs) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`);
        }
    }
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        const taskDefinitionResource = await prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change);
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: namesOfHotswappableChanges,
            service: 'ecs-service',
            resourceNames: [
                `ECS Task Definition '${await taskDefinitionResource.Family}'`,
                ...ecsServicesReferencingTaskDef.map(ecsService => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`),
            ],
            apply: async (sdk) => {
                // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
                // we need to lowercase the evaluated TaskDef from CloudFormation,
                // as the AWS SDK uses lowercase property names for these
                // The SDK requires more properties here than its worth doing explicit typing for
                // instead, just use all the old values in the diff to fill them in implicitly
                const lowercasedTaskDef = (0, common_1.transformObjectKeys)(taskDefinitionResource, common_1.lowerCaseFirstCharacter, {
                    // All the properties that take arbitrary string as keys i.e. { "string" : "string" }
                    // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                    ContainerDefinitions: {
                        DockerLabels: true,
                        FirelensConfiguration: {
                            Options: true,
                        },
                        LogConfiguration: {
                            Options: true,
                        },
                    },
                    Volumes: {
                        DockerVolumeConfiguration: {
                            DriverOpts: true,
                            Labels: true,
                        },
                    },
                });
                const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
                const taskDefRevArn = registerTaskDefResponse.taskDefinition?.taskDefinitionArn;
                // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
                const servicePerClusterUpdates = {};
                for (const ecsService of ecsServicesReferencingTaskDef) {
                    const clusterName = ecsService.serviceArn.split('/')[1];
                    const existingClusterPromises = servicePerClusterUpdates[clusterName];
                    let clusterPromises;
                    if (existingClusterPromises) {
                        clusterPromises = existingClusterPromises;
                    }
                    else {
                        clusterPromises = [];
                        servicePerClusterUpdates[clusterName] = clusterPromises;
                    }
                    // Forcing New Deployment and setting Minimum Healthy Percent to 0.
                    // As CDK HotSwap is development only, this seems the most efficient way to ensure all tasks are replaced immediately, regardless of original amount.
                    clusterPromises.push({
                        promise: sdk.ecs().updateService({
                            service: ecsService.serviceArn,
                            taskDefinition: taskDefRevArn,
                            cluster: clusterName,
                            forceNewDeployment: true,
                            deploymentConfiguration: {
                                minimumHealthyPercent: 0,
                            },
                        }).promise(),
                        ecsService: ecsService,
                    });
                }
                await Promise.all(Object.values(servicePerClusterUpdates)
                    .map(clusterUpdates => {
                    return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
                }));
                // Step 3 - wait for the service deployments triggered in Step 2 to finish
                // configure a custom Waiter
                sdk.ecs().api.waiters.deploymentCompleted = {
                    name: 'DeploymentCompleted',
                    operation: 'describeServices',
                    delay: 6,
                    maxAttempts: 100,
                    acceptors: [
                        {
                            matcher: 'pathAny',
                            argument: 'failures[].reason',
                            expected: 'MISSING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'DRAINING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'INACTIVE',
                            state: 'failure',
                        },
                        // failure if any services report a deployment with status FAILED
                        {
                            matcher: 'path',
                            argument: "length(services[].deployments[? rolloutState == 'FAILED'][]) > `0`",
                            expected: true,
                            state: 'failure',
                        },
                        // wait for all services to report only a single deployment
                        {
                            matcher: 'path',
                            argument: 'length(services[? length(deployments) > `1`]) == `0`',
                            expected: true,
                            state: 'success',
                        },
                    ],
                };
                // create a custom Waiter that uses the deploymentCompleted configuration added above
                const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentCompleted');
                // wait for all of the waiters to finish
                await Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
                    return deploymentWaiter.wait({
                        cluster: clusterName,
                        services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
                    }).promise();
                }));
            },
        });
    }
    return ret;
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
async function prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change) {
    const taskDefinitionResource = {
        ...change.oldValue.Properties,
        ContainerDefinitions: change.newValue.Properties?.ContainerDefinitions,
    };
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource?.Family);
    if (!familyNameOrArn) {
        // if the Family property has not been provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    return {
        ...await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource ?? {}),
            Family: undefined,
        }),
        Family: family,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQixxQ0FBd0s7QUFJakssS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EO0lBRTNHLHlFQUF5RTtJQUN6RSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFLENBQUM7UUFDeEQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQXdCLEVBQUUsQ0FBQztJQUVwQyxxRkFBcUY7SUFDckYscUZBQXFGO0lBQ3JGLHVEQUF1RDtJQUN2RCxNQUFNLGlCQUFpQixHQUFHLElBQUEsd0JBQWUsRUFBQyxNQUFNLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7SUFDNUUsaUJBQWlCLENBQUMsb0NBQW9DLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFNUQsdUVBQXVFO0lBQ3ZFLE1BQU0sMkJBQTJCLEdBQUcsbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEYsTUFBTSxxQ0FBcUMsR0FBRywyQkFBMkIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLG1CQUFtQixDQUFDLENBQUM7SUFDdEgsTUFBTSw2QkFBNkIsR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO0lBQzlELEtBQUssTUFBTSxrQkFBa0IsSUFBSSxxQ0FBcUMsRUFBRSxDQUFDO1FBQ3ZFLE1BQU0sVUFBVSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0YsSUFBSSxVQUFVLEVBQUUsQ0FBQztZQUNmLDZCQUE2QixDQUFDLElBQUksQ0FBQyxFQUFFLFVBQVUsRUFBRSxDQUFD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QUFDLENBQUM7UUFDdkMsZ0dBQWdHO1FBQ2hHLENBQUMsQ0FBQyxlQUFlLENBQUM7SUFDcEIsOEZBQThGO0lBQzlGLE9BQU87UUFDTCxHQUFHLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUM7WUFDakQsR0FBRyxDQUFDLHNCQUFzQixJQUFJLEVBQUUsQ0FBQztZQUNqQyxNQUFNLEVBQUUsU0FBUztTQUNsQixDQUFDO1FBQ0YsTUFBTSxFQUFFLE1BQU07S0FDZixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IENoYW5nZUhvdHN3YXBSZXN1bHQsIGNsYXNzaWZ5Q2hhbmdlcywgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBsb3dlckNhc2VGaXJzdENoYXJhY3RlciwgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlLCB0cmFuc2Zvcm1PYmplY3RLZXlzIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4uL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgLy8gdGhlIG9ubHkgcmVzb3VyY2UgY2hhbmdlIHdlIGNhbiBldmFsdWF0ZSBoZXJlIGlzIGFuIEVDUyBUYXNrRGVmaW5pdGlvblxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09ICdBV1M6OkVDUzo6VGFza0RlZmluaXRpb24nKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcmV0OiBDaGFuZ2VIb3Rzd2FwUmVzdWx0ID0gW107XG5cbiAgLy8gV2Ugb25seSBhbGxvdyBhIGNoYW5nZSBpbiB0aGUgQ29udGFpbmVyRGVmaW5pdGlvbnMgb2YgdGhlIFRhc2tEZWZpbml0aW9uIGZvciBub3cgLVxuICAvLyBpdCBjb250YWlucyB0aGUgaW1hZ2UgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcywgc28gc2VlbXMgbGlrZSBhIHNhZmUgYmV0IGZvciBub3cuXG4gIC8vIFdlIG1pZ2h0IHJldmlzaXQgdGhpcyBkZWNpc2lvbiBpbiB0aGUgZnV0dXJlIHRob3VnaCFcbiAgY29uc3QgY2xhc3NpZmllZENoYW5nZXMgPSBjbGFzc2lmeUNoYW5nZXMoY2hhbmdlLCBbJ0NvbnRhaW5lckRlZmluaXRpb25zJ10pO1xuICBjbGFzc2lmaWVkQ2hhbmdlcy5yZXBvcnROb25Ib3Rzd2FwcGFibGVQcm9wZXJ0eUNoYW5nZXMocmV0KTtcblxuICAvLyBmaW5kIGFsbCBFQ1MgU2VydmljZXMgdGhhdCByZWZlcmVuY2UgdGhlIFRhc2tEZWZpbml0aW9uIHRoYXQgY2hhbmdlZFxuICBjb25zdCByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRSZWZlcmVuY2VzVG8obG9naWNhbElkKTtcbiAgY29uc3QgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZi5maWx0ZXIociA9PiByLlR5cGUgPT09ICdBV1M6OkVDUzo6U2VydmljZScpO1xuICBjb25zdCBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IG5ldyBBcnJheTxFY3NTZXJ2aWNlPigpO1xuICBmb3IgKGNvbnN0IGVjc1NlcnZpY2VSZXNvdXJjZSBvZiBlY3NTZXJ2aWNlUmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmKSB7XG4gICAgY29uc3Qgc2VydmljZUFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFBoeXNpY2FsTmFtZUZvcihlY3NTZXJ2aWNlUmVzb3VyY2UuTG9naWNhbElkKTtcbiAgICBpZiAoc2VydmljZUFybikge1xuICAgICAgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYucHVzaCh7IHNlcnZpY2VBcm4gfSk7XG4gICAgfVxuICB9XG4gIGlmIChlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGggPT09IDApIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcmVzb3VyY2VzIHJlZmVyZW5jaW5nIHRoZSBUYXNrRGVmaW5pdGlvbixcbiAgICAvLyBob3Rzd2FwIGlzIG5vdCBwb3NzaWJsZSBpbiBGQUxMX0JBQ0sgbW9kZVxuICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShyZXQsIGNoYW5nZSwgdW5kZWZpbmVkLCAnTm8gRUNTIHNlcnZpY2VzIHJlZmVyZW5jZSB0aGUgY2hhbmdlZCB0YXNrIGRlZmluaXRpb24nLCBmYWxzZSk7XG4gIH0gaWYgKHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGggPiBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGgpIHtcbiAgICAvLyBpZiBzb21ldGhpbmcgYmVzaWRlcyBhbiBFQ1MgU2VydmljZSBpcyByZWZlcmVuY2luZyB0aGUgVGFza0RlZmluaXRpb24sXG4gICAgLy8gaG90c3dhcCBpcyBub3QgcG9zc2libGUgaW4gRkFMTF9CQUNLIG1vZGVcbiAgICBjb25zdCBub25FY3NTZXJ2aWNlVGFza0RlZlJlZnMgPSByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYuZmlsdGVyKHIgPT4gci5UeXBlICE9PSAnQVdTOjpFQ1M6OlNlcnZpY2UnKTtcbiAgICBmb3IgKGNvbnN0IHRhc2tSZWYgb2Ygbm9uRWNzU2VydmljZVRhc2tEZWZSZWZzKSB7XG4gICAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UocmV0LCBjaGFuZ2UsIHVuZGVmaW5lZCwgYEEgcmVzb3VyY2UgJyR7dGFza1JlZi5Mb2dpY2FsSWR9JyB3aXRoIFR5cGUgJyR7dGFza1JlZi5UeXBlfScgdGhhdCBpcyBub3QgYW4gRUNTIFNlcnZpY2Ugd2FzIGZvdW5kIHJlZmVyZW5jaW5nIHRoZSBjaGFuZ2VkIFRhc2tEZWZpbml0aW9uICcke2xvZ2ljYWxJZH0nYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMgPSBPYmplY3Qua2V5cyhjbGFzc2lmaWVkQ2hhbmdlcy5ob3Rzd2FwcGFibGVQcm9wcyk7XG4gIGlmIChuYW1lc09mSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdGFza0RlZmluaXRpb25SZXNvdXJjZSA9IGF3YWl0IHByZXBhcmVUYXNrRGVmaW5pdGlvbkNoYW5nZShldmFsdWF0ZUNmblRlbXBsYXRlLCBsb2dpY2FsSWQsIGNoYW5nZSk7XG4gICAgcmV0LnB1c2goe1xuICAgICAgaG90c3dhcHBhYmxlOiB0cnVlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICAgIHByb3BzQ2hhbmdlZDogbmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMsXG4gICAgICBzZXJ2aWNlOiAnZWNzLXNlcnZpY2UnLFxuICAgICAgcmVzb3VyY2VOYW1lczogW1xuICAgICAgICBgRUNTIFRhc2sgRGVmaW5pdGlvbiAnJHthd2FpdCB0YXNrRGVmaW5pdGlvblJlc291cmNlLkZhbWlseX0nYCxcbiAgICAgICAgLi4uZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubWFwKGVjc1NlcnZpY2UgPT4gYEVDUyBTZXJ2aWNlICcke2Vjc1NlcnZpY2Uuc2VydmljZUFybi5zcGxpdCgnLycpWzJdfSdgKSxcbiAgICAgIF0sXG4gICAgICBhcHBseTogYXN5bmMgKHNkazogSVNESykgPT4ge1xuICAgICAgICAvLyBTdGVwIDEgLSB1cGRhdGUgdGhlIGNoYW5nZWQgVGFza0RlZmluaXRpb24sIGNyZWF0aW5nIGEgbmV3IFRhc2tEZWZpbml0aW9uIFJldmlzaW9uXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gbG93ZXJjYXNlIHRoZSBldmFsdWF0ZWQgVGFza0RlZiBmcm9tIENsb3VkRm9ybWF0aW9uLFxuICAgICAgICAvLyBhcyB0aGUgQVdTIFNESyB1c2VzIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyBmb3IgdGhlc2VcblxuICAgICAgICAvLyBUaGUgU0RLIHJlcXVpcmVzIG1vcmUgcHJvcGVydGllcyBoZXJlIHRoYW4gaXRzIHdvcnRoIGRvaW5nIGV4cGxpY2l0IHR5cGluZyBmb3JcbiAgICAgICAgLy8gaW5zdGVhZCwganVzdCB1c2UgYWxsIHRoZSBvbGQgdmFsdWVzIGluIHRoZSBkaWZmIHRvIGZpbGwgdGhlbSBpbiBpbXBsaWNpdGx5XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZWRUYXNrRGVmID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh0YXNrRGVmaW5pdGlvblJlc291cmNlLCBsb3dlckNhc2VGaXJzdENoYXJhY3Rlciwge1xuICAgICAgICAgIC8vIEFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHRha2UgYXJiaXRyYXJ5IHN0cmluZyBhcyBrZXlzIGkuZS4geyBcInN0cmluZ1wiIDogXCJzdHJpbmdcIiB9XG4gICAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvbkVDUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9SZWdpc3RlclRhc2tEZWZpbml0aW9uLmh0bWwjQVBJX1JlZ2lzdGVyVGFza0RlZmluaXRpb25fUmVxdWVzdFN5bnRheFxuICAgICAgICAgIENvbnRhaW5lckRlZmluaXRpb25zOiB7XG4gICAgICAgICAgICBEb2NrZXJMYWJlbHM6IHRydWUsXG4gICAgICAgICAgICBGaXJlbGVuc0NvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgT3B0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBMb2dDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgIE9wdGlvbnM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgVm9sdW1lczoge1xuICAgICAgICAgICAgRG9ja2VyVm9sdW1lQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICBEcml2ZXJPcHRzOiB0cnVlLFxuICAgICAgICAgICAgICBMYWJlbHM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWdpc3RlclRhc2tEZWZSZXNwb25zZSA9IGF3YWl0IHNkay5lY3MoKS5yZWdpc3RlclRhc2tEZWZpbml0aW9uKGxvd2VyY2FzZWRUYXNrRGVmKS5wcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHRhc2tEZWZSZXZBcm4gPSByZWdpc3RlclRhc2tEZWZSZXNwb25zZS50YXNrRGVmaW5pdGlvbj8udGFza0RlZmluaXRpb25Bcm47XG5cbiAgICAgICAgLy8gU3RlcCAyIC0gdXBkYXRlIHRoZSBzZXJ2aWNlcyB1c2luZyB0aGF0IFRhc2tEZWZpbml0aW9uIHRvIHBvaW50IHRvIHRoZSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICAgICAgY29uc3Qgc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzOiB7IFtjbHVzdGVyOiBzdHJpbmddOiBBcnJheTx7IHByb21pc2U6IFByb21pc2U8YW55PjsgZWNzU2VydmljZTogRWNzU2VydmljZSB9PiB9ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZWNzU2VydmljZSBvZiBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgICAgICAgIGNvbnN0IGNsdXN0ZXJOYW1lID0gZWNzU2VydmljZS5zZXJ2aWNlQXJuLnNwbGl0KCcvJylbMV07XG5cbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NsdXN0ZXJQcm9taXNlcyA9IHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlc1tjbHVzdGVyTmFtZV07XG4gICAgICAgICAgbGV0IGNsdXN0ZXJQcm9taXNlczogQXJyYXk8eyBwcm9taXNlOiBQcm9taXNlPGFueT47IGVjc1NlcnZpY2U6IEVjc1NlcnZpY2UgfT47XG4gICAgICAgICAgaWYgKGV4aXN0aW5nQ2x1c3RlclByb21pc2VzKSB7XG4gICAgICAgICAgICBjbHVzdGVyUHJvbWlzZXMgPSBleGlzdGluZ0NsdXN0ZXJQcm9taXNlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2x1c3RlclByb21pc2VzID0gW107XG4gICAgICAgICAgICBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXNbY2x1c3Rlck5hbWVdID0gY2x1c3RlclByb21pc2VzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGb3JjaW5nIE5ldyBEZXBsb3ltZW50IGFuZCBzZXR0aW5nIE1pbmltdW0gSGVhbHRoeSBQZXJjZW50IHRvIDAuXG4gICAgICAgICAgLy8gQXMgQ0RLIEhvdFN3YXAgaXMgZGV2ZWxvcG1lbnQgb25seSwgdGhpcyBzZWVtcyB0aGUgbW9zdCBlZmZpY2llbnQgd2F5IHRvIGVuc3VyZSBhbGwgdGFza3MgYXJlIHJlcGxhY2VkIGltbWVkaWF0ZWx5LCByZWdhcmRsZXNzIG9mIG9yaWdpbmFsIGFtb3VudC5cbiAgICAgICAgICBjbHVzdGVyUHJvbWlzZXMucHVzaCh7XG4gICAgICAgICAgICBwcm9taXNlOiBzZGsuZWNzKCkudXBkYXRlU2VydmljZSh7XG4gICAgICAgICAgICAgIHNlcnZpY2U6IGVjc1NlcnZpY2Uuc2VydmljZUFybixcbiAgICAgICAgICAgICAgdGFza0RlZmluaXRpb246IHRhc2tEZWZSZXZBcm4sXG4gICAgICAgICAgICAgIGNsdXN0ZXI6IGNsdXN0ZXJOYW1lLFxuICAgICAgICAgICAgICBmb3JjZU5ld0RlcGxveW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgIGRlcGxveW1lbnRDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgbWluaW11bUhlYWx0aHlQZXJjZW50OiAwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkucHJvbWlzZSgpLFxuICAgICAgICAgICAgZWNzU2VydmljZTogZWNzU2VydmljZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlcylcbiAgICAgICAgICAubWFwKGNsdXN0ZXJVcGRhdGVzID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjbHVzdGVyVXBkYXRlcy5tYXAoc2VydmljZVVwZGF0ZSA9PiBzZXJ2aWNlVXBkYXRlLnByb21pc2UpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdGVwIDMgLSB3YWl0IGZvciB0aGUgc2VydmljZSBkZXBsb3ltZW50cyB0cmlnZ2VyZWQgaW4gU3RlcCAyIHRvIGZpbmlzaFxuICAgICAgICAvLyBjb25maWd1cmUgYSBjdXN0b20gV2FpdGVyXG4gICAgICAgIChzZGsuZWNzKCkgYXMgYW55KS5hcGkud2FpdGVycy5kZXBsb3ltZW50Q29tcGxldGVkID0ge1xuICAgICAgICAgIG5hbWU6ICdEZXBsb3ltZW50Q29tcGxldGVkJyxcbiAgICAgICAgICBvcGVyYXRpb246ICdkZXNjcmliZVNlcnZpY2VzJyxcbiAgICAgICAgICBkZWxheTogNixcbiAgICAgICAgICBtYXhBdHRlbXB0czogMTAwLFxuICAgICAgICAgIGFjY2VwdG9yczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgICAgIGFyZ3VtZW50OiAnZmFpbHVyZXNbXS5yZWFzb24nLFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ01JU1NJTkcnLFxuICAgICAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGhBbnknLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ3NlcnZpY2VzW10uc3RhdHVzJyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdEUkFJTklORycsXG4gICAgICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgICAgIGFyZ3VtZW50OiAnc2VydmljZXNbXS5zdGF0dXMnLFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ0lOQUNUSVZFJyxcbiAgICAgICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGZhaWx1cmUgaWYgYW55IHNlcnZpY2VzIHJlcG9ydCBhIGRlcGxveW1lbnQgd2l0aCBzdGF0dXMgRkFJTEVEXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hdGNoZXI6ICdwYXRoJyxcbiAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibGVuZ3RoKHNlcnZpY2VzW10uZGVwbG95bWVudHNbPyByb2xsb3V0U3RhdGUgPT0gJ0ZBSUxFRCddW10pID4gYDBgXCIsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgYWxsIHNlcnZpY2VzIHRvIHJlcG9ydCBvbmx5IGEgc2luZ2xlIGRlcGxveW1lbnRcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGgnLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ2xlbmd0aChzZXJ2aWNlc1s/IGxlbmd0aChkZXBsb3ltZW50cykgPiBgMWBdKSA9PSBgMGAnLFxuICAgICAgICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhdGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3JlYXRlIGEgY3VzdG9tIFdhaXRlciB0aGF0IHVzZXMgdGhlIGRlcGxveW1lbnRDb21wbGV0ZWQgY29uZmlndXJhdGlvbiBhZGRlZCBhYm92ZVxuICAgICAgICBjb25zdCBkZXBsb3ltZW50V2FpdGVyID0gbmV3IChBV1MgYXMgYW55KS5SZXNvdXJjZVdhaXRlcihzZGsuZWNzKCksICdkZXBsb3ltZW50Q29tcGxldGVkJyk7XG4gICAgICAgIC8vIHdhaXQgZm9yIGFsbCBvZiB0aGUgd2FpdGVycyB0byBmaW5pc2hcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMoc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzKS5tYXAoKFtjbHVzdGVyTmFtZSwgc2VydmljZVVwZGF0ZXNdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGRlcGxveW1lbnRXYWl0ZXIud2FpdCh7XG4gICAgICAgICAgICBjbHVzdGVyOiBjbHVzdGVyTmFtZSxcbiAgICAgICAgICAgIHNlcnZpY2VzOiBzZXJ2aWNlVXBkYXRlcy5tYXAoc2VydmljZVVwZGF0ZSA9PiBzZXJ2aWNlVXBkYXRlLmVjc1NlcnZpY2Uuc2VydmljZUFybiksXG4gICAgICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuaW50ZXJmYWNlIEVjc1NlcnZpY2Uge1xuICByZWFkb25seSBzZXJ2aWNlQXJuOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVUYXNrRGVmaW5pdGlvbkNoYW5nZShcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLCBsb2dpY2FsSWQ6IHN0cmluZywgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4pIHtcbiAgY29uc3QgdGFza0RlZmluaXRpb25SZXNvdXJjZTogeyBbbmFtZTogc3RyaW5nXTogYW55IH0gPSB7XG4gICAgLi4uY2hhbmdlLm9sZFZhbHVlLlByb3BlcnRpZXMsXG4gICAgQ29udGFpbmVyRGVmaW5pdGlvbnM6IGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzPy5Db250YWluZXJEZWZpbml0aW9ucyxcbiAgfTtcbiAgLy8gZmlyc3QsIGxldCdzIGdldCB0aGUgbmFtZSBvZiB0aGUgZmFtaWx5XG4gIGNvbnN0IGZhbWlseU5hbWVPckFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUobG9naWNhbElkLCB0YXNrRGVmaW5pdGlvblJlc291cmNlPy5GYW1pbHkpO1xuICBpZiAoIWZhbWlseU5hbWVPckFybikge1xuICAgIC8vIGlmIHRoZSBGYW1pbHkgcHJvcGVydHkgaGFzIG5vdCBiZWVuIHByb3ZpZGVkLCBhbmQgd2UgY2FuJ3QgZmluZCBpdCBpbiB0aGUgY3VycmVudCBTdGFjayxcbiAgICAvLyB0aGlzIG1lYW5zIGhvdHN3YXBwaW5nIGlzIG5vdCBwb3NzaWJsZVxuICAgIHJldHVybjtcbiAgfVxuICAvLyB0aGUgcGh5c2ljYWwgbmFtZSBvZiB0aGUgVGFzayBEZWZpbml0aW9uIGluIENsb3VkRm9ybWF0aW9uIGluY2x1ZGVzIGl0cyBjdXJyZW50IHJldmlzaW9uIG51bWJlciBhdCB0aGUgZW5kLFxuICAvLyByZW1vdmUgaXQgaWYgbmVlZGVkXG4gIGNvbnN0IGZhbWlseU5hbWVPckFyblBhcnRzID0gZmFtaWx5TmFtZU9yQXJuLnNwbGl0KCc6Jyk7XG4gIGNvbnN0IGZhbWlseSA9IGZhbWlseU5hbWVPckFyblBhcnRzLmxlbmd0aCA+IDFcbiAgICAvLyBmYW1pbHlOYW1lT3JBcm4gaXMgYWN0dWFsbHkgYW4gQVJOLCBvZiB0aGUgZm9ybWF0ICdhcm46YXdzOmVjczpyZWdpb246YWNjb3VudDp0YXNrLWRlZmluaXRpb24vPGZhbWlseS1uYW1lPjo8cmV2aXNpb24tbnI+J1xuICAgIC8vIHNvLCB0YWtlIHRoZSA2dGggZWxlbWVudCwgYXQgaW5kZXggNSwgYW5kIHNwbGl0IGl0IG9uICcvJ1xuICAgID8gZmFtaWx5TmFtZU9yQXJuUGFydHNbNV0uc3BsaXQoJy8nKVsxXVxuICAgIC8vIG90aGVyd2lzZSwgZmFtaWx5TmFtZU9yQXJuIGlzIGp1c3QgdGhlIHNpbXBsZSBuYW1lIGV2YWx1YXRlZCBmcm9tIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZVxuICAgIDogZmFtaWx5TmFtZU9yQXJuO1xuICAvLyB0aGVuLCBsZXQncyBldmFsdWF0ZSB0aGUgYm9keSBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBUYXNrRGVmICh3aXRob3V0IHRoZSBGYW1pbHkgcHJvcGVydHkpXG4gIHJldHVybiB7XG4gICAgLi4uYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oe1xuICAgICAgLi4uKHRhc2tEZWZpbml0aW9uUmVzb3VyY2UgPz8ge30pLFxuICAgICAgRmFtaWx5OiB1bmRlZmluZWQsXG4gICAgfSksXG4gICAgRmFtaWx5OiBmYW1pbHksXG4gIH07XG59XG4iXX0=