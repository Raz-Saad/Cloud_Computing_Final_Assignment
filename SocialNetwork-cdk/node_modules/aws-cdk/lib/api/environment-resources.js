"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoBootstrapStackEnvironmentResources = exports.EnvironmentResources = exports.EnvironmentResourcesRegistry = void 0;
const toolkit_info_1 = require("./toolkit-info");
const logging_1 = require("../logging");
/**
 * Registry class for `EnvironmentResources`.
 *
 * The state management of this class is a bit non-standard. We want to cache
 * data related to toolkit stacks and SSM parameters, but we are not in charge
 * of ensuring caching of SDKs. Since `EnvironmentResources` needs an SDK to
 * function, we treat it as an ephemeral class, and store the actual cached data
 * in `EnvironmentResourcesRegistry`.
 */
class EnvironmentResourcesRegistry {
    constructor(toolkitStackName) {
        this.toolkitStackName = toolkitStackName;
        this.cache = new Map();
    }
    for(resolvedEnvironment, sdk) {
        const key = `${resolvedEnvironment.account}:${resolvedEnvironment.region}`;
        let envCache = this.cache.get(key);
        if (!envCache) {
            envCache = emptyCache();
            this.cache.set(key, envCache);
        }
        return new EnvironmentResources(resolvedEnvironment, sdk, envCache, this.toolkitStackName);
    }
}
exports.EnvironmentResourcesRegistry = EnvironmentResourcesRegistry;
/**
 * Interface with the account and region we're deploying into
 *
 * Manages lookups for bootstrapped resources, falling back to the legacy "CDK Toolkit"
 * original bootstrap stack if necessary.
 *
 * The state management of this class is a bit non-standard. We want to cache
 * data related to toolkit stacks and SSM parameters, but we are not in charge
 * of ensuring caching of SDKs. Since `EnvironmentResources` needs an SDK to
 * function, we treat it as an ephemeral class, and store the actual cached data
 * in `EnvironmentResourcesRegistry`.
 */
class EnvironmentResources {
    constructor(environment, sdk, cache, toolkitStackName) {
        this.environment = environment;
        this.sdk = sdk;
        this.cache = cache;
        this.toolkitStackName = toolkitStackName;
    }
    /**
     * Look up the toolkit for a given environment, using a given SDK
     */
    async lookupToolkit() {
        if (!this.cache.toolkitInfo) {
            this.cache.toolkitInfo = await toolkit_info_1.ToolkitInfo.lookup(this.environment, this.sdk, this.toolkitStackName);
        }
        return this.cache.toolkitInfo;
    }
    /**
     * Validate that the bootstrap stack version matches or exceeds the expected version
     *
     * Use the SSM parameter name to read the version number if given, otherwise use the version
     * discovered on the bootstrap stack.
     *
     * Pass in the SSM parameter name so we can cache the lookups an don't need to do the same
     * lookup again and again for every artifact.
     */
    async validateVersion(expectedVersion, ssmParameterName) {
        if (expectedVersion === undefined) {
            // No requirement
            return;
        }
        const defExpectedVersion = expectedVersion;
        if (ssmParameterName !== undefined) {
            try {
                doValidate(await this.versionFromSsmParameter(ssmParameterName));
                return;
            }
            catch (e) {
                if (e.code !== 'AccessDeniedException') {
                    throw e;
                }
                // This is a fallback! The bootstrap template that goes along with this change introduces
                // a new 'ssm:GetParameter' permission, but when run using the previous bootstrap template we
                // won't have the permissions yet to read the version, so we won't be able to show the
                // message telling the user they need to update! When we see an AccessDeniedException, fall
                // back to the version we read from Stack Outputs; but ONLY if the version we discovered via
                // outputs is legitimately an old version. If it's newer than that, something else must be broken,
                // so let it fail as it would if we didn't have this fallback.
                const bootstrapStack = await this.lookupToolkit();
                if (bootstrapStack.found && bootstrapStack.version < BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER) {
                    (0, logging_1.warning)(`Could not read SSM parameter ${ssmParameterName}: ${e.message}, falling back to version from ${bootstrapStack}`);
                    doValidate(bootstrapStack.version);
                    return;
                }
                throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', but during the confirmation via SSM parameter ${ssmParameterName} the following error occurred: ${e}`);
            }
        }
        // No SSM parameter
        const bootstrapStack = await this.lookupToolkit();
        doValidate(bootstrapStack.version);
        function doValidate(version) {
            if (defExpectedVersion > version) {
                throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`);
            }
        }
    }
    /**
     * Read a version from an SSM parameter, cached
     */
    async versionFromSsmParameter(parameterName) {
        const existing = this.cache.ssmParameters.get(parameterName);
        if (existing !== undefined) {
            return existing;
        }
        const ssm = this.sdk.ssm();
        try {
            const result = await ssm.getParameter({ Name: parameterName }).promise();
            const asNumber = parseInt(`${result.Parameter?.Value}`, 10);
            if (isNaN(asNumber)) {
                throw new Error(`SSM parameter ${parameterName} not a number: ${result.Parameter?.Value}`);
            }
            this.cache.ssmParameters.set(parameterName, asNumber);
            return asNumber;
        }
        catch (e) {
            if (e.code === 'ParameterNotFound') {
                throw new Error(`SSM parameter ${parameterName} not found. Has the environment been bootstrapped? Please run \'cdk bootstrap\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`);
            }
            throw e;
        }
    }
    async prepareEcrRepository(repositoryName) {
        if (!this.sdk) {
            throw new Error('ToolkitInfo needs to have been initialized with an sdk to call prepareEcrRepository');
        }
        const ecr = this.sdk.ecr();
        // check if repo already exists
        try {
            (0, logging_1.debug)(`${repositoryName}: checking if ECR repository already exists`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            const existingRepositoryUri = describeResponse.repositories[0]?.repositoryUri;
            if (existingRepositoryUri) {
                return { repositoryUri: existingRepositoryUri };
            }
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        // create the repo (tag it so it will be easier to garbage collect in the future)
        (0, logging_1.debug)(`${repositoryName}: creating ECR repository`);
        const assetTag = { Key: 'awscdk:asset', Value: 'true' };
        const response = await ecr.createRepository({ repositoryName, tags: [assetTag] }).promise();
        const repositoryUri = response.repository?.repositoryUri;
        if (!repositoryUri) {
            throw new Error(`CreateRepository did not return a repository URI for ${repositoryUri}`);
        }
        // configure image scanning on push (helps in identifying software vulnerabilities, no additional charge)
        (0, logging_1.debug)(`${repositoryName}: enable image scanning`);
        await ecr.putImageScanningConfiguration({ repositoryName, imageScanningConfiguration: { scanOnPush: true } }).promise();
        return { repositoryUri };
    }
}
exports.EnvironmentResources = EnvironmentResources;
class NoBootstrapStackEnvironmentResources extends EnvironmentResources {
    constructor(environment, sdk) {
        super(environment, sdk, emptyCache());
    }
    /**
     * Look up the toolkit for a given environment, using a given SDK
     */
    async lookupToolkit() {
        throw new Error('Trying to perform an operation that requires a bootstrap stack; you should not see this error, this is a bug in the CDK CLI.');
    }
}
exports.NoBootstrapStackEnvironmentResources = NoBootstrapStackEnvironmentResources;
function emptyCache() {
    return {
        ssmParameters: new Map(),
        toolkitInfo: undefined,
    };
}
/**
 * The bootstrap template version that introduced ssm:GetParameter
 */
const BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER = 5;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW52aXJvbm1lbnQtcmVzb3VyY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZW52aXJvbm1lbnQtcmVzb3VyY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLGlEQUFnRTtBQUNoRSx3Q0FBNEM7QUFFNUM7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFhLDRCQUE0QjtJQUd2QyxZQUE2QixnQkFBeUI7UUFBekIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFTO1FBRnJDLFVBQUssR0FBRyxJQUFJLEdBQUcsRUFBNEIsQ0FBQztJQUc3RCxDQUFDO0lBRU0sR0FBRyxDQUFDLG1CQUFzQyxFQUFFLEdBQVM7UUFDMUQsTUFBTSxHQUFHLEdBQUcsR0FBRyxtQkFBbUIsQ0FBQyxPQUFPLElBQUksbUJBQW1CLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDM0UsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2QsUUFBUSxHQUFHLFVBQVUsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNoQyxDQUFDO1FBQ0QsT0FBTyxJQUFJLG9CQUFvQixDQUFDLG1CQUFtQixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDN0YsQ0FBQztDQUNGO0FBZkQsb0VBZUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQWEsb0JBQW9CO0lBQy9CLFlBQ2tCLFdBQThCLEVBQzdCLEdBQVMsRUFDVCxLQUF1QixFQUN2QixnQkFBeUI7UUFIMUIsZ0JBQVcsR0FBWCxXQUFXLENBQW1CO1FBQzdCLFFBQUcsR0FBSCxHQUFHLENBQU07UUFDVCxVQUFLLEdBQUwsS0FBSyxDQUFrQjtRQUN2QixxQkFBZ0IsR0FBaEIsZ0JBQWdC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RSxZQUFZLFdBQThCLEVBQUUsR0FBUztRQUNuRCxLQUFLLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxhQUFhO1FBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsOEhBQThILENBQUMsQ0FBQztJQUNsSixDQUFDO0NBQ0Y7QUFYRCxvRkFXQztBQVlELFNBQVMsVUFBVTtJQUNqQixPQUFPO1FBQ0wsYUFBYSxFQUFFLElBQUksR0FBRyxFQUFFO1FBQ3hCLFdBQVcsRUFBRSxTQUFTO0tBQ3ZCLENBQUM7QUFDSixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLG1EQUFtRCxHQUFHLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBFY3JSZXBvc2l0b3J5SW5mbywgVG9vbGtpdEluZm8gfSBmcm9tICcuL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgeyBkZWJ1Zywgd2FybmluZyB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuXG4vKipcbiAqIFJlZ2lzdHJ5IGNsYXNzIGZvciBgRW52aXJvbm1lbnRSZXNvdXJjZXNgLlxuICpcbiAqIFRoZSBzdGF0ZSBtYW5hZ2VtZW50IG9mIHRoaXMgY2xhc3MgaXMgYSBiaXQgbm9uLXN0YW5kYXJkLiBXZSB3YW50IHRvIGNhY2hlXG4gKiBkYXRhIHJlbGF0ZWQgdG8gdG9vbGtpdCBzdGFja3MgYW5kIFNTTSBwYXJhbWV0ZXJzLCBidXQgd2UgYXJlIG5vdCBpbiBjaGFyZ2VcbiAqIG9mIGVuc3VyaW5nIGNhY2hpbmcgb2YgU0RLcy4gU2luY2UgYEVudmlyb25tZW50UmVzb3VyY2VzYCBuZWVkcyBhbiBTREsgdG9cbiAqIGZ1bmN0aW9uLCB3ZSB0cmVhdCBpdCBhcyBhbiBlcGhlbWVyYWwgY2xhc3MsIGFuZCBzdG9yZSB0aGUgYWN0dWFsIGNhY2hlZCBkYXRhXG4gKiBpbiBgRW52aXJvbm1lbnRSZXNvdXJjZXNSZWdpc3RyeWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnZpcm9ubWVudFJlc291cmNlc1JlZ2lzdHJ5IHtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBFbnZpcm9ubWVudENhY2hlPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZykge1xuICB9XG5cbiAgcHVibGljIGZvcihyZXNvbHZlZEVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgc2RrOiBJU0RLKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7cmVzb2x2ZWRFbnZpcm9ubWVudC5hY2NvdW50fToke3Jlc29sdmVkRW52aXJvbm1lbnQucmVnaW9ufWA7XG4gICAgbGV0IGVudkNhY2hlID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIWVudkNhY2hlKSB7XG4gICAgICBlbnZDYWNoZSA9IGVtcHR5Q2FjaGUoKTtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgZW52Q2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVudmlyb25tZW50UmVzb3VyY2VzKHJlc29sdmVkRW52aXJvbm1lbnQsIHNkaywgZW52Q2FjaGUsIHRoaXMudG9vbGtpdFN0YWNrTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2Ugd2l0aCB0aGUgYWNjb3VudCBhbmQgcmVnaW9uIHdlJ3JlIGRlcGxveWluZyBpbnRvXG4gKlxuICogTWFuYWdlcyBsb29rdXBzIGZvciBib290c3RyYXBwZWQgcmVzb3VyY2VzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxlZ2FjeSBcIkNESyBUb29sa2l0XCJcbiAqIG9yaWdpbmFsIGJvb3RzdHJhcCBzdGFjayBpZiBuZWNlc3NhcnkuXG4gKlxuICogVGhlIHN0YXRlIG1hbmFnZW1lbnQgb2YgdGhpcyBjbGFzcyBpcyBhIGJpdCBub24tc3RhbmRhcmQuIFdlIHdhbnQgdG8gY2FjaGVcbiAqIGRhdGEgcmVsYXRlZCB0byB0b29sa2l0IHN0YWNrcyBhbmQgU1NNIHBhcmFtZXRlcnMsIGJ1dCB3ZSBhcmUgbm90IGluIGNoYXJnZVxuICogb2YgZW5zdXJpbmcgY2FjaGluZyBvZiBTREtzLiBTaW5jZSBgRW52aXJvbm1lbnRSZXNvdXJjZXNgIG5lZWRzIGFuIFNESyB0b1xuICogZnVuY3Rpb24sIHdlIHRyZWF0IGl0IGFzIGFuIGVwaGVtZXJhbCBjbGFzcywgYW5kIHN0b3JlIHRoZSBhY3R1YWwgY2FjaGVkIGRhdGFcbiAqIGluIGBFbnZpcm9ubWVudFJlc291cmNlc1JlZ2lzdHJ5YC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVudmlyb25tZW50UmVzb3VyY2VzIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNkazogSVNESyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlOiBFbnZpcm9ubWVudENhY2hlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZyxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIHRoZSB0b29sa2l0IGZvciBhIGdpdmVuIGVudmlyb25tZW50LCB1c2luZyBhIGdpdmVuIFNES1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGxvb2t1cFRvb2xraXQoKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlLnRvb2xraXRJbmZvKSB7XG4gICAgICB0aGlzLmNhY2hlLnRvb2xraXRJbmZvID0gYXdhaXQgVG9vbGtpdEluZm8ubG9va3VwKHRoaXMuZW52aXJvbm1lbnQsIHRoaXMuc2RrLCB0aGlzLnRvb2xraXRTdGFja05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZS50b29sa2l0SW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGF0IHRoZSBib290c3RyYXAgc3RhY2sgdmVyc2lvbiBtYXRjaGVzIG9yIGV4Y2VlZHMgdGhlIGV4cGVjdGVkIHZlcnNpb25cbiAgICpcbiAgICogVXNlIHRoZSBTU00gcGFyYW1ldGVyIG5hbWUgdG8gcmVhZCB0aGUgdmVyc2lvbiBudW1iZXIgaWYgZ2l2ZW4sIG90aGVyd2lzZSB1c2UgdGhlIHZlcnNpb25cbiAgICogZGlzY292ZXJlZCBvbiB0aGUgYm9vdHN0cmFwIHN0YWNrLlxuICAgKlxuICAgKiBQYXNzIGluIHRoZSBTU00gcGFyYW1ldGVyIG5hbWUgc28gd2UgY2FuIGNhY2hlIHRoZSBsb29rdXBzIGFuIGRvbid0IG5lZWQgdG8gZG8gdGhlIHNhbWVcbiAgICogbG9va3VwIGFnYWluIGFuZCBhZ2FpbiBmb3IgZXZlcnkgYXJ0aWZhY3QuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdmFsaWRhdGVWZXJzaW9uKGV4cGVjdGVkVmVyc2lvbjogbnVtYmVyIHwgdW5kZWZpbmVkLCBzc21QYXJhbWV0ZXJOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoZXhwZWN0ZWRWZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE5vIHJlcXVpcmVtZW50XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlZkV4cGVjdGVkVmVyc2lvbiA9IGV4cGVjdGVkVmVyc2lvbjtcblxuICAgIGlmIChzc21QYXJhbWV0ZXJOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvVmFsaWRhdGUoYXdhaXQgdGhpcy52ZXJzaW9uRnJvbVNzbVBhcmFtZXRlcihzc21QYXJhbWV0ZXJOYW1lKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBpZiAoZS5jb2RlICE9PSAnQWNjZXNzRGVuaWVkRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGZhbGxiYWNrISBUaGUgYm9vdHN0cmFwIHRlbXBsYXRlIHRoYXQgZ29lcyBhbG9uZyB3aXRoIHRoaXMgY2hhbmdlIGludHJvZHVjZXNcbiAgICAgICAgLy8gYSBuZXcgJ3NzbTpHZXRQYXJhbWV0ZXInIHBlcm1pc3Npb24sIGJ1dCB3aGVuIHJ1biB1c2luZyB0aGUgcHJldmlvdXMgYm9vdHN0cmFwIHRlbXBsYXRlIHdlXG4gICAgICAgIC8vIHdvbid0IGhhdmUgdGhlIHBlcm1pc3Npb25zIHlldCB0byByZWFkIHRoZSB2ZXJzaW9uLCBzbyB3ZSB3b24ndCBiZSBhYmxlIHRvIHNob3cgdGhlXG4gICAgICAgIC8vIG1lc3NhZ2UgdGVsbGluZyB0aGUgdXNlciB0aGV5IG5lZWQgdG8gdXBkYXRlISBXaGVuIHdlIHNlZSBhbiBBY2Nlc3NEZW5pZWRFeGNlcHRpb24sIGZhbGxcbiAgICAgICAgLy8gYmFjayB0byB0aGUgdmVyc2lvbiB3ZSByZWFkIGZyb20gU3RhY2sgT3V0cHV0czsgYnV0IE9OTFkgaWYgdGhlIHZlcnNpb24gd2UgZGlzY292ZXJlZCB2aWFcbiAgICAgICAgLy8gb3V0cHV0cyBpcyBsZWdpdGltYXRlbHkgYW4gb2xkIHZlcnNpb24uIElmIGl0J3MgbmV3ZXIgdGhhbiB0aGF0LCBzb21ldGhpbmcgZWxzZSBtdXN0IGJlIGJyb2tlbixcbiAgICAgICAgLy8gc28gbGV0IGl0IGZhaWwgYXMgaXQgd291bGQgaWYgd2UgZGlkbid0IGhhdmUgdGhpcyBmYWxsYmFjay5cbiAgICAgICAgY29uc3QgYm9vdHN0cmFwU3RhY2sgPSBhd2FpdCB0aGlzLmxvb2t1cFRvb2xraXQoKTtcbiAgICAgICAgaWYgKGJvb3RzdHJhcFN0YWNrLmZvdW5kICYmIGJvb3RzdHJhcFN0YWNrLnZlcnNpb24gPCBCT09UU1RSQVBfVEVNUExBVEVfVkVSU0lPTl9JTlRST0RVQ0lOR19HRVRQQVJBTUVURVIpIHtcbiAgICAgICAgICB3YXJuaW5nKGBDb3VsZCBub3QgcmVhZCBTU00gcGFyYW1ldGVyICR7c3NtUGFyYW1ldGVyTmFtZX06ICR7ZS5tZXNzYWdlfSwgZmFsbGluZyBiYWNrIHRvIHZlcnNpb24gZnJvbSAke2Jvb3RzdHJhcFN0YWNrfWApO1xuICAgICAgICAgIGRvVmFsaWRhdGUoYm9vdHN0cmFwU3RhY2sudmVyc2lvbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIENESyBkZXBsb3ltZW50IHJlcXVpcmVzIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uICcke2V4cGVjdGVkVmVyc2lvbn0nLCBidXQgZHVyaW5nIHRoZSBjb25maXJtYXRpb24gdmlhIFNTTSBwYXJhbWV0ZXIgJHtzc21QYXJhbWV0ZXJOYW1lfSB0aGUgZm9sbG93aW5nIGVycm9yIG9jY3VycmVkOiAke2V9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gU1NNIHBhcmFtZXRlclxuICAgIGNvbnN0IGJvb3RzdHJhcFN0YWNrID0gYXdhaXQgdGhpcy5sb29rdXBUb29sa2l0KCk7XG4gICAgZG9WYWxpZGF0ZShib290c3RyYXBTdGFjay52ZXJzaW9uKTtcblxuICAgIGZ1bmN0aW9uIGRvVmFsaWRhdGUodmVyc2lvbjogbnVtYmVyKSB7XG4gICAgICBpZiAoZGVmRXhwZWN0ZWRWZXJzaW9uID4gdmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgQ0RLIGRlcGxveW1lbnQgcmVxdWlyZXMgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gJyR7ZXhwZWN0ZWRWZXJzaW9ufScsIGZvdW5kICcke3ZlcnNpb259Jy4gUGxlYXNlIHJ1biAnY2RrIGJvb3RzdHJhcCcuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSB2ZXJzaW9uIGZyb20gYW4gU1NNIHBhcmFtZXRlciwgY2FjaGVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdmVyc2lvbkZyb21Tc21QYXJhbWV0ZXIocGFyYW1ldGVyTmFtZTogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuY2FjaGUuc3NtUGFyYW1ldGVycy5nZXQocGFyYW1ldGVyTmFtZSk7XG4gICAgaWYgKGV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHsgcmV0dXJuIGV4aXN0aW5nOyB9XG5cbiAgICBjb25zdCBzc20gPSB0aGlzLnNkay5zc20oKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzc20uZ2V0UGFyYW1ldGVyKHsgTmFtZTogcGFyYW1ldGVyTmFtZSB9KS5wcm9taXNlKCk7XG5cbiAgICAgIGNvbnN0IGFzTnVtYmVyID0gcGFyc2VJbnQoYCR7cmVzdWx0LlBhcmFtZXRlcj8uVmFsdWV9YCwgMTApO1xuICAgICAgaWYgKGlzTmFOKGFzTnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNTTSBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJOYW1lfSBub3QgYSBudW1iZXI6ICR7cmVzdWx0LlBhcmFtZXRlcj8uVmFsdWV9YCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FjaGUuc3NtUGFyYW1ldGVycy5zZXQocGFyYW1ldGVyTmFtZSwgYXNOdW1iZXIpO1xuICAgICAgcmV0dXJuIGFzTnVtYmVyO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ1BhcmFtZXRlck5vdEZvdW5kJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNTTSBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJOYW1lfSBub3QgZm91bmQuIEhhcyB0aGUgZW52aXJvbm1lbnQgYmVlbiBib290c3RyYXBwZWQ/IFBsZWFzZSBydW4gXFwnY2RrIGJvb3RzdHJhcFxcJyAoc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jZGsvbGF0ZXN0L2d1aWRlL2Jvb3RzdHJhcHBpbmcuaHRtbClgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHByZXBhcmVFY3JSZXBvc2l0b3J5KHJlcG9zaXRvcnlOYW1lOiBzdHJpbmcpOiBQcm9taXNlPEVjclJlcG9zaXRvcnlJbmZvPiB7XG4gICAgaWYgKCF0aGlzLnNkaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sa2l0SW5mbyBuZWVkcyB0byBoYXZlIGJlZW4gaW5pdGlhbGl6ZWQgd2l0aCBhbiBzZGsgdG8gY2FsbCBwcmVwYXJlRWNyUmVwb3NpdG9yeScpO1xuICAgIH1cbiAgICBjb25zdCBlY3IgPSB0aGlzLnNkay5lY3IoKTtcblxuICAgIC8vIGNoZWNrIGlmIHJlcG8gYWxyZWFkeSBleGlzdHNcbiAgICB0cnkge1xuICAgICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBjaGVja2luZyBpZiBFQ1IgcmVwb3NpdG9yeSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgY29uc3QgZGVzY3JpYmVSZXNwb25zZSA9IGF3YWl0IGVjci5kZXNjcmliZVJlcG9zaXRvcmllcyh7IHJlcG9zaXRvcnlOYW1lczogW3JlcG9zaXRvcnlOYW1lXSB9KS5wcm9taXNlKCk7XG4gICAgICBjb25zdCBleGlzdGluZ1JlcG9zaXRvcnlVcmkgPSBkZXNjcmliZVJlc3BvbnNlLnJlcG9zaXRvcmllcyFbMF0/LnJlcG9zaXRvcnlVcmk7XG4gICAgICBpZiAoZXhpc3RpbmdSZXBvc2l0b3J5VXJpKSB7XG4gICAgICAgIHJldHVybiB7IHJlcG9zaXRvcnlVcmk6IGV4aXN0aW5nUmVwb3NpdG9yeVVyaSB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgaWYgKGUuY29kZSAhPT0gJ1JlcG9zaXRvcnlOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgcmVwbyAodGFnIGl0IHNvIGl0IHdpbGwgYmUgZWFzaWVyIHRvIGdhcmJhZ2UgY29sbGVjdCBpbiB0aGUgZnV0dXJlKVxuICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY3JlYXRpbmcgRUNSIHJlcG9zaXRvcnlgKTtcbiAgICBjb25zdCBhc3NldFRhZyA9IHsgS2V5OiAnYXdzY2RrOmFzc2V0JywgVmFsdWU6ICd0cnVlJyB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZWNyLmNyZWF0ZVJlcG9zaXRvcnkoeyByZXBvc2l0b3J5TmFtZSwgdGFnczogW2Fzc2V0VGFnXSB9KS5wcm9taXNlKCk7XG4gICAgY29uc3QgcmVwb3NpdG9yeVVyaSA9IHJlc3BvbnNlLnJlcG9zaXRvcnk/LnJlcG9zaXRvcnlVcmk7XG4gICAgaWYgKCFyZXBvc2l0b3J5VXJpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENyZWF0ZVJlcG9zaXRvcnkgZGlkIG5vdCByZXR1cm4gYSByZXBvc2l0b3J5IFVSSSBmb3IgJHtyZXBvc2l0b3J5VXJpfWApO1xuICAgIH1cblxuICAgIC8vIGNvbmZpZ3VyZSBpbWFnZSBzY2FubmluZyBvbiBwdXNoIChoZWxwcyBpbiBpZGVudGlmeWluZyBzb2Z0d2FyZSB2dWxuZXJhYmlsaXRpZXMsIG5vIGFkZGl0aW9uYWwgY2hhcmdlKVxuICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogZW5hYmxlIGltYWdlIHNjYW5uaW5nYCk7XG4gICAgYXdhaXQgZWNyLnB1dEltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uKHsgcmVwb3NpdG9yeU5hbWUsIGltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uOiB7IHNjYW5PblB1c2g6IHRydWUgfSB9KS5wcm9taXNlKCk7XG5cbiAgICByZXR1cm4geyByZXBvc2l0b3J5VXJpIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5vQm9vdHN0cmFwU3RhY2tFbnZpcm9ubWVudFJlc291cmNlcyBleHRlbmRzIEVudmlyb25tZW50UmVzb3VyY2VzIHtcbiAgY29uc3RydWN0b3IoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGs6IElTREspIHtcbiAgICBzdXBlcihlbnZpcm9ubWVudCwgc2RrLCBlbXB0eUNhY2hlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgdXAgdGhlIHRvb2xraXQgZm9yIGEgZ2l2ZW4gZW52aXJvbm1lbnQsIHVzaW5nIGEgZ2l2ZW4gU0RLXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbG9va3VwVG9vbGtpdCgpOiBQcm9taXNlPFRvb2xraXRJbmZvPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gcGVyZm9ybSBhbiBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyBhIGJvb3RzdHJhcCBzdGFjazsgeW91IHNob3VsZCBub3Qgc2VlIHRoaXMgZXJyb3IsIHRoaXMgaXMgYSBidWcgaW4gdGhlIENESyBDTEkuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIHRoYXQgaXMgY2FjaGVkIG9uIGEgcGVyLWVudmlyb25tZW50IGxldmVsXG4gKlxuICogVGhpcyBjYWNoZSBtYXkgYmUgc2hhcmVkIGJldHdlZW4gZGlmZmVyZW50IGluc3RhbmNlcyBvZiB0aGUgYEVudmlyb25tZW50UmVzb3VyY2VzYCBjbGFzcy5cbiAqL1xuaW50ZXJmYWNlIEVudmlyb25tZW50Q2FjaGUge1xuICByZWFkb25seSBzc21QYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBudW1iZXI+O1xuICB0b29sa2l0SW5mbz86IFRvb2xraXRJbmZvO1xufVxuXG5mdW5jdGlvbiBlbXB0eUNhY2hlKCk6IEVudmlyb25tZW50Q2FjaGUge1xuICByZXR1cm4ge1xuICAgIHNzbVBhcmFtZXRlcnM6IG5ldyBNYXAoKSxcbiAgICB0b29sa2l0SW5mbzogdW5kZWZpbmVkLFxuICB9O1xufVxuXG4vKipcbiAqIFRoZSBib290c3RyYXAgdGVtcGxhdGUgdmVyc2lvbiB0aGF0IGludHJvZHVjZWQgc3NtOkdldFBhcmFtZXRlclxuICovXG5jb25zdCBCT09UU1RSQVBfVEVNUExBVEVfVkVSU0lPTl9JTlRST0RVQ0lOR19HRVRQQVJBTUVURVIgPSA1O1xuIl19