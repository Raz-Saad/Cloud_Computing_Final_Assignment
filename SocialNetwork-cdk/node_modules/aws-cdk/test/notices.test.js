"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable import/order */
const https = require("https");
const os = require("os");
const path = require("path");
const fs = require("fs-extra");
const nock = require("nock");
const logging = require("../lib/logging");
const notices_1 = require("../lib/notices");
const version = require("../lib/version");
const BASIC_NOTICE = {
    title: 'Toggling off auto_delete_objects for Bucket empties the bucket',
    issueNumber: 16603,
    overview: 'If a stack is deployed with an S3 bucket with auto_delete_objects=True, and then re-deployed with auto_delete_objects=False, all the objects in the bucket will be deleted.',
    components: [{
            name: 'cli',
            version: '<=1.126.0',
        }],
    schemaVersion: '1',
};
const MULTIPLE_AFFECTED_VERSIONS_NOTICE = {
    title: 'Error when building EKS cluster with monocdk import',
    issueNumber: 17061,
    overview: 'When using monocdk/aws-eks to build a stack containing an EKS cluster, error is thrown about missing lambda-layer-node-proxy-agent/layer/package.json.',
    components: [{
            name: 'cli',
            version: '<1.130.0 >=1.126.0',
        }],
    schemaVersion: '1',
};
const FRAMEWORK_2_1_0_AFFECTED_NOTICE = {
    title: 'Regression on module foobar',
    issueNumber: 1234,
    overview: 'Some bug description',
    components: [{
            name: 'framework',
            version: '<= 2.1.0',
        }],
    schemaVersion: '1',
};
const NOTICE_FOR_APIGATEWAYV2 = {
    title: 'Regression on module foobar',
    issueNumber: 1234,
    overview: 'Some bug description',
    components: [{
            name: '@aws-cdk/aws-apigatewayv2-alpha.',
            version: '<= 2.13.0-alpha.0',
        }],
    schemaVersion: '1',
};
const NOTICE_FOR_APIGATEWAY = {
    title: 'Regression on module foobar',
    issueNumber: 1234,
    overview: 'Some bug description',
    components: [{
            name: '@aws-cdk/aws-apigateway',
            version: '<= 2.13.0-alpha.0',
        }],
    schemaVersion: '1',
};
const NOTICE_FOR_APIGATEWAYV2_CFN_STAGE = {
    title: 'Regression on module foobar',
    issueNumber: 1234,
    overview: 'Some bug description',
    components: [{
            name: 'aws-cdk-lib.aws_apigatewayv2.CfnStage',
            version: '<= 2.13.0-alpha.0',
        }],
    schemaVersion: '1',
};
describe('cli notices', () => {
    beforeAll(() => {
        jest
            .spyOn(version, 'versionNumber')
            .mockImplementation(() => '1.0.0');
    });
    afterAll(() => {
        jest.restoreAllMocks();
    });
    describe(notices_1.formatNotices, () => {
        test('correct format', () => {
            const result = (0, notices_1.formatNotices)([BASIC_NOTICE])[0];
            expect(result).toEqual(`16603	Toggling off auto_delete_objects for Bucket empties the bucket

	Overview: If a stack is deployed with an S3 bucket with
	          auto_delete_objects=True, and then re-deployed with
	          auto_delete_objects=False, all the objects in the bucket
	          will be deleted.

	Affected versions: cli: <=1.126.0

	More information at: https://github.com/aws/aws-cdk/issues/16603
`);
        });
        test('multiple affect versions', () => {
            const result = (0, notices_1.formatNotices)([MULTIPLE_AFFECTED_VERSIONS_NOTICE])[0];
            expect(result).toEqual(`17061	Error when building EKS cluster with monocdk import

	Overview: When using monocdk/aws-eks to build a stack containing an
	          EKS cluster, error is thrown about missing
	          lambda-layer-node-proxy-agent/layer/package.json.

	Affected versions: cli: <1.130.0 >=1.126.0

	More information at: https://github.com/aws/aws-cdk/issues/17061
`);
        });
    });
    describe(notices_1.filterNotices, () => {
        test('correctly filter notices on cli', () => {
            const notices = [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE];
            expect((0, notices_1.filterNotices)(notices, {
                cliVersion: '1.0.0',
            })).toEqual([BASIC_NOTICE]);
            expect((0, notices_1.filterNotices)(notices, {
                cliVersion: '1.129.0',
            })).toEqual([MULTIPLE_AFFECTED_VERSIONS_NOTICE]);
            expect((0, notices_1.filterNotices)(notices, {
                cliVersion: '1.126.0',
            })).toEqual(notices);
            expect((0, notices_1.filterNotices)(notices, {
                cliVersion: '1.130.0',
            })).toEqual([]);
        });
        test('correctly filter notices on framework', () => {
            const notices = [FRAMEWORK_2_1_0_AFFECTED_NOTICE];
            expect((0, notices_1.filterNotices)(notices, {
                outdir: path.join(__dirname, 'cloud-assembly-trees', 'built-with-2_12_0'),
            })).toEqual([]);
            expect((0, notices_1.filterNotices)(notices, {
                outdir: path.join(__dirname, 'cloud-assembly-trees', 'built-with-1_144_0'),
            })).toEqual([FRAMEWORK_2_1_0_AFFECTED_NOTICE]);
        });
        test('correctly filter notices on arbitrary modules', () => {
            const notices = [NOTICE_FOR_APIGATEWAYV2];
            // module-level match
            expect((0, notices_1.filterNotices)(notices, {
                outdir: path.join(__dirname, 'cloud-assembly-trees', 'experimental-module'),
            })).toEqual([NOTICE_FOR_APIGATEWAYV2]);
            // no apigatewayv2 in the tree
            expect((0, notices_1.filterNotices)(notices, {
                outdir: path.join(__dirname, 'cloud-assembly-trees', 'built-with-2_12_0'),
            })).toEqual([]);
            // module name mismatch: apigateway != apigatewayv2
            expect((0, notices_1.filterNotices)([NOTICE_FOR_APIGATEWAY], {
                outdir: path.join(__dirname, 'cloud-assembly-trees', 'experimental-module'),
            })).toEqual([]);
            // construct-level match
            expect((0, notices_1.filterNotices)([NOTICE_FOR_APIGATEWAYV2_CFN_STAGE], {
                outdir: path.join(__dirname, 'cloud-assembly-trees', 'experimental-module'),
            })).toEqual([NOTICE_FOR_APIGATEWAYV2_CFN_STAGE]);
        });
    });
    describe(notices_1.WebsiteNoticeDataSource, () => {
        const dataSource = new notices_1.WebsiteNoticeDataSource();
        test('returns data when download succeeds', async () => {
            const result = await mockCall(200, {
                notices: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],
            });
            expect(result).toEqual([BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE]);
        });
        test('returns appropriate error when the server returns an unexpected status code', async () => {
            const result = mockCall(500, {
                notices: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],
            });
            await expect(result).rejects.toThrow(/500/);
        });
        test('returns appropriate error when the server returns an unexpected structure', async () => {
            const result = mockCall(200, {
                foo: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],
            });
            await expect(result).rejects.toThrow(/key is missing/);
        });
        test('returns appropriate error when the server returns invalid json', async () => {
            const result = mockCall(200, '-09aiskjkj838');
            await expect(result).rejects.toThrow(/Failed to parse/);
        });
        test('returns appropriate error when HTTPS call throws', async () => {
            const mockGet = jest.spyOn(https, 'get')
                .mockImplementation(() => { throw new Error('No connection'); });
            const result = dataSource.fetch();
            await expect(result).rejects.toThrow(/No connection/);
            mockGet.mockRestore();
        });
        test('returns appropriate error when the request has an error', async () => {
            nock('https://cli.cdk.dev-tools.aws.dev')
                .get('/notices.json')
                .replyWithError('DNS resolution failed');
            const result = dataSource.fetch();
            await expect(result).rejects.toThrow(/DNS resolution failed/);
        });
        test('returns appropriate error when the connection stays idle for too long', async () => {
            nock('https://cli.cdk.dev-tools.aws.dev')
                .get('/notices.json')
                .delayConnection(3500)
                .reply(200, {
                notices: [BASIC_NOTICE],
            });
            const result = dataSource.fetch();
            await expect(result).rejects.toThrow(/timed out/);
        });
        test('returns empty array when the request takes too long to finish', async () => {
            nock('https://cli.cdk.dev-tools.aws.dev')
                .get('/notices.json')
                .delayBody(3500)
                .reply(200, {
                notices: [BASIC_NOTICE],
            });
            const result = dataSource.fetch();
            await expect(result).rejects.toThrow(/timed out/);
        });
        function mockCall(statusCode, body) {
            nock('https://cli.cdk.dev-tools.aws.dev')
                .get('/notices.json')
                .reply(statusCode, body);
            return dataSource.fetch();
        }
    });
    describe(notices_1.CachedDataSource, () => {
        const fileName = path.join(os.tmpdir(), 'cache.json');
        const cachedData = [BASIC_NOTICE];
        const freshData = [MULTIPLE_AFFECTED_VERSIONS_NOTICE];
        beforeEach(() => {
            fs.writeFileSync(fileName, '');
        });
        test('retrieves data from the delegate cache when the file is empty', async () => {
            const dataSource = dataSourceWithDelegateReturning(freshData);
            const notices = await dataSource.fetch();
            expect(notices).toEqual(freshData);
        });
        test('retrieves data from the file when the data is still valid', async () => {
            fs.writeJsonSync(fileName, {
                notices: cachedData,
                expiration: Date.now() + 10000,
            });
            const dataSource = dataSourceWithDelegateReturning(freshData);
            const notices = await dataSource.fetch();
            expect(notices).toEqual(cachedData);
        });
        test('retrieves data from the delegate when the data is expired', async () => {
            fs.writeJsonSync(fileName, {
                notices: cachedData,
                expiration: 0,
            });
            const dataSource = dataSourceWithDelegateReturning(freshData);
            const notices = await dataSource.fetch();
            expect(notices).toEqual(freshData);
        });
        test('retrieves data from the delegate when the file cannot be read', async () => {
            const debugSpy = jest.spyOn(logging, 'debug');
            if (fs.existsSync('does-not-exist.json')) {
                fs.unlinkSync('does-not-exist.json');
            }
            const dataSource = dataSourceWithDelegateReturning(freshData, 'does-not-exist.json');
            const notices = await dataSource.fetch();
            expect(notices).toEqual(freshData);
            expect(debugSpy).not.toHaveBeenCalled();
            debugSpy.mockRestore();
            if (fs.existsSync('does-not-exist.json')) {
                fs.unlinkSync('does-not-exist.json');
            }
        });
        test('retrieved data from the delegate when it is configured to ignore the cache', async () => {
            fs.writeJsonSync(fileName, {
                notices: cachedData,
                expiration: Date.now() + 10000,
            });
            const dataSource = dataSourceWithDelegateReturning(freshData, fileName, true);
            const notices = await dataSource.fetch();
            expect(notices).toEqual(freshData);
        });
        test('error in delegate gets turned into empty result by cached source', async () => {
            // GIVEN
            const delegate = {
                fetch: jest.fn().mockRejectedValue(new Error('fetching failed')),
            };
            const dataSource = new notices_1.CachedDataSource(fileName, delegate, true);
            // WHEN
            const notices = await dataSource.fetch();
            // THEN
            expect(notices).toEqual([]);
        });
        function dataSourceWithDelegateReturning(notices, file = fileName, ignoreCache = false) {
            const delegate = {
                fetch: jest.fn(),
            };
            delegate.fetch.mockResolvedValue(notices);
            return new notices_1.CachedDataSource(file, delegate, ignoreCache);
        }
    });
    describe(notices_1.generateMessage, () => {
        test('does not show anything when there are no notices', async () => {
            const dataSource = createDataSource();
            dataSource.fetch.mockResolvedValue([]);
            const result = await (0, notices_1.generateMessage)(dataSource, {
                acknowledgedIssueNumbers: [],
                outdir: '/tmp',
            });
            expect(result).toEqual('');
        });
        test('shows notices that pass the filter', async () => {
            const dataSource = createDataSource();
            dataSource.fetch.mockResolvedValue([BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE]);
            const result = await (0, notices_1.generateMessage)(dataSource, {
                acknowledgedIssueNumbers: [17061],
                outdir: '/tmp',
            });
            expect(result).toEqual(`
NOTICES         (What's this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)

16603	Toggling off auto_delete_objects for Bucket empties the bucket

	Overview: If a stack is deployed with an S3 bucket with
	          auto_delete_objects=True, and then re-deployed with
	          auto_delete_objects=False, all the objects in the bucket
	          will be deleted.

	Affected versions: cli: <=1.126.0

	More information at: https://github.com/aws/aws-cdk/issues/16603


If you don’t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge 16603".`);
        });
        function createDataSource() {
            return {
                fetch: jest.fn(),
            };
        }
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWNlcy50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibm90aWNlcy50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsMENBQTBDO0FBQzFDLDRDQU93QjtBQUN4QiwwQ0FBMEM7QUFFMUMsTUFBTSxZQUFZLEdBQUc7SUFDbkIsS0FBSyxFQUFFLGdFQUFnRTtJQUN2RSxXQUFXLEVBQUUsS0FBSztJQUNsQixRQUFRLEVBQUUsNktBQTZLO0lBQ3ZMLFVBQVUsRUFBRSxDQUFDO1lBQ1gsSUFBSSxFQUFFLEtBQUs7WUFDWCxPQUFPLEVBQUUsV0FBVztTQUNyQixDQUFDO0lBQ0YsYUFBYSxFQUFFLEdBQUc7Q0FDbkIsQ0FBQztBQUVGLE1BQU0saUNBQWlDLEdBQUc7SUFDeEMsS0FBSyxFQUFFLHFEQUFxRDtJQUM1RCxXQUFXLEVBQUUsS0FBSztJQUNsQixRQUFRLEVBQUUsd0pBQXdKO0lBQ2xLLFVBQVUsRUFBRSxDQUFDO1lBQ1gsSUFBSSxFQUFFLEtBQUs7WUFDWCxPQUFPLEVBQUUsb0JBQW9CO1NBQzlCLENBQUM7SUFDRixhQUFhLEVBQUUsR0FBRztDQUNuQixDQUFDO0FBRUYsTUFBTSwrQkFBK0IsR0FBRztJQUN0QyxLQUFLLEVBQUUsNkJBQTZCO0lBQ3BDLFdBQVcsRUFBRSxJQUFJO0lBQ2pCLFFBQVEsRUFBRSxzQkFBc0I7SUFDaEMsVUFBVSxFQUFFLENBQUM7WUFDWCxJQUFJLEVBQUUsV0FBVztZQUNqQixPQUFPLEVBQUUsVUFBVTtTQUNwQixDQUFDO0lBQ0YsYUFBYSxFQUFFLEdBQUc7Q0FDbkIsQ0FBQztBQUVGLE1BQU0sdUJBQXVCLEdBQUc7SUFDOUIsS0FBSyxFQUFFLDZCQUE2QjtJQUNwQyxXQUFXLEVBQUUsSUFBSTtJQUNqQixRQUFRLEVBQUUsc0JBQXNCO0lBQ2hDLFVB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QUNmLENBQUMsQ0FBQztZQUVILE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs2R0FlZ0YsQ0FBQyxDQUFDO1FBQzNHLENBQUMsQ0FBQyxDQUFDO1FBRUgsU0FBUyxnQkFBZ0I7WUFDdkIsT0FBTztnQkFDTCxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTthQUNqQixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvb3JkZXIgKi9cbmltcG9ydCAqIGFzIGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBub2NrIGZyb20gJ25vY2snO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICcuLi9saWIvbG9nZ2luZyc7XG5pbXBvcnQge1xuICBDYWNoZWREYXRhU291cmNlLFxuICBmaWx0ZXJOb3RpY2VzLFxuICBmb3JtYXROb3RpY2VzLFxuICBnZW5lcmF0ZU1lc3NhZ2UsXG4gIE5vdGljZSxcbiAgV2Vic2l0ZU5vdGljZURhdGFTb3VyY2UsXG59IGZyb20gJy4uL2xpYi9ub3RpY2VzJztcbmltcG9ydCAqIGFzIHZlcnNpb24gZnJvbSAnLi4vbGliL3ZlcnNpb24nO1xuXG5jb25zdCBCQVNJQ19OT1RJQ0UgPSB7XG4gIHRpdGxlOiAnVG9nZ2xpbmcgb2ZmIGF1dG9fZGVsZXRlX29iamVjdHMgZm9yIEJ1Y2tldCBlbXB0aWVzIHRoZSBidWNrZXQnLFxuICBpc3N1ZU51bWJlcjogMTY2MDMsXG4gIG92ZXJ2aWV3OiAnSWYgYSBzdGFjayBpcyBkZXBsb3llZCB3aXRoIGFuIFMzIGJ1Y2tldCB3aXRoIGF1dG9fZGVsZXRlX29iamVjdHM9VHJ1ZSwgYW5kIHRoZW4gcmUtZGVwbG95ZWQgd2l0aCBhdXRvX2RlbGV0ZV9vYmplY3RzPUZhbHNlLCBhbGwgdGhlIG9iamVjdHMgaW4gdGhlIGJ1Y2tldCB3aWxsIGJlIGRlbGV0ZWQuJyxcbiAgY29tcG9uZW50czogW3tcbiAgICBuYW1lOiAnY2xpJyxcbiAgICB2ZXJzaW9uOiAnPD0xLjEyNi4wJyxcbiAgfV0sXG4gIHNjaGVtYVZlcnNpb246ICcxJyxcbn07XG5cbmNvbnN0IE1VTFRJUExFX0FGRkVDVEVEX1ZFUlNJT05TX05PVElDRSA9IHtcbiAgdGl0bGU6ICdFcnJvciB3aGVuIGJ1aWxkaW5nIEVLUyBjbHVzdGVyIHdpdGggbW9ub2NkayBpbXBvcnQnLFxuICBpc3N1ZU51bWJlcjogMTcwNjEsXG4gIG92ZXJ2aWV3OiAnV2hlbiB1c2luZyBtb25vY2RrL2F3cy1la3MgdG8gYnVpbGQgYSBzdGFjayBjb250YWluaW5nIGFuIEVLUyBjbHVzdGVyLCBlcnJvciBpcyB0aHJvd24gYWJvdXQgbWlzc2luZyBsYW1iZGEtbGF5ZXItbm9kZS1wcm94eS1hZ2VudC9sYXllci9wYWNrYWdlLmpzb24uJyxcbiAgY29tcG9uZW50czogW3tcbiAgICBuYW1lOiAnY2xpJyxcbiAgICB2ZXJzaW9uOiAnPDEuMTMwLjAgPj0xLjEyNi4wJyxcbiAgfV0sXG4gIHNjaGVtYVZlcnNpb246ICcxJyxcbn07XG5cbmNvbnN0IEZSQU1FV09SS18yXzFfMF9BRkZFQ1RFRF9OT1RJQ0UgPSB7XG4gIHRpdGxlOiAnUmVncmVzc2lvbiBvbiBtb2R1bGUgZm9vYmFyJyxcbiAgaXNzdWVOdW1iZXI6IDEyMzQsXG4gIG92ZXJ2aWV3OiAnU29tZSBidWcgZGVzY3JpcHRpb24nLFxuICBjb21wb25lbnRzOiBbe1xuICAgIG5hbWU6ICdmcmFtZXdvcmsnLFxuICAgIHZlcnNpb246ICc8PSAyLjEuMCcsXG4gIH1dLFxuICBzY2hlbWFWZXJzaW9uOiAnMScsXG59O1xuXG5jb25zdCBOT1RJQ0VfRk9SX0FQSUdBVEVXQVlWMiA9IHtcbiAgdGl0bGU6ICdSZWdyZXNzaW9uIG9uIG1vZHVsZSBmb29iYXInLFxuICBpc3N1ZU51bWJlcjogMTIzNCxcbiAgb3ZlcnZpZXc6ICdTb21lIGJ1ZyBkZXNjcmlwdGlvbicsXG4gIGNvbXBvbmVudHM6IFt7XG4gICAgbmFtZTogJ0Bhd3MtY2RrL2F3cy1hcGlnYXRld2F5djItYWxwaGEuJyxcbiAgICB2ZXJzaW9uOiAnPD0gMi4xMy4wLWFscGhhLjAnLFxuICB9XSxcbiAgc2NoZW1hVmVyc2lvbjogJzEnLFxufTtcblxuY29uc3QgTk9USUNFX0ZPUl9BUElHQVRFV0FZID0ge1xuICB0aXRsZTogJ1JlZ3Jlc3Npb24gb24gbW9kdWxlIGZvb2JhcicsXG4gIGlzc3VlTnVtYmVyOiAxMjM0LFxuICBvdmVydmlldzogJ1NvbWUgYnVnIGRlc2NyaXB0aW9uJyxcbiAgY29tcG9uZW50czogW3tcbiAgICBuYW1lOiAnQGF3cy1jZGsvYXdzLWFwaWdhdGV3YXknLFxuICAgIHZlcnNpb246ICc8PSAyLjEzLjAtYWxwaGEuMCcsXG4gIH1dLFxuICBzY2hlbWFWZXJzaW9uOiAnMScsXG59O1xuXG5jb25zdCBOT1RJQ0VfRk9SX0FQSUdBVEVXQVlWMl9DRk5fU1RBR0UgPSB7XG4gIHRpdGxlOiAnUmVncmVzc2lvbiBvbiBtb2R1bGUgZm9vYmFyJyxcbiAgaXNzdWVOdW1iZXI6IDEyMzQsXG4gIG92ZXJ2aWV3OiAnU29tZSBidWcgZGVzY3JpcHRpb24nLFxuICBjb21wb25lbnRzOiBbe1xuICAgIG5hbWU6ICdhd3MtY2RrLWxpYi5hd3NfYXBpZ2F0ZXdheXYyLkNmblN0YWdlJyxcbiAgICB2ZXJzaW9uOiAnPD0gMi4xMy4wLWFscGhhLjAnLFxuICB9XSxcbiAgc2NoZW1hVmVyc2lvbjogJzEnLFxufTtcblxuZGVzY3JpYmUoJ2NsaSBub3RpY2VzJywgKCkgPT4ge1xuICBiZWZvcmVBbGwoKCkgPT4ge1xuICAgIGplc3RcbiAgICAgIC5zcHlPbih2ZXJzaW9uLCAndmVyc2lvbk51bWJlcicpXG4gICAgICAubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICcxLjAuMCcpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoZm9ybWF0Tm90aWNlcywgKCkgPT4ge1xuICAgIHRlc3QoJ2NvcnJlY3QgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0Tm90aWNlcyhbQkFTSUNfTk9USUNFXSlbMF07XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGAxNjYwM1x0VG9nZ2xpbmcgb2ZmIGF1dG9fZGVsZXRlX29iamVjdHMgZm9yIEJ1Y2tldCBlbXB0aWVzIHRoZSBidWNrZXRcblxuXHRPdmVydmlldzogSWYgYSBzdGFjayBpcyBkZXBsb3llZCB3aXRoIGFuIFMzIGJ1Y2tldCB3aXRoXG5cdCAgICAgICAgICBhdXRvX2RlbGV0ZV9vYmplY3RzPVRydWUsIGFuZCB0aGVuIHJlLWRlcGxveWVkIHdpdGhcblx0ICAgICAgICAgIGF1dG9fZGVsZXRlX29iamVjdHM9RmFsc2UsIGFsbCB0aGUgb2JqZWN0cyBpbiB0aGUgYnVja2V0XG5cdCAgICAgICAgICB3aWxsIGJlIGRlbGV0ZWQuXG5cblx0QWZmZWN0ZWQgdmVyc2lvbnM6IGNsaTogPD0xLjEyNi4wXG5cblx0TW9yZSBpbmZvcm1hdGlvbiBhdDogaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy8xNjYwM1xuYCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdtdWx0aXBsZSBhZmZlY3QgdmVyc2lvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXROb3RpY2VzKFtNVUxUSVBMRV9BRkZFQ1RFRF9WRVJTSU9OU19OT1RJQ0VdKVswXTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoYDE3MDYxXHRFcnJvciB3aGVuIGJ1aWxkaW5nIEVLUyBjbHVzdGVyIHdpdGggbW9ub2NkayBpbXBvcnRcblxuXHRPdmVydmlldzogV2hlbiB1c2luZyBtb25vY2RrL2F3cy1la3MgdG8gYnVpbGQgYSBzdGFjayBjb250YWluaW5nIGFuXG5cdCAgICAgICAgICBFS1MgY2x1c3RlciwgZXJyb3IgaXMgdGhyb3duIGFib3V0IG1pc3Npbmdcblx0ICAgICAgICAgIGxhbWJkYS1sYXllci1ub2RlLXByb3h5LWFnZW50L2xheWVyL3BhY2thZ2UuanNvbi5cblxuXHRBZmZlY3RlZCB2ZXJzaW9uczogY2xpOiA8MS4xMzAuMCA+PTEuMTI2LjBcblxuXHRNb3JlIGluZm9ybWF0aW9uIGF0OiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzE3MDYxXG5gKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoZmlsdGVyTm90aWNlcywgKCkgPT4ge1xuICAgIHRlc3QoJ2NvcnJlY3RseSBmaWx0ZXIgbm90aWNlcyBvbiBjbGknLCAoKSA9PiB7XG4gICAgICBjb25zdCBub3RpY2VzID0gW0JBU0lDX05PVElDRSwgTVVMVElQTEVfQUZGRUNURURfVkVSU0lPTlNfTk9USUNFXTtcbiAgICAgIGV4cGVjdChmaWx0ZXJOb3RpY2VzKG5vdGljZXMsIHtcbiAgICAgICAgY2xpVmVyc2lvbjogJzEuMC4wJyxcbiAgICAgIH0pKS50b0VxdWFsKFtCQVNJQ19OT1RJQ0VdKTtcblxuICAgICAgZXhwZWN0KGZpbHRlck5vdGljZXMobm90aWNlcywge1xuICAgICAgICBjbGlWZXJzaW9uOiAnMS4xMjkuMCcsXG4gICAgICB9KSkudG9FcXVhbChbTVVMVElQTEVfQUZGRUNURURfVkVSU0lPTlNfTk9USUNFXSk7XG5cbiAgICAgIGV4cGVjdChmaWx0ZXJOb3RpY2VzKG5vdGljZXMsIHtcbiAgICAgICAgY2xpVmVyc2lvbjogJzEuMTI2LjAnLFxuICAgICAgfSkpLnRvRXF1YWwobm90aWNlcyk7XG5cbiAgICAgIGV4cGVjdChmaWx0ZXJOb3RpY2VzKG5vdGljZXMsIHtcbiAgICAgICAgY2xpVmVyc2lvbjogJzEuMTMwLjAnLFxuICAgICAgfSkpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnY29ycmVjdGx5IGZpbHRlciBub3RpY2VzIG9uIGZyYW1ld29yaycsICgpID0+IHtcbiAgICAgIGNvbnN0IG5vdGljZXMgPSBbRlJBTUVXT1JLXzJfMV8wX0FGRkVDVEVEX05PVElDRV07XG5cbiAgICAgIGV4cGVjdChmaWx0ZXJOb3RpY2VzKG5vdGljZXMsIHtcbiAgICAgICAgb3V0ZGlyOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnY2xvdWQtYXNzZW1ibHktdHJlZXMnLCAnYnVpbHQtd2l0aC0yXzEyXzAnKSxcbiAgICAgIH0pKS50b0VxdWFsKFtdKTtcblxuICAgICAgZXhwZWN0KGZpbHRlck5vdGljZXMobm90aWNlcywge1xuICAgICAgICBvdXRkaXI6IHBhdGguam9pbihfX2Rpcm5hbWUsICdjbG91ZC1hc3NlbWJseS10cmVlcycsICdidWlsdC13aXRoLTFfMTQ0XzAnKSxcbiAgICAgIH0pKS50b0VxdWFsKFtGUkFNRVdPUktfMl8xXzBfQUZGRUNURURfTk9USUNFXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdjb3JyZWN0bHkgZmlsdGVyIG5vdGljZXMgb24gYXJiaXRyYXJ5IG1vZHVsZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBub3RpY2VzID0gW05PVElDRV9GT1JfQVBJR0FURVdBWVYyXTtcblxuICAgICAgLy8gbW9kdWxlLWxldmVsIG1hdGNoXG4gICAgICBleHBlY3QoZmlsdGVyTm90aWNlcyhub3RpY2VzLCB7XG4gICAgICAgIG91dGRpcjogcGF0aC5qb2luKF9fZGlybmFtZSwgJ2Nsb3VkLWFzc2VtYmx5LXRyZWVzJywgJ2V4cGVyaW1lbnRhbC1tb2R1bGUnKSxcbiAgICAgIH0pKS50b0VxdWFsKFtOT1RJQ0VfRk9SX0FQSUdBVEVXQVlWMl0pO1xuXG4gICAgICAvLyBubyBhcGlnYXRld2F5djIgaW4gdGhlIHRyZWVcbiAgICAgIGV4cGVjdChmaWx0ZXJOb3RpY2VzKG5vdGljZXMsIHtcbiAgICAgICAgb3V0ZGlyOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnY2xvdWQtYXNzZW1ibHktdHJlZXMnLCAnYnVpbHQtd2l0aC0yXzEyXzAnKSxcbiAgICAgIH0pKS50b0VxdWFsKFtdKTtcblxuICAgICAgLy8gbW9kdWxlIG5hbWUgbWlzbWF0Y2g6IGFwaWdhdGV3YXkgIT0gYXBpZ2F0ZXdheXYyXG4gICAgICBleHBlY3QoZmlsdGVyTm90aWNlcyhbTk9USUNFX0ZPUl9BUElHQVRFV0FZXSwge1xuICAgICAgICBvdXRkaXI6IHBhdGguam9pbihfX2Rpcm5hbWUsICdjbG91ZC1hc3NlbWJseS10cmVlcycsICdleHBlcmltZW50YWwtbW9kdWxlJyksXG4gICAgICB9KSkudG9FcXVhbChbXSk7XG5cbiAgICAgIC8vIGNvbnN0cnVjdC1sZXZlbCBtYXRjaFxuICAgICAgZXhwZWN0KGZpbHRlck5vdGljZXMoW05PVElDRV9GT1JfQVBJR0FURVdBWVYyX0NGTl9TVEFHRV0sIHtcbiAgICAgICAgb3V0ZGlyOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnY2xvdWQtYXNzZW1ibHktdHJlZXMnLCAnZXhwZXJpbWVudGFsLW1vZHVsZScpLFxuICAgICAgfSkpLnRvRXF1YWwoW05PVElDRV9GT1JfQVBJR0FURVdBWVYyX0NGTl9TVEFHRV0pO1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIGRlc2NyaWJlKFdlYnNpdGVOb3RpY2VEYXRhU291cmNlLCAoKSA9PiB7XG4gICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZSgpO1xuXG4gICAgdGVzdCgncmV0dXJucyBkYXRhIHdoZW4gZG93bmxvYWQgc3VjY2VlZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrQ2FsbCgyMDAsIHtcbiAgICAgICAgbm90aWNlczogW0JBU0lDX05PVElDRSwgTVVMVElQTEVfQUZGRUNURURfVkVSU0lPTlNfTk9USUNFXSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtCQVNJQ19OT1RJQ0UsIE1VTFRJUExFX0FGRkVDVEVEX1ZFUlNJT05TX05PVElDRV0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncmV0dXJucyBhcHByb3ByaWF0ZSBlcnJvciB3aGVuIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiB1bmV4cGVjdGVkIHN0YXR1cyBjb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbW9ja0NhbGwoNTAwLCB7XG4gICAgICAgIG5vdGljZXM6IFtCQVNJQ19OT1RJQ0UsIE1VTFRJUExFX0FGRkVDVEVEX1ZFUlNJT05TX05PVElDRV0sXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHJlc3VsdCkucmVqZWN0cy50b1Rocm93KC81MDAvKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JldHVybnMgYXBwcm9wcmlhdGUgZXJyb3Igd2hlbiB0aGUgc2VydmVyIHJldHVybnMgYW4gdW5leHBlY3RlZCBzdHJ1Y3R1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBtb2NrQ2FsbCgyMDAsIHtcbiAgICAgICAgZm9vOiBbQkFTSUNfTk9USUNFLCBNVUxUSVBMRV9BRkZFQ1RFRF9WRVJTSU9OU19OT1RJQ0VdLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChyZXN1bHQpLnJlamVjdHMudG9UaHJvdygva2V5IGlzIG1pc3NpbmcvKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JldHVybnMgYXBwcm9wcmlhdGUgZXJyb3Igd2hlbiB0aGUgc2VydmVyIHJldHVybnMgaW52YWxpZCBqc29uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbW9ja0NhbGwoMjAwLCAnLTA5YWlza2prajgzOCcpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocmVzdWx0KS5yZWplY3RzLnRvVGhyb3coL0ZhaWxlZCB0byBwYXJzZS8pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgncmV0dXJucyBhcHByb3ByaWF0ZSBlcnJvciB3aGVuIEhUVFBTIGNhbGwgdGhyb3dzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0dldCA9IGplc3Quc3B5T24oaHR0cHMsICdnZXQnKVxuICAgICAgICAubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdObyBjb25uZWN0aW9uJyk7IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBkYXRhU291cmNlLmZldGNoKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChyZXN1bHQpLnJlamVjdHMudG9UaHJvdygvTm8gY29ubmVjdGlvbi8pO1xuXG4gICAgICBtb2NrR2V0Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdyZXR1cm5zIGFwcHJvcHJpYXRlIGVycm9yIHdoZW4gdGhlIHJlcXVlc3QgaGFzIGFuIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbm9jaygnaHR0cHM6Ly9jbGkuY2RrLmRldi10b29scy5hd3MuZGV2JylcbiAgICAgICAgLmdldCgnL25vdGljZXMuanNvbicpXG4gICAgICAgIC5yZXBseVdpdGhFcnJvcignRE5TIHJlc29sdXRpb24gZmFpbGVkJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGFTb3VyY2UuZmV0Y2goKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHJlc3VsdCkucmVqZWN0cy50b1Rocm93KC9ETlMgcmVzb2x1dGlvbiBmYWlsZWQvKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JldHVybnMgYXBwcm9wcmlhdGUgZXJyb3Igd2hlbiB0aGUgY29ubmVjdGlvbiBzdGF5cyBpZGxlIGZvciB0b28gbG9uZycsIGFzeW5jICgpID0+IHtcbiAgICAgIG5vY2soJ2h0dHBzOi8vY2xpLmNkay5kZXYtdG9vbHMuYXdzLmRldicpXG4gICAgICAgIC5nZXQoJy9ub3RpY2VzLmpzb24nKVxuICAgICAgICAuZGVsYXlDb25uZWN0aW9uKDM1MDApXG4gICAgICAgIC5yZXBseSgyMDAsIHtcbiAgICAgICAgICBub3RpY2VzOiBbQkFTSUNfTk9USUNFXSxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGFTb3VyY2UuZmV0Y2goKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHJlc3VsdCkucmVqZWN0cy50b1Rocm93KC90aW1lZCBvdXQvKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JldHVybnMgZW1wdHkgYXJyYXkgd2hlbiB0aGUgcmVxdWVzdCB0YWtlcyB0b28gbG9uZyB0byBmaW5pc2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICBub2NrKCdodHRwczovL2NsaS5jZGsuZGV2LXRvb2xzLmF3cy5kZXYnKVxuICAgICAgICAuZ2V0KCcvbm90aWNlcy5qc29uJylcbiAgICAgICAgLmRlbGF5Qm9keSgzNTAwKVxuICAgICAgICAucmVwbHkoMjAwLCB7XG4gICAgICAgICAgbm90aWNlczogW0JBU0lDX05PVElDRV0sXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBkYXRhU291cmNlLmZldGNoKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChyZXN1bHQpLnJlamVjdHMudG9UaHJvdygvdGltZWQgb3V0Lyk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtb2NrQ2FsbChzdGF0dXNDb2RlOiBudW1iZXIsIGJvZHk6IGFueSk6IFByb21pc2U8Tm90aWNlW10+IHtcbiAgICAgIG5vY2soJ2h0dHBzOi8vY2xpLmNkay5kZXYtdG9vbHMuYXdzLmRldicpXG4gICAgICAgIC5nZXQoJy9ub3RpY2VzLmpzb24nKVxuICAgICAgICAucmVwbHkoc3RhdHVzQ29kZSwgYm9keSk7XG5cbiAgICAgIHJldHVybiBkYXRhU291cmNlLmZldGNoKCk7XG4gICAgfVxuICB9KTtcblxuICBkZXNjcmliZShDYWNoZWREYXRhU291cmNlLCAoKSA9PiB7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLmpvaW4ob3MudG1wZGlyKCksICdjYWNoZS5qc29uJyk7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IFtCQVNJQ19OT1RJQ0VdO1xuICAgIGNvbnN0IGZyZXNoRGF0YSA9IFtNVUxUSVBMRV9BRkZFQ1RFRF9WRVJTSU9OU19OT1RJQ0VdO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVOYW1lLCAnJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdyZXRyaWV2ZXMgZGF0YSBmcm9tIHRoZSBkZWxlZ2F0ZSBjYWNoZSB3aGVuIHRoZSBmaWxlIGlzIGVtcHR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2VXaXRoRGVsZWdhdGVSZXR1cm5pbmcoZnJlc2hEYXRhKTtcblxuICAgICAgY29uc3Qgbm90aWNlcyA9IGF3YWl0IGRhdGFTb3VyY2UuZmV0Y2goKTtcblxuICAgICAgZXhwZWN0KG5vdGljZXMpLnRvRXF1YWwoZnJlc2hEYXRhKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JldHJpZXZlcyBkYXRhIGZyb20gdGhlIGZpbGUgd2hlbiB0aGUgZGF0YSBpcyBzdGlsbCB2YWxpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGZzLndyaXRlSnNvblN5bmMoZmlsZU5hbWUsIHtcbiAgICAgICAgbm90aWNlczogY2FjaGVkRGF0YSxcbiAgICAgICAgZXhwaXJhdGlvbjogRGF0ZS5ub3coKSArIDEwMDAwLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBkYXRhU291cmNlID0gZGF0YVNvdXJjZVdpdGhEZWxlZ2F0ZVJldHVybmluZyhmcmVzaERhdGEpO1xuXG4gICAgICBjb25zdCBub3RpY2VzID0gYXdhaXQgZGF0YVNvdXJjZS5mZXRjaCgpO1xuXG4gICAgICBleHBlY3Qobm90aWNlcykudG9FcXVhbChjYWNoZWREYXRhKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JldHJpZXZlcyBkYXRhIGZyb20gdGhlIGRlbGVnYXRlIHdoZW4gdGhlIGRhdGEgaXMgZXhwaXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGZzLndyaXRlSnNvblN5bmMoZmlsZU5hbWUsIHtcbiAgICAgICAgbm90aWNlczogY2FjaGVkRGF0YSxcbiAgICAgICAgZXhwaXJhdGlvbjogMCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2VXaXRoRGVsZWdhdGVSZXR1cm5pbmcoZnJlc2hEYXRhKTtcblxuICAgICAgY29uc3Qgbm90aWNlcyA9IGF3YWl0IGRhdGFTb3VyY2UuZmV0Y2goKTtcblxuICAgICAgZXhwZWN0KG5vdGljZXMpLnRvRXF1YWwoZnJlc2hEYXRhKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3JldHJpZXZlcyBkYXRhIGZyb20gdGhlIGRlbGVnYXRlIHdoZW4gdGhlIGZpbGUgY2Fubm90IGJlIHJlYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkZWJ1Z1NweSA9IGplc3Quc3B5T24obG9nZ2luZywgJ2RlYnVnJyk7XG5cbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKCdkb2VzLW5vdC1leGlzdC5qc29uJykpIHtcbiAgICAgICAgZnMudW5saW5rU3luYygnZG9lcy1ub3QtZXhpc3QuanNvbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhU291cmNlID0gZGF0YVNvdXJjZVdpdGhEZWxlZ2F0ZVJldHVybmluZyhmcmVzaERhdGEsICdkb2VzLW5vdC1leGlzdC5qc29uJyk7XG5cbiAgICAgIGNvbnN0IG5vdGljZXMgPSBhd2FpdCBkYXRhU291cmNlLmZldGNoKCk7XG5cbiAgICAgIGV4cGVjdChub3RpY2VzKS50b0VxdWFsKGZyZXNoRGF0YSk7XG4gICAgICBleHBlY3QoZGVidWdTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIGRlYnVnU3B5Lm1vY2tSZXN0b3JlKCk7XG5cbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKCdkb2VzLW5vdC1leGlzdC5qc29uJykpIHtcbiAgICAgICAgZnMudW5saW5rU3luYygnZG9lcy1ub3QtZXhpc3QuanNvbicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdCgncmV0cmlldmVkIGRhdGEgZnJvbSB0aGUgZGVsZWdhdGUgd2hlbiBpdCBpcyBjb25maWd1cmVkIHRvIGlnbm9yZSB0aGUgY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBmcy53cml0ZUpzb25TeW5jKGZpbGVOYW1lLCB7XG4gICAgICAgIG5vdGljZXM6IGNhY2hlZERhdGEsXG4gICAgICAgIGV4cGlyYXRpb246IERhdGUubm93KCkgKyAxMDAwMCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2VXaXRoRGVsZWdhdGVSZXR1cm5pbmcoZnJlc2hEYXRhLCBmaWxlTmFtZSwgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IG5vdGljZXMgPSBhd2FpdCBkYXRhU291cmNlLmZldGNoKCk7XG5cbiAgICAgIGV4cGVjdChub3RpY2VzKS50b0VxdWFsKGZyZXNoRGF0YSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdlcnJvciBpbiBkZWxlZ2F0ZSBnZXRzIHR1cm5lZCBpbnRvIGVtcHR5IHJlc3VsdCBieSBjYWNoZWQgc291cmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIGNvbnN0IGRlbGVnYXRlID0ge1xuICAgICAgICBmZXRjaDogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignZmV0Y2hpbmcgZmFpbGVkJykpLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgQ2FjaGVkRGF0YVNvdXJjZShmaWxlTmFtZSwgZGVsZWdhdGUsIHRydWUpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBub3RpY2VzID0gYXdhaXQgZGF0YVNvdXJjZS5mZXRjaCgpO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3Qobm90aWNlcykudG9FcXVhbChbXSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBkYXRhU291cmNlV2l0aERlbGVnYXRlUmV0dXJuaW5nKG5vdGljZXM6IE5vdGljZVtdLCBmaWxlOiBzdHJpbmcgPSBmaWxlTmFtZSwgaWdub3JlQ2FjaGU6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgICAgY29uc3QgZGVsZWdhdGUgPSB7XG4gICAgICAgIGZldGNoOiBqZXN0LmZuKCksXG4gICAgICB9O1xuXG4gICAgICBkZWxlZ2F0ZS5mZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZShub3RpY2VzKTtcbiAgICAgIHJldHVybiBuZXcgQ2FjaGVkRGF0YVNvdXJjZShmaWxlLCBkZWxlZ2F0ZSwgaWdub3JlQ2FjaGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoZ2VuZXJhdGVNZXNzYWdlLCAoKSA9PiB7XG4gICAgdGVzdCgnZG9lcyBub3Qgc2hvdyBhbnl0aGluZyB3aGVuIHRoZXJlIGFyZSBubyBub3RpY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IGNyZWF0ZURhdGFTb3VyY2UoKTtcbiAgICAgIGRhdGFTb3VyY2UuZmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZU1lc3NhZ2UoZGF0YVNvdXJjZSwge1xuICAgICAgICBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IFtdLFxuICAgICAgICBvdXRkaXI6ICcvdG1wJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKCcnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3dzIG5vdGljZXMgdGhhdCBwYXNzIHRoZSBmaWx0ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhU291cmNlID0gY3JlYXRlRGF0YVNvdXJjZSgpO1xuICAgICAgZGF0YVNvdXJjZS5mZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZShbQkFTSUNfTk9USUNFLCBNVUxUSVBMRV9BRkZFQ1RFRF9WRVJTSU9OU19OT1RJQ0VdKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2VuZXJhdGVNZXNzYWdlKGRhdGFTb3VyY2UsIHtcbiAgICAgICAgYWNrbm93bGVkZ2VkSXNzdWVOdW1iZXJzOiBbMTcwNjFdLFxuICAgICAgICBvdXRkaXI6ICcvdG1wJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGBcbk5PVElDRVMgICAgICAgICAoV2hhdCdzIHRoaXM/IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay93aWtpL0NMSS1Ob3RpY2VzKVxuXG4xNjYwM1x0VG9nZ2xpbmcgb2ZmIGF1dG9fZGVsZXRlX29iamVjdHMgZm9yIEJ1Y2tldCBlbXB0aWVzIHRoZSBidWNrZXRcblxuXHRPdmVydmlldzogSWYgYSBzdGFjayBpcyBkZXBsb3llZCB3aXRoIGFuIFMzIGJ1Y2tldCB3aXRoXG5cdCAgICAgICAgICBhdXRvX2RlbGV0ZV9vYmplY3RzPVRydWUsIGFuZCB0aGVuIHJlLWRlcGxveWVkIHdpdGhcblx0ICAgICAgICAgIGF1dG9fZGVsZXRlX29iamVjdHM9RmFsc2UsIGFsbCB0aGUgb2JqZWN0cyBpbiB0aGUgYnVja2V0XG5cdCAgICAgICAgICB3aWxsIGJlIGRlbGV0ZWQuXG5cblx0QWZmZWN0ZWQgdmVyc2lvbnM6IGNsaTogPD0xLjEyNi4wXG5cblx0TW9yZSBpbmZvcm1hdGlvbiBhdDogaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy8xNjYwM1xuXG5cbklmIHlvdSBkb27igJl0IHdhbnQgdG8gc2VlIGEgbm90aWNlIGFueW1vcmUsIHVzZSBcImNkayBhY2tub3dsZWRnZSA8aWQ+XCIuIEZvciBleGFtcGxlLCBcImNkayBhY2tub3dsZWRnZSAxNjYwM1wiLmApO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0YVNvdXJjZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZldGNoOiBqZXN0LmZuKCksXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59KTtcbiJdfQ==