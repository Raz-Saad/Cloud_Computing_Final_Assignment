"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.withMocked = exports.withMockedClassSingleton = exports.instanceMockFrom = exports.testStack = exports.testAssembly = exports.MockCloudExecutable = exports.DEFAULT_FAKE_TEMPLATE = void 0;
/* eslint-disable import/order */
const fs = require("fs");
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const mock_sdk_1 = require("./util/mock-sdk");
const cloud_executable_1 = require("../lib/api/cxapp/cloud-executable");
const settings_1 = require("../lib/settings");
exports.DEFAULT_FAKE_TEMPLATE = { No: 'Resources' };
class MockCloudExecutable extends cloud_executable_1.CloudExecutable {
    constructor(assembly, sdkProviderArg) {
        const configuration = new settings_1.Configuration();
        const sdkProvider = sdkProviderArg ?? new mock_sdk_1.MockSdkProvider();
        super({
            configuration,
            sdkProvider,
            synthesizer: () => Promise.resolve(testAssembly(assembly)),
        });
        this.configuration = configuration;
        this.sdkProvider = sdkProvider;
    }
}
exports.MockCloudExecutable = MockCloudExecutable;
function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function addAttributes(assembly, builder) {
    for (const stack of assembly.stacks) {
        const templateFile = `${stack.stackName}.template.json`;
        const template = stack.template ?? exports.DEFAULT_FAKE_TEMPLATE;
        fs.writeFileSync(path.join(builder.outdir, templateFile), JSON.stringify(template, undefined, 2));
        addNestedStacks(templateFile, builder.outdir, template);
        // we call patchStackTags here to simulate the tags formatter
        // that is used when building real manifest files.
        const metadata = patchStackTags({ ...stack.metadata });
        for (const asset of stack.assets || []) {
            metadata[asset.id] = [
                { type: cxschema.ArtifactMetadataEntryType.ASSET, data: asset },
            ];
        }
        for (const missing of assembly.missing || []) {
            builder.addMissing(missing);
        }
        const dependencies = [...stack.depends ?? []];
        if (stack.assetManifest) {
            const manifestFile = `${stack.stackName}.assets.json`;
            fs.writeFileSync(path.join(builder.outdir, manifestFile), JSON.stringify(stack.assetManifest, undefined, 2));
            dependencies.push(`${stack.stackName}.assets`);
            builder.addArtifact(`${stack.stackName}.assets`, {
                type: cxschema.ArtifactType.ASSET_MANIFEST,
                environment: stack.env || 'aws://123456789012/here',
                properties: {
                    file: manifestFile,
                },
            });
        }
        builder.addArtifact(stack.stackName, {
            type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,
            environment: stack.env || 'aws://123456789012/here',
            dependencies,
            metadata,
            properties: {
                ...stack.properties,
                templateFile,
                terminationProtection: stack.terminationProtection,
            },
            displayName: stack.displayName,
        });
    }
}
function addNestedStacks(templatePath, outdir, rootStackTemplate) {
    let template = rootStackTemplate;
    if (!template) {
        const templatePathWithDir = path.join('nested-stack-templates', templatePath);
        template = JSON.parse(fs.readFileSync(path.join(__dirname, templatePathWithDir)).toString());
        fs.writeFileSync(path.join(outdir, templatePath), JSON.stringify(template, undefined, 2));
    }
    for (const logicalId in template.Resources) {
        if (template.Resources[logicalId].Type === 'AWS::CloudFormation::Stack') {
            if (template.Resources[logicalId].Metadata && template.Resources[logicalId].Metadata['aws:asset:path']) {
                const nestedTemplatePath = template.Resources[logicalId].Metadata['aws:asset:path'];
                addNestedStacks(nestedTemplatePath, outdir);
            }
        }
    }
}
function testAssembly(assembly) {
    const builder = new cxapi.CloudAssemblyBuilder();
    addAttributes(assembly, builder);
    if (assembly.nestedAssemblies != null && assembly.nestedAssemblies.length > 0) {
        assembly.nestedAssemblies?.forEach((nestedAssembly, i) => {
            const nestedAssemblyBuilder = builder.createNestedAssembly(`nested${i}`, `nested${i}`);
            addAttributes(nestedAssembly, nestedAssemblyBuilder);
            nestedAssemblyBuilder.buildAssembly();
        });
    }
    return builder.buildAssembly();
}
exports.testAssembly = testAssembly;
/**
 * Transform stack tags from how they are decalred in source code (lower cased)
 * to how they are stored on disk (upper cased). In real synthesis this is done
 * by a special tags formatter.
 *
 * @see aws-cdk-lib/lib/stack.ts
 */
function patchStackTags(metadata) {
    const cloned = clone(metadata);
    for (const metadataEntries of Object.values(cloned)) {
        for (const metadataEntry of metadataEntries) {
            if (metadataEntry.type === cxschema.ArtifactMetadataEntryType.STACK_TAGS && metadataEntry.data) {
                const metadataAny = metadataEntry;
                metadataAny.data = metadataAny.data.map((t) => {
                    return { Key: t.key, Value: t.value };
                });
            }
        }
    }
    return cloned;
}
function testStack(stack) {
    const assembly = testAssembly({ stacks: [stack] });
    return assembly.getStackByName(stack.stackName);
}
exports.testStack = testStack;
/**
 * Return a mocked instance of a class, given its constructor
 *
 * I don't understand why jest doesn't provide this by default,
 * but there you go.
 *
 * FIXME: Currently very limited. Doesn't support inheritance, getters or
 * automatic detection of properties (as those exist on instances, not
 * classes).
 */
function instanceMockFrom(ctr) {
    const ret = {};
    for (const methodName of Object.getOwnPropertyNames(ctr.prototype)) {
        ret[methodName] = jest.fn();
    }
    return ret;
}
exports.instanceMockFrom = instanceMockFrom;
/**
 * Run an async block with a class (constructor) replaced with a mock
 *
 * The class constructor will be replaced with a constructor that returns
 * a singleton, and the singleton will be passed to the block so that its
 * methods can be mocked individually.
 *
 * Uses `instanceMockFrom` so is subject to the same limitations that hold
 * for that function.
 */
async function withMockedClassSingleton(obj, key, cb) {
    const original = obj[key];
    try {
        const mock = instanceMockFrom(original);
        obj[key] = jest.fn().mockReturnValue(mock);
        const ret = await cb(mock);
        return ret;
    }
    finally {
        obj[key] = original;
    }
}
exports.withMockedClassSingleton = withMockedClassSingleton;
function withMocked(obj, key, block) {
    const original = obj[key];
    const mockFn = jest.fn();
    obj[key] = mockFn;
    let asyncFinally = false;
    try {
        const ret = block(mockFn);
        if (!isPromise(ret)) {
            return ret;
        }
        asyncFinally = true;
        return ret.finally(() => { obj[key] = original; });
    }
    finally {
        if (!asyncFinally) {
            obj[key] = original;
        }
    }
}
exports.withMocked = withMocked;
function isPromise(object) {
    return Promise.resolve(object) === object;
}
async function sleep(ms) {
    return new Promise(ok => setTimeout(ok, ms));
}
exports.sleep = sleep;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBQ2pDLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsMkRBQTJEO0FBRTNELHlDQUF5QztBQUN6Qyw4Q0FBa0Q7QUFDbEQsd0VBQW9FO0FBQ3BFLDhDQUFnRDtBQUVuQyxRQUFBLHFCQUFxQixHQUFHLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxDQUFDO0FBeUJ6RCxNQUFhLG1CQUFvQixTQUFRLGtDQUFlO0lBSXRELFlBQVksUUFBc0IsRUFBRSxjQUFnQztRQUNsRSxNQUFNLGFBQWEsR0FBRyxJQUFJLHdCQUFhLEVBQUUsQ0FBQztRQUMxQyxNQUFNLFdBQVcsR0FBRyxjQUFjLElBQUksSUFBSSwwQkFBZSxFQUFFLENBQUM7UUFFNUQsS0FBSyxDQUFDO1lBQ0osYUFBYTtZQUNiLFdBQVc7WUFDWCxXQUFXLEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDM0QsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7SUFDakMsQ0FBQztDQUNGO0FBakJELGtEQWlCQztBQUVELFNBQVMsS0FBSyxDQUFDLEdBQVE7SUFDckIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBRUQsU0FBUyxhQUFhLENBQUMsUUFBc0IsRUFBRSxPQUFtQztJQUNoRixLQUFLLE1BQU0sS0FBSyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNwQyxNQUFNLFlBQVksR0FBRyxHQUFHLEtBQUssQ0FBQyxTQUFTLGdCQUFnQixDQUFDO1FBQ3hELE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLElBQUksNkJBQXFCLENBQUM7UUFDekQsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEcsZUFBZSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRXhELDZEQUE2RDtRQUM3RCxrREFBa0Q7UUFDbEQsTUFBTSxRQUFRLEdBQWlELGNBQWMsQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDckcsS0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLEVBQUUsRUFBRSxDQUFDO1lBQ3ZDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUc7Z0JBQ25CLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTthQUNoRSxDQUFDO1FBQ0osQ0FBQztRQUVELEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUUsQ0FBQztZQUM3QyxPQUFPLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlCLENBQUM7UUFFRCxNQUFNLFlBQVksR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQztRQUU5QyxJQUFJLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUN4QixNQUFNLFlBQVksR0FBRyxHQUFHLEtBQUssQ0FBQyxTQUFTLGNBQWMsQ0FBQztZQUN0RCxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0csWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxTQUFTLFNBQVMsQ0FBQyxDQUFDO1lBQy9DLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxLQUFLLENBQUMsU0FBUyxTQUFTLEVBQUU7Z0JBQy9DLElBQUksRUFBRSxRQUFRLENBQUMsWUFBWSxDQUFDLGNBQWM7Z0JBQzFDLFdBQVcsRUFBRSxLQUFLLENBQUMsR0FBRyxJQUFJLHlCQUF5QjtnQkFDbkQsVUFBVSxFQUFFO29CQUNWLElBQUksRUFBRSxZQUFZO2lCQUNuQjthQUNGLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUU7WUFDbkMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxZQUFZLENBQUMsd0JBQXdCO1lBQ3BELFdBQVcsRUFBRSxLQUFLLENBQUMsR0FBRyxJQUFJLHlCQUF5QjtZQUVuRCxZQUFZO1lBQ1osUUFBUTtZQUNSLFVBQVUsRUFBRTtnQkFDVixHQUFHLEtBQUssQ0FBQyxVQUFVO2dCQUNuQixZQUFZO2dCQUNaLHFCQUFxQixFQUFFLEtBQUssQ0FBQyxxQkFBcUI7YUFDbkQ7WUFDRCxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVc7U0FDL0IsQ0FBQyxDQUFDO0lBRUwsQ0FBQztBQUNILENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxZQUFvQixFQUFFLE1BQWMsRUFBRSxpQkFBdUI7SUFDcEYsSUFBSSxRQUFRLEdBQUcsaUJBQWlCLENBQUM7SUFFakMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2QsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzlFLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDN0YsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRUQsS0FBSyxNQUFNLFNBQVMsSUFBSSxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDM0MsSUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksS0FBSyw0QkFBNEIsRUFBRSxDQUFDO1lBQ3hFLElBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO2dCQUN2RyxNQUFNLGtCQUFrQixHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Z0JBQ3BGLGVBQWUsQ0FBQyxrQkFBa0IsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUM5QyxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBZ0IsWUFBWSxDQUFDLFFBQXNCO0lBQ2pELE1BQU0sT0FBTyxHQUFHLElBQUksS0FBSyxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFDakQsYUFBYSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUVqQyxJQUFJLFFBQVEsQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLElBQUksUUFBUSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUM5RSxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsT0FBTyxDQUFDLENBQUMsY0FBNEIsRUFBRSxDQUFTLEVBQUUsRUFBRTtZQUM3RSxNQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN2RixhQUFhLENBQUMsY0FBYyxFQUFFLHFCQUFxQixDQUFDLENBQUM7WUFDckQscUJBQXFCLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDeEMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsT0FBTyxPQUFPLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDakMsQ0FBQztBQWJELG9DQWFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxjQUFjLENBQUMsUUFBc0Q7SUFFNUUsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBaUQsQ0FBQztJQUUvRSxLQUFLLE1BQU0sZUFBZSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUNwRCxLQUFLLE1BQU0sYUFBYSxJQUFJLGVBQWUsRUFBRSxDQUFDO1lBQzVDLElBQUksYUFBYSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMseUJBQXlCLENBQUMsVUFBVSxJQUFJLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFFL0YsTUFBTSxXQUFXLEdBQUcsYUFBb0IsQ0FBQztnQkFFekMsV0FBVyxDQUFDLElBQUksR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQU0sRUFBRSxFQUFFO29CQUNqRCxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDeEMsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsU0FBZ0IsU0FBUyxDQUFDLEtBQXdCO0lBQ2hELE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNuRCxPQUFPLFFBQVEsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFIRCw4QkFHQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLGdCQUFnQixDQUFJLEdBQThCO0lBQ2hFLE1BQU0sR0FBRyxHQUFRLEVBQUUsQ0FBQztJQUNwQixLQUFLLE1BQU0sVUFBVSxJQUFJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztRQUNuRSxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFORCw0Q0FNQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNJLEtBQUssVUFBVSx3QkFBd0IsQ0FDNUMsR0FBTSxFQUNOLEdBQU0sRUFDTixFQUFtRztJQUduRyxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUIsSUFBSSxDQUFDO1FBQ0gsTUFBTSxJQUFJLEdBQUcsZ0JBQWdCLENBQUMsUUFBZSxDQUFDLENBQUM7UUFDL0MsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFRLENBQUM7UUFDbEQsTUFBTSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsSUFBVyxDQUFDLENBQUM7UUFDbEMsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO1lBQVMsQ0FBQztRQUNULEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUM7SUFDdEIsQ0FBQztBQUNILENBQUM7QUFmRCw0REFlQztBQUVELFNBQWdCLFVBQVUsQ0FBeUMsR0FBTSxFQUFFLEdBQU0sRUFBRSxLQUFtQztJQUNwSCxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQ3hCLEdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUM7SUFFM0IsSUFBSSxZQUFZLEdBQVksS0FBSyxDQUFDO0lBQ2xDLElBQUksQ0FBQztRQUNILE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFhLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFBQyxPQUFPLEdBQUcsQ0FBQztRQUFDLENBQUM7UUFFcEMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUNwQixPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBUSxDQUFDO0lBQzVELENBQUM7WUFBUyxDQUFDO1FBQ1QsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ2xCLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUM7UUFDdEIsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBakJELGdDQWlCQztBQUVELFNBQVMsU0FBUyxDQUFJLE1BQVc7SUFDL0IsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLE1BQU0sQ0FBQztBQUM1QyxDQUFDO0FBRU0sS0FBSyxVQUFVLEtBQUssQ0FBQyxFQUFVO0lBQ3BDLE9BQU8sSUFBSSxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUZELHNCQUVDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L29yZGVyICovXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCB7IEFzc2V0TWFuaWZlc3QgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IE1vY2tTZGtQcm92aWRlciB9IGZyb20gJy4vdXRpbC9tb2NrLXNkayc7XG5pbXBvcnQgeyBDbG91ZEV4ZWN1dGFibGUgfSBmcm9tICcuLi9saWIvYXBpL2N4YXBwL2Nsb3VkLWV4ZWN1dGFibGUnO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL2xpYi9zZXR0aW5ncyc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0ZBS0VfVEVNUExBVEUgPSB7IE5vOiAnUmVzb3VyY2VzJyB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RTdGFja0FydGlmYWN0IHtcbiAgc3RhY2tOYW1lOiBzdHJpbmc7XG4gIHRlbXBsYXRlPzogYW55O1xuICBlbnY/OiBzdHJpbmc7XG4gIGRlcGVuZHM/OiBzdHJpbmdbXTtcbiAgbWV0YWRhdGE/OiBjeGFwaS5TdGFja01ldGFkYXRhO1xuXG4gIC8qKiBPbGQtc3R5bGUgYXNzZXRzICovXG4gIGFzc2V0cz86IGN4c2NoZW1hLkFzc2V0TWV0YWRhdGFFbnRyeVtdO1xuICBwcm9wZXJ0aWVzPzogUGFydGlhbDxjeHNjaGVtYS5Bd3NDbG91ZEZvcm1hdGlvblN0YWNrUHJvcGVydGllcz47XG4gIHRlcm1pbmF0aW9uUHJvdGVjdGlvbj86IGJvb2xlYW47XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuXG4gIC8qKiBOZXctc3R5bGUgYXNzZXRzICovXG4gIGFzc2V0TWFuaWZlc3Q/OiBBc3NldE1hbmlmZXN0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RBc3NlbWJseSB7XG4gIHN0YWNrczogVGVzdFN0YWNrQXJ0aWZhY3RbXTtcbiAgbWlzc2luZz86IGN4c2NoZW1hLk1pc3NpbmdDb250ZXh0W107XG4gIG5lc3RlZEFzc2VtYmxpZXM/OiBUZXN0QXNzZW1ibHlbXTtcbn1cblxuZXhwb3J0IGNsYXNzIE1vY2tDbG91ZEV4ZWN1dGFibGUgZXh0ZW5kcyBDbG91ZEV4ZWN1dGFibGUge1xuICBwdWJsaWMgcmVhZG9ubHkgY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbjtcbiAgcHVibGljIHJlYWRvbmx5IHNka1Byb3ZpZGVyOiBNb2NrU2RrUHJvdmlkZXI7XG5cbiAgY29uc3RydWN0b3IoYXNzZW1ibHk6IFRlc3RBc3NlbWJseSwgc2RrUHJvdmlkZXJBcmc/OiBNb2NrU2RrUHJvdmlkZXIpIHtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gbmV3IENvbmZpZ3VyYXRpb24oKTtcbiAgICBjb25zdCBzZGtQcm92aWRlciA9IHNka1Byb3ZpZGVyQXJnID8/IG5ldyBNb2NrU2RrUHJvdmlkZXIoKTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICBzZGtQcm92aWRlcixcbiAgICAgIHN5bnRoZXNpemVyOiAoKSA9PiBQcm9taXNlLnJlc29sdmUodGVzdEFzc2VtYmx5KGFzc2VtYmx5KSksXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIHRoaXMuc2RrUHJvdmlkZXIgPSBzZGtQcm92aWRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZShvYmo6IGFueSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0cmlidXRlcyhhc3NlbWJseTogVGVzdEFzc2VtYmx5LCBidWlsZGVyOiBjeGFwaS5DbG91ZEFzc2VtYmx5QnVpbGRlcikge1xuICBmb3IgKGNvbnN0IHN0YWNrIG9mIGFzc2VtYmx5LnN0YWNrcykge1xuICAgIGNvbnN0IHRlbXBsYXRlRmlsZSA9IGAke3N0YWNrLnN0YWNrTmFtZX0udGVtcGxhdGUuanNvbmA7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBzdGFjay50ZW1wbGF0ZSA/PyBERUZBVUxUX0ZBS0VfVEVNUExBVEU7XG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oYnVpbGRlci5vdXRkaXIsIHRlbXBsYXRlRmlsZSksIEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlLCB1bmRlZmluZWQsIDIpKTtcbiAgICBhZGROZXN0ZWRTdGFja3ModGVtcGxhdGVGaWxlLCBidWlsZGVyLm91dGRpciwgdGVtcGxhdGUpO1xuXG4gICAgLy8gd2UgY2FsbCBwYXRjaFN0YWNrVGFncyBoZXJlIHRvIHNpbXVsYXRlIHRoZSB0YWdzIGZvcm1hdHRlclxuICAgIC8vIHRoYXQgaXMgdXNlZCB3aGVuIGJ1aWxkaW5nIHJlYWwgbWFuaWZlc3QgZmlsZXMuXG4gICAgY29uc3QgbWV0YWRhdGE6IHsgW3BhdGg6IHN0cmluZ106IGN4c2NoZW1hLk1ldGFkYXRhRW50cnlbXSB9ID0gcGF0Y2hTdGFja1RhZ3MoeyAuLi5zdGFjay5tZXRhZGF0YSB9KTtcbiAgICBmb3IgKGNvbnN0IGFzc2V0IG9mIHN0YWNrLmFzc2V0cyB8fCBbXSkge1xuICAgICAgbWV0YWRhdGFbYXNzZXQuaWRdID0gW1xuICAgICAgICB7IHR5cGU6IGN4c2NoZW1hLkFydGlmYWN0TWV0YWRhdGFFbnRyeVR5cGUuQVNTRVQsIGRhdGE6IGFzc2V0IH0sXG4gICAgICBdO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgbWlzc2luZyBvZiBhc3NlbWJseS5taXNzaW5nIHx8IFtdKSB7XG4gICAgICBidWlsZGVyLmFkZE1pc3NpbmcobWlzc2luZyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gWy4uLnN0YWNrLmRlcGVuZHMgPz8gW11dO1xuXG4gICAgaWYgKHN0YWNrLmFzc2V0TWFuaWZlc3QpIHtcbiAgICAgIGNvbnN0IG1hbmlmZXN0RmlsZSA9IGAke3N0YWNrLnN0YWNrTmFtZX0uYXNzZXRzLmpzb25gO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oYnVpbGRlci5vdXRkaXIsIG1hbmlmZXN0RmlsZSksIEpTT04uc3RyaW5naWZ5KHN0YWNrLmFzc2V0TWFuaWZlc3QsIHVuZGVmaW5lZCwgMikpO1xuICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYCR7c3RhY2suc3RhY2tOYW1lfS5hc3NldHNgKTtcbiAgICAgIGJ1aWxkZXIuYWRkQXJ0aWZhY3QoYCR7c3RhY2suc3RhY2tOYW1lfS5hc3NldHNgLCB7XG4gICAgICAgIHR5cGU6IGN4c2NoZW1hLkFydGlmYWN0VHlwZS5BU1NFVF9NQU5JRkVTVCxcbiAgICAgICAgZW52aXJvbm1lbnQ6IHN0YWNrLmVudiB8fCAnYXdzOi8vMTIzNDU2Nzg5MDEyL2hlcmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZmlsZTogbWFuaWZlc3RGaWxlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYnVpbGRlci5hZGRBcnRpZmFjdChzdGFjay5zdGFja05hbWUsIHtcbiAgICAgIHR5cGU6IGN4c2NoZW1hLkFydGlmYWN0VHlwZS5BV1NfQ0xPVURGT1JNQVRJT05fU1RBQ0ssXG4gICAgICBlbnZpcm9ubWVudDogc3RhY2suZW52IHx8ICdhd3M6Ly8xMjM0NTY3ODkwMTIvaGVyZScsXG5cbiAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAuLi5zdGFjay5wcm9wZXJ0aWVzLFxuICAgICAgICB0ZW1wbGF0ZUZpbGUsXG4gICAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogc3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uLFxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiBzdGFjay5kaXNwbGF5TmFtZSxcbiAgICB9KTtcblxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZE5lc3RlZFN0YWNrcyh0ZW1wbGF0ZVBhdGg6IHN0cmluZywgb3V0ZGlyOiBzdHJpbmcsIHJvb3RTdGFja1RlbXBsYXRlPzogYW55KSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHJvb3RTdGFja1RlbXBsYXRlO1xuXG4gIGlmICghdGVtcGxhdGUpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZVBhdGhXaXRoRGlyID0gcGF0aC5qb2luKCduZXN0ZWQtc3RhY2stdGVtcGxhdGVzJywgdGVtcGxhdGVQYXRoKTtcbiAgICB0ZW1wbGF0ZSA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhdGguam9pbihfX2Rpcm5hbWUsIHRlbXBsYXRlUGF0aFdpdGhEaXIpKS50b1N0cmluZygpKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihvdXRkaXIsIHRlbXBsYXRlUGF0aCksIEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlLCB1bmRlZmluZWQsIDIpKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbG9naWNhbElkIGluIHRlbXBsYXRlLlJlc291cmNlcykge1xuICAgIGlmICh0ZW1wbGF0ZS5SZXNvdXJjZXNbbG9naWNhbElkXS5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snKSB7XG4gICAgICBpZiAodGVtcGxhdGUuUmVzb3VyY2VzW2xvZ2ljYWxJZF0uTWV0YWRhdGEgJiYgdGVtcGxhdGUuUmVzb3VyY2VzW2xvZ2ljYWxJZF0uTWV0YWRhdGFbJ2F3czphc3NldDpwYXRoJ10pIHtcbiAgICAgICAgY29uc3QgbmVzdGVkVGVtcGxhdGVQYXRoID0gdGVtcGxhdGUuUmVzb3VyY2VzW2xvZ2ljYWxJZF0uTWV0YWRhdGFbJ2F3czphc3NldDpwYXRoJ107XG4gICAgICAgIGFkZE5lc3RlZFN0YWNrcyhuZXN0ZWRUZW1wbGF0ZVBhdGgsIG91dGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0QXNzZW1ibHkoYXNzZW1ibHk6IFRlc3RBc3NlbWJseSk6IGN4YXBpLkNsb3VkQXNzZW1ibHkge1xuICBjb25zdCBidWlsZGVyID0gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHlCdWlsZGVyKCk7XG4gIGFkZEF0dHJpYnV0ZXMoYXNzZW1ibHksIGJ1aWxkZXIpO1xuXG4gIGlmIChhc3NlbWJseS5uZXN0ZWRBc3NlbWJsaWVzICE9IG51bGwgJiYgYXNzZW1ibHkubmVzdGVkQXNzZW1ibGllcy5sZW5ndGggPiAwKSB7XG4gICAgYXNzZW1ibHkubmVzdGVkQXNzZW1ibGllcz8uZm9yRWFjaCgobmVzdGVkQXNzZW1ibHk6IFRlc3RBc3NlbWJseSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBuZXN0ZWRBc3NlbWJseUJ1aWxkZXIgPSBidWlsZGVyLmNyZWF0ZU5lc3RlZEFzc2VtYmx5KGBuZXN0ZWQke2l9YCwgYG5lc3RlZCR7aX1gKTtcbiAgICAgIGFkZEF0dHJpYnV0ZXMobmVzdGVkQXNzZW1ibHksIG5lc3RlZEFzc2VtYmx5QnVpbGRlcik7XG4gICAgICBuZXN0ZWRBc3NlbWJseUJ1aWxkZXIuYnVpbGRBc3NlbWJseSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkZXIuYnVpbGRBc3NlbWJseSgpO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBzdGFjayB0YWdzIGZyb20gaG93IHRoZXkgYXJlIGRlY2FscmVkIGluIHNvdXJjZSBjb2RlIChsb3dlciBjYXNlZClcbiAqIHRvIGhvdyB0aGV5IGFyZSBzdG9yZWQgb24gZGlzayAodXBwZXIgY2FzZWQpLiBJbiByZWFsIHN5bnRoZXNpcyB0aGlzIGlzIGRvbmVcbiAqIGJ5IGEgc3BlY2lhbCB0YWdzIGZvcm1hdHRlci5cbiAqXG4gKiBAc2VlIGF3cy1jZGstbGliL2xpYi9zdGFjay50c1xuICovXG5mdW5jdGlvbiBwYXRjaFN0YWNrVGFncyhtZXRhZGF0YTogeyBbcGF0aDogc3RyaW5nXTogY3hzY2hlbWEuTWV0YWRhdGFFbnRyeVtdIH0pOiB7IFtwYXRoOiBzdHJpbmddOiBjeHNjaGVtYS5NZXRhZGF0YUVudHJ5W10gfSB7XG5cbiAgY29uc3QgY2xvbmVkID0gY2xvbmUobWV0YWRhdGEpIGFzIHsgW3BhdGg6IHN0cmluZ106IGN4c2NoZW1hLk1ldGFkYXRhRW50cnlbXSB9O1xuXG4gIGZvciAoY29uc3QgbWV0YWRhdGFFbnRyaWVzIG9mIE9iamVjdC52YWx1ZXMoY2xvbmVkKSkge1xuICAgIGZvciAoY29uc3QgbWV0YWRhdGFFbnRyeSBvZiBtZXRhZGF0YUVudHJpZXMpIHtcbiAgICAgIGlmIChtZXRhZGF0YUVudHJ5LnR5cGUgPT09IGN4c2NoZW1hLkFydGlmYWN0TWV0YWRhdGFFbnRyeVR5cGUuU1RBQ0tfVEFHUyAmJiBtZXRhZGF0YUVudHJ5LmRhdGEpIHtcblxuICAgICAgICBjb25zdCBtZXRhZGF0YUFueSA9IG1ldGFkYXRhRW50cnkgYXMgYW55O1xuXG4gICAgICAgIG1ldGFkYXRhQW55LmRhdGEgPSBtZXRhZGF0YUFueS5kYXRhLm1hcCgodDogYW55KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHsgS2V5OiB0LmtleSwgVmFsdWU6IHQudmFsdWUgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0U3RhY2soc3RhY2s6IFRlc3RTdGFja0FydGlmYWN0KTogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0IHtcbiAgY29uc3QgYXNzZW1ibHkgPSB0ZXN0QXNzZW1ibHkoeyBzdGFja3M6IFtzdGFja10gfSk7XG4gIHJldHVybiBhc3NlbWJseS5nZXRTdGFja0J5TmFtZShzdGFjay5zdGFja05hbWUpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIG1vY2tlZCBpbnN0YW5jZSBvZiBhIGNsYXNzLCBnaXZlbiBpdHMgY29uc3RydWN0b3JcbiAqXG4gKiBJIGRvbid0IHVuZGVyc3RhbmQgd2h5IGplc3QgZG9lc24ndCBwcm92aWRlIHRoaXMgYnkgZGVmYXVsdCxcbiAqIGJ1dCB0aGVyZSB5b3UgZ28uXG4gKlxuICogRklYTUU6IEN1cnJlbnRseSB2ZXJ5IGxpbWl0ZWQuIERvZXNuJ3Qgc3VwcG9ydCBpbmhlcml0YW5jZSwgZ2V0dGVycyBvclxuICogYXV0b21hdGljIGRldGVjdGlvbiBvZiBwcm9wZXJ0aWVzIChhcyB0aG9zZSBleGlzdCBvbiBpbnN0YW5jZXMsIG5vdFxuICogY2xhc3NlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnN0YW5jZU1vY2tGcm9tPEE+KGN0cjogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gQSk6IGplc3QuTW9ja2VkPEE+IHtcbiAgY29uc3QgcmV0OiBhbnkgPSB7fTtcbiAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN0ci5wcm90b3R5cGUpKSB7XG4gICAgcmV0W21ldGhvZE5hbWVdID0gamVzdC5mbigpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUnVuIGFuIGFzeW5jIGJsb2NrIHdpdGggYSBjbGFzcyAoY29uc3RydWN0b3IpIHJlcGxhY2VkIHdpdGggYSBtb2NrXG4gKlxuICogVGhlIGNsYXNzIGNvbnN0cnVjdG9yIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIGNvbnN0cnVjdG9yIHRoYXQgcmV0dXJuc1xuICogYSBzaW5nbGV0b24sIGFuZCB0aGUgc2luZ2xldG9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBibG9jayBzbyB0aGF0IGl0c1xuICogbWV0aG9kcyBjYW4gYmUgbW9ja2VkIGluZGl2aWR1YWxseS5cbiAqXG4gKiBVc2VzIGBpbnN0YW5jZU1vY2tGcm9tYCBzbyBpcyBzdWJqZWN0IHRvIHRoZSBzYW1lIGxpbWl0YXRpb25zIHRoYXQgaG9sZFxuICogZm9yIHRoYXQgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoTW9ja2VkQ2xhc3NTaW5nbGV0b248QSBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIGtleW9mIEEsIEI+KFxuICBvYmo6IEEsXG4gIGtleTogSyxcbiAgY2I6IChtb2NrOiBBW0tdIGV4dGVuZHMgamVzdC5Db25zdHJ1Y3RhYmxlID8gamVzdC5Nb2NrZWQ8SW5zdGFuY2VUeXBlPEFbS10+PiA6IG5ldmVyKSA9PiBQcm9taXNlPEI+LFxuKTogUHJvbWlzZTxCPiB7XG5cbiAgY29uc3Qgb3JpZ2luYWwgPSBvYmpba2V5XTtcbiAgdHJ5IHtcbiAgICBjb25zdCBtb2NrID0gaW5zdGFuY2VNb2NrRnJvbShvcmlnaW5hbCBhcyBhbnkpO1xuICAgIG9ialtrZXldID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShtb2NrKSBhcyBhbnk7XG4gICAgY29uc3QgcmV0ID0gYXdhaXQgY2IobW9jayBhcyBhbnkpO1xuICAgIHJldHVybiByZXQ7XG4gIH0gZmluYWxseSB7XG4gICAgb2JqW2tleV0gPSBvcmlnaW5hbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aE1vY2tlZDxBIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMga2V5b2YgQSwgQj4ob2JqOiBBLCBrZXk6IEssIGJsb2NrOiAoZm46IGplc3QuTW9ja2VkPEE+W0tdKSA9PiBCKTogQiB7XG4gIGNvbnN0IG9yaWdpbmFsID0gb2JqW2tleV07XG4gIGNvbnN0IG1vY2tGbiA9IGplc3QuZm4oKTtcbiAgKG9iaiBhcyBhbnkpW2tleV0gPSBtb2NrRm47XG5cbiAgbGV0IGFzeW5jRmluYWxseTogYm9vbGVhbiA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IHJldCA9IGJsb2NrKG1vY2tGbiBhcyBhbnkpO1xuICAgIGlmICghaXNQcm9taXNlKHJldCkpIHsgcmV0dXJuIHJldDsgfVxuXG4gICAgYXN5bmNGaW5hbGx5ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0LmZpbmFsbHkoKCkgPT4geyBvYmpba2V5XSA9IG9yaWdpbmFsOyB9KSBhcyBhbnk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKCFhc3luY0ZpbmFsbHkpIHtcbiAgICAgIG9ialtrZXldID0gb3JpZ2luYWw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZTxBPihvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBQcm9taXNlPEE+IHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvYmplY3QpID09PSBvYmplY3Q7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcChtczogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShvayA9PiBzZXRUaW1lb3V0KG9rLCBtcykpO1xufVxuIl19